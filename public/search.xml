<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>currying</title>
    <url>/2020/05/05/JavaScript/currying/</url>
    <content><![CDATA[<h1 id="currying"><a href="#currying" class="headerlink" title="currying"></a>currying</h1><p>函数柯里化是高阶函数的一种应用，currying 又称部分求职。也就是说一个 currying 函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存其拉力。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。</p>
<p>我们举一个例子来进一步认识一下 currying。</p>
<p>假设我们要编写一个计算每月开销的函数，在每天结束之前，我们都要记录今天花掉了多少钱。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> monthlyCost = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cost = <span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">  monthlyCost += money</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cost(<span class="number">100</span>) <span class="comment">// 第1天开销</span></span><br><span class="line">cost(<span class="number">200</span>) <span class="comment">// 第2天开销</span></span><br><span class="line">cost(<span class="number">300</span>) <span class="comment">// 第3天开销</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(monthlyCost)  <span class="comment">//600</span></span><br></pre></td></tr></table></figure>

<p>通过这段代码可以看到，每天结束后我们都会记录并计算到今天为止花掉的钱。但我们其实并不关心每天花掉多少钱，而只想知道到月底的时候回花掉多少钱。也就是说，实际上只需要在月底计算一次。</p>
<p>如果在每个月的前29天，我们都只是保存好当天的开销，知到30天才计算求值，这样就达到了我们的要求。虽然下面的 cost 函数还不是一个 currying 函数的完整实现，但有助于我们了解其思想：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cost = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> money = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = args.length; i &lt; l; i++) &#123;</span><br><span class="line">        money += args[i]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> money</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ;[].push.apply(args, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">cost(<span class="number">100</span>) <span class="comment">// 未真正求值</span></span><br><span class="line">cost(<span class="number">200</span>) <span class="comment">// 未真正求值</span></span><br><span class="line">cost(<span class="number">300</span>) <span class="comment">// 未真正求值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cost()) <span class="comment">//600</span></span><br></pre></td></tr></table></figure>



<p>接下来我们编写一个通用的 <code>function currying(){}</code>，<code>function currying(){}</code> 接受一个参数，即将要被 currying 的函数。在这个例子中，这个函数的作用遍历本月每天的开销并求出它们的总和。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>,args)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      [].push.apply(args,<span class="built_in">arguments</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">arguments</span>.callee</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cost = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,l=<span class="built_in">arguments</span>.length;i&lt;l;i++)&#123;</span><br><span class="line">      money += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> money</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cost = currying(cost)  <span class="comment">// 转化成 currying 函数</span></span><br><span class="line"></span><br><span class="line">cost(<span class="number">100</span>) <span class="comment">// 未真正求值</span></span><br><span class="line">cost(<span class="number">200</span>) <span class="comment">// 未真正求值</span></span><br><span class="line">cost(<span class="number">300</span>) <span class="comment">// 未真正求值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cost()) <span class="comment">//600</span></span><br></pre></td></tr></table></figure>



<p>至此，我们完成了一个 currying 函数的编写。当调用 cost() 时，如果明确带上一个参数，表示此时并不能真正的求值计算，而是把这些参数保存起来，此时让 cost 函数返回另外一个函数。只有当我们以不带参数的形式执行 cost() 时，才利用前面保存的所有参数，真正开始求值计算。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>currying</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie、session和token</title>
    <url>/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/cst/</url>
    <content><![CDATA[<h1 id="cookie、session和token"><a href="#cookie、session和token" class="headerlink" title="cookie、session和token"></a>cookie、session和token</h1><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie是由浏览器生成发送给浏览器，浏览器把cookie以键值对的方式存储在某个目录下的文件中，下一次请求同一网站时会把该cookie发送给服务器。</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>ookie会被附加在每个HTTP请求中，所以无形中增加了流量。</li>
<li>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）</li>
<li>Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。<a id="more"></a>
<h3 id="Cookie，SessionStorage，LocalStorage"><a href="#Cookie，SessionStorage，LocalStorage" class="headerlink" title="Cookie，SessionStorage，LocalStorage"></a>Cookie，SessionStorage，LocalStorage</h3></li>
</ul>
<p>HTML5提供了两种本地存储的方式 sessionStorage 和 localStorage；</p>
<p><img src="cookie.jpg" alt="cookie"></p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session代表会话，服务器为了区分每个客户端，给客户端分配不同的”身份标识”，然后客户端每次想服务器发请求的识货，都带上这个“身份标识”，服务器就知道这个请求是哪个客户端发的了。</p>
<h3 id="过程-服务端session-客户端-sessionId"><a href="#过程-服务端session-客户端-sessionId" class="headerlink" title="过程(服务端session + 客户端 sessionId)"></a>过程(服务端session + 客户端 sessionId)</h3><p><img src="session.jpg" alt="session"></p>
<ol>
<li><p>用户向服务器发送用户名和密码</p>
</li>
<li><p>服务器验证通过后,在当前对话(session)里面保存相关数据,比如用户角色, 登陆时间等;</p>
</li>
<li><p>服务器向用户返回一个<code>session_id</code>, 写入用户的<code>cookie</code></p>
</li>
<li><p>用户随后的每一次请求, 都会通过<code>cookie</code>, 将<code>session_id</code>传回服务器</p>
</li>
<li><p>服务端收到 <code>session_id</code>, 找到前期保存的数据, 由此得知用户的身份</p>
</li>
</ol>
<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token是服务端生成的一串字符串,以作客户端进行请求的令牌,当第一次登陆后,服务器生成一个token便将此token返回给客户端,以后客户端只要带上这个token前来请求数据即可,无需再次带上用户名和密码</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><img src="token.jpg" alt="token"></p>
<ol>
<li>用户通过用户名和密码发送请求</li>
<li>程序验证</li>
<li>程序返回一个签名的token给客户端</li>
<li>客户端储存token, 并且每次用每次发送请求</li>
<li>服务端验证Token并返回数据</li>
</ol>
<h3 id="Token-的用途"><a href="#Token-的用途" class="headerlink" title="Token 的用途"></a>Token 的用途</h3><p>Token 的用途主要有三点：</p>
<ul>
<li>拦截无效请求，降低服务器处理压力；</li>
<li>实现第三方 API 授权，无需每次都输入用户名密码鉴权；</li>
<li>身份校验，防止 CSRF 攻击。</li>
</ul>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JSON Web Token（JWT）是非常流行的跨域身份验证解决方案。</p>
<h4 id="JWT-构成"><a href="#JWT-构成" class="headerlink" title="JWT 构成"></a>JWT 构成</h4><ul>
<li>头部</li>
<li>负载</li>
<li>签名</li>
</ul>
<p>下面是一串 JWT 字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.EJzdDeNLOQhy-2WmXuK1B49xF17Tk0pja1tCPp81YjY</span><br></pre></td></tr></table></figure>

<p>它将被解析为以下三部分：</p>
<h5 id="HEADER-ALGORITHM-amp-TOKEN-TYPE"><a href="#HEADER-ALGORITHM-amp-TOKEN-TYPE" class="headerlink" title="HEADER: ALGORITHM &amp; TOKEN TYPE"></a>HEADER: ALGORITHM &amp; TOKEN TYPE</h5><p>JWT 头部分是一个描述 JWT 元数据的 JSON 对象：</p>
<ul>
<li>alg：表示加密算法，HS256 是 HMAC SHA256 的缩写</li>
<li>typ：token 类型</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PAYLOAD-DATA"><a href="#PAYLOAD-DATA" class="headerlink" title="PAYLOAD: DATA"></a>PAYLOAD: DATA</h5><p>JWT 数据部分，payload 是 JWT 的主体内容部分，也是一个 JSON 字符串，包含需要传递的数据，注意 payload 部分不要存储隐私数据，防止信息泄露</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"iat"</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="VERIFY-SIGNATURE"><a href="#VERIFY-SIGNATURE" class="headerlink" title="VERIFY SIGNATURE"></a>VERIFY SIGNATURE</h5><p>JWT 签名部分是对上面两部分数据加密后生成的字符串，通过 header 指定的算法生成加密字符串，以确保数据不会被篡改。</p>
<p>生成签名时需要使用密钥（即下方示例中的 abcdefg），密钥只保存在服务端，不能向用户公开，它是一个字符串，我们可以自由指定。</p>
<p>生成签名时需要根据 header 中指定的签名算法，并根据下方的公式，即将 header 和 payload 的数据通过 base64加密后用 <code>.</code> 进行连接，然后通过密钥进行 SHA256 加密，由于加入了密钥，所以生成的字符串将无法被破译和篡改，只有在服务端才能还原</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  abcdefg</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们可以在 <a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a> 调试 JWT 字符串</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://jwt.io/" target="_blank" rel="noopener">jwt</a></li>
<li><a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">彻底理解cookie，session，token</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JSON Web Token 入门教程</a></li>
<li><a href="https://www.jianshu.com/p/bd1be47a16c1" target="_blank" rel="noopener">Cookie、Session、Token那点事儿（原创）</a></li>
</ul>
<ul>
<li><a href="https://juejin.im/post/5d01f82cf265da1b67210869#heading-15" target="_blank" rel="noopener">详解 Cookie，Session，Token</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>JS设计模式</title>
    <url>/2020/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="JS设计模式"><a href="#JS设计模式" class="headerlink" title="JS设计模式"></a>JS设计模式</h1><p><strong>设计模式的定义</strong>：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。</p>
<p>通俗一点说，设计模式是在某种场合下对某个问题的一种解决方案。再通俗一点说，设计模式就是给面向对象软件开发中的一些好的设计取个名字。</p>
<h2 id="设计模式存在的意义"><a href="#设计模式存在的意义" class="headerlink" title="设计模式存在的意义"></a>设计模式存在的意义</h2><p>从某些角度来看，设计模式会带来代码量的增加，或许也会把系统的逻辑搞得更复杂。如果使用不当，事情还可能更糟。那设计模式存在的意义是什么呢？</p>
<p>举个简单的例子，我们给一个空房间日复一日的放东西，当然最简单的方法就是直接往里面扔就行了。这样造成的后果，如果以后想从房间找自己想要的东西，就发现会很难。设计模式的存在就好比，我们给房间里面放了一些柜子，虽然柜子会增加我们的成本，但它可以在维护阶段为我们带来好处。</p>
<p>设计模式的作用是让人们写出<strong>可复用</strong>和<strong>可维护性高</strong>的程序。一个程序总是有变化的部分和不变的部分，当我们找出可变部分，并将这些部分封装起来，那么剩下的就是不变和稳定的部分。这些不变和稳定的部分是非常容易复用的。这也是设计模式为什么描写的是可复用面向对象软件基础的原因。</p>
<h2 id="对-JS-设计模式的误解"><a href="#对-JS-设计模式的误解" class="headerlink" title="对 JS 设计模式的误解"></a>对 JS 设计模式的误解</h2><p>虽然 JavaScript 是一门完全面向对象的语言，但在很长一段时间内，JavaScript 在人们的印象中只是用来验证表单，或者完成一些简单动画特效的脚本语言。在 JavaScript 语言上运用设计模式难免显得小题大做。但目前 JavaScript 已成为最流行的语言之一，在许多大型 Web 项目中，JavaScript 代码数量已经非常多。我们绝对有必要把一些优秀的设计模式借鉴到 JavaScript 这门语言中，许多优秀的 JavaScript 开源框架就是运用了不少设计模式。</p>
<p>但对于 JavaScript 的语言特点，和别的面向对象语言的设计模式有所不同。JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。JavaScript 也没有在语言层面提供对抽象类和接口的支持。所以不能照搬。</p>
<h2 id="开启设计模式的大门"><a href="#开启设计模式的大门" class="headerlink" title="开启设计模式的大门"></a>开启设计模式的大门</h2><p>以上可见，设计模式的重要性，对于每一个程序员是必须要会的技能。以前看过一些设计模式方面的资料，但没有进行系统化的总结，印象不够深刻。现在买了一本设计模式的书，准备慢慢的一步一步的揭开设计模式的面纱。在每一个阶段会进行一定的总结，巩固自己的知识。好了废话不多说，让我们开启设计模式的大门吧。</p>
]]></content>
      <categories>
        <category>JS设计模式</category>
      </categories>
      <tags>
        <tag>JS设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>判断对象是否为空</title>
    <url>/2020/04/22/JavaScript/%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/</url>
    <content><![CDATA[<h1 id="判断对象是否是空对象"><a href="#判断对象是否是空对象" class="headerlink" title="判断对象是否是空对象"></a>判断对象是否是空对象</h1><p>本文给出三种判断方式：</p>
<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>用 <code>for...in</code> 遍历对象的键，看对象中是否存在</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123; <span class="comment">// 如果不为空，则会执行到这一步，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果为空,返回false</span></span><br></pre></td></tr></table></figure>



<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>用 <code>JSON.stringify()</code> 方法用于将 JavaScript 值转换为 JSON 字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">JSON</span>.stringify(obj) === <span class="string">'&#123;&#125;'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果为空,返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 如果不为空，则会执行到这一步，返回true</span></span><br></pre></td></tr></table></figure>



<h2 id="ES6新增的方法Object-keys"><a href="#ES6新增的方法Object-keys" class="headerlink" title="ES6新增的方法Object.keys()"></a>ES6新增的方法Object.keys()</h2><p><code>Object.keys()</code> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 如果为空,返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 如果不为空，则会执行到这一步，返回true</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿数量</title>
    <url>/2020/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h1 id="岛屿数量-–-LeetCode"><a href="#岛屿数量-–-LeetCode" class="headerlink" title="岛屿数量 – LeetCode"></a>岛屿数量 – LeetCode</h1><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></p>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>



<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="利用DFS"><a href="#利用DFS" class="headerlink" title="利用DFS"></a>利用DFS</h3><p>利用深度优先遍历的思想，递归遍历每一个岛屿，当这个岛屿被访问过，就将其值设为0，便于下一次递归中，不会在重复遍历。</p>
<p>具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;character[][]&#125; grid</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numIslands = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 利用DFS</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> rows = grid.length</span><br><span class="line">    <span class="keyword">if</span> (rows === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> cols = grid[<span class="number">0</span>].length</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] === <span class="string">'1'</span>)&#123;</span><br><span class="line">                dfs(grid,i,j,rows,cols)</span><br><span class="line">                res++</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">grid,i,j,rows,cols</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;rows<span class="number">-1</span> || j&gt;cols<span class="number">-1</span> || grid[i][j] === <span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="string">'0'</span></span><br><span class="line"></span><br><span class="line">    dfs(grid,i<span class="number">-1</span>,j,rows,cols)</span><br><span class="line">    dfs(grid,i+<span class="number">1</span>,j,rows,cols)</span><br><span class="line">    dfs(grid,i,j<span class="number">-1</span>,rows,cols)</span><br><span class="line">    dfs(grid,i,j+<span class="number">1</span>,rows,cols)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>岛屿数量</tag>
      </tags>
  </entry>
  <entry>
    <title>axios拦截器</title>
    <url>/2020/04/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/axios%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h1 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h1><p>页面发送http请求，很多情况我们要对请求和其响应进行特定的处理；例如每个请求都附带后端返回的token，拿到response之前loading动画的展示等。如果请求数非常多，这样处理起来会非常的麻烦，程序的优雅性也会大打折扣。在这种情况下，axios为开发者提供了这样一个API：拦截器。拦截器分为 请求（request）拦截器和 响应（response）拦截器。</p>
<h2 id="添加请求拦截器"><a href="#添加请求拦截器" class="headerlink" title="添加请求拦截器"></a>添加请求拦截器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="comment">//config是axios请求的参数</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在发送请求之前，对于配置中的token进行一些处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.interceptors.request.use(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置统一的请求头</span></span><br><span class="line">    <span class="keyword">if</span>(cookie.getCookie(<span class="string">'token'</span>))&#123;</span><br><span class="line">        config.headers.Authorization = <span class="string">"Bearer "</span> + cookie.getCookie(<span class="string">"token"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="添加响应拦截器"><a href="#添加响应拦截器" class="headerlink" title="添加响应拦截器"></a>添加响应拦截器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="comment">// response 是请求回来的数据</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题（二）</title>
    <url>/2020/03/03/%E6%AF%8F%E6%97%A5%E9%95%80%E9%87%91/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="每日一题（二）"><a href="#每日一题（二）" class="headerlink" title="每日一题（二）"></a>每日一题（二）</h1><h2 id="常见的网站漏洞有哪些"><a href="#常见的网站漏洞有哪些" class="headerlink" title="常见的网站漏洞有哪些"></a>常见的网站漏洞有哪些</h2><p>有跨站脚本攻击（XSS）、跨站请求伪造（CSRF）、点击劫持、SQL注入、DDOS攻击、DNS劫持</p>
<h2 id="简单介绍一下XSS以及XSS如何防御"><a href="#简单介绍一下XSS以及XSS如何防御" class="headerlink" title="简单介绍一下XSS以及XSS如何防御"></a>简单介绍一下XSS以及XSS如何防御</h2><p>跨站脚本攻击是说攻击者通过注入恶意脚本，在用户浏览页面的时候进行攻击，比如获取cookie或者其他用户身份信息。或者攻击者在论坛中放一个看似安全的连接，骗取用户单击并窃取 cookie 中的用户私密信息；攻击者在论坛中加一个恶意表单，当用户提交表单的时候，将信息传给了攻击者的服务器。</p>
<p>可以分为存储型和反射型：</p>
<ul>
<li>存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击</li>
<li>反射型不存储在数据库中，往往表现为将攻击代码放在URL地址的请求参数中</li>
</ul>
<h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><ol>
<li><strong>转义字符</strong>，对于用户输入的内容进行转义，如对引号、尖括号、斜杠进行转义</li>
<li><strong>CSP</strong>，CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。通常可以通过两种方式实现GSP：<ul>
<li>设置HTTP Header中的Content-Security-Pplicy</li>
<li>设置meta标签方式</li>
</ul>
</li>
<li>输入内容长度控制</li>
<li>HTTP-Only Cookie：禁止JavaScript读取某些敏感Cookie，攻击者完成XSS注入后也无法窃取此Cookie</li>
<li>验证码：防止脚本冒充用户提交危险操作</li>
</ol>
<h2 id="简单介绍一下CSRF-跨站请求伪造-以及如何防御"><a href="#简单介绍一下CSRF-跨站请求伪造-以及如何防御" class="headerlink" title="简单介绍一下CSRF(跨站请求伪造)以及如何防御"></a>简单介绍一下CSRF(跨站请求伪造)以及如何防御</h2><p>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对呗攻击的网站执行某项操作的目的</p>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ol>
<li><strong>同源检测</strong>：验证 HTTP Referer 或者 Origin字段；它记录了该HTTP请求的来源地址</li>
<li><strong>在请求地址中添加token并验证</strong>：服务器下发一个随机Token，每次发送请求时将Token携带上，服务器验证Token是否有效</li>
<li>在HTTP头中自定义属性并验证。把token放到HTTP头的自定义属性里面</li>
<li><strong>不让第三方网站访问到用户Cookie</strong>:可以对设置 <strong>SameSite</strong> 属性。该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但该属性目前并不是所有浏览器都兼容。</li>
</ol>
<h2 id="SQL注入是什么？如何防护？"><a href="#SQL注入是什么？如何防护？" class="headerlink" title="SQL注入是什么？如何防护？"></a>SQL注入是什么？如何防护？</h2><p>SQL注入是把 SQL 命令插入 Web 表单、输入域名或页面请求的查询字符串中，最终达到欺骗服务器执行恶意 SQL 命令。</p>
<p>总的来说，有以下几点防护措施：</p>
<ol>
<li>始终不信任用户的输入，要对用户的输入进行校验，可以通过正则表达式或限制长度，对单引号和双 “-” 进行转换等</li>
<li>始终不要使用动态拼接 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询与存取</li>
<li>始终不要使用管理员权限的数据库连接，为每个应用使用单独的权限和有限的权限数据库连接</li>
<li>不要把机密信息用明文存放，应通过加密或者散列处理密码和敏感的信息</li>
</ol>
<h2 id="判断数组的方法"><a href="#判断数组的方法" class="headerlink" title="判断数组的方法"></a>判断数组的方法</h2><h3 id="Object-property-toString-call"><a href="#Object-property-toString-call" class="headerlink" title="Object.property.toString.call()"></a>Object.property.toString.call()</h3><p>每一个继承 Object 的对象都有 <code>toString</code> 方法，如果 <code>toString</code> 方法没有重写，会返回 <code>[Object type]</code>，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 <code>toString</code> 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或 apply 方法改变 <code>toString</code> 方法的执行上下文</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> an = [<span class="string">'Hello'</span>,<span class="string">'An'</span>];</span><br><span class="line">an.toString(); <span class="comment">// "Hello,An"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(an); <span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure>

<p>这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'An'</span>) <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>(<span class="number">1</span>)) <span class="comment">// "[object Symbol]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;<span class="attr">name</span>: <span class="string">'An'</span>&#125;) <span class="comment">// "[object Object]"</span></span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 的内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p>
<p>使用 <code>instanceof</code>判断一个对象是否为数组，<code>instanceof</code> 会判断这个对象的原型链上是否会找到对应的 <code>Array</code> 的原型，找到返回 <code>true</code>，否则返回 <code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[]  <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但 <code>instanceof</code> 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[]  <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p>该方法用来判断对象是否为数组</p>
<ul>
<li><p>instanceof 与 isArray：</p>
<p>当检测Array实例时，<code>Array.isArray</code> 优于 <code>instanceof</code> ，因为 <code>Array.isArray</code> 可以检测出 <code>iframes</code></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length<span class="number">-1</span>].Array;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correctly checking for Array</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Considered harmful, because doesn't work though iframes</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Array.isArray()</code> 与 <code>Object.prototype.toString.call()</code><br><code>Array.isArray()</code>是ES5新增的方法，当不存在 <code>Array.isArray()</code> ，可以用 <code>Object.prototype.toString.call()</code> 实现。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h2><p>null是一个表示”无”的<strong>对象</strong>，转为数值时为<strong>0</strong>；undefined是一个表示”无”的<strong>原始值</strong>，转为数值时为<strong>NaN</strong>。</p>
<ul>
<li><p>​    null表示”没有对象”，即该处不应该有值</p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象。</li>
<li>作为对象原型链的终点。</li>
</ul>
</li>
<li><p>​    undefined表示”缺省值”，就是此处应该有一个值，但是还没有定义</p>
<ul>
<li>变量被声明了，但没有赋值时，就等于undefined。</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li>
<li>对象没有赋值的属性，该属性的值为undefined。</li>
<li>函数没有返回值时，默认返回undefined。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>每日一题系列</category>
      </categories>
      <tags>
        <tag>Xss</tag>
        <tag>CSRF</tag>
        <tag>判断数组的方法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/04/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>贪心算法是指，在对问题求解时，总是做出<strong>在当前看来最好的选择</strong>。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的<strong>局部最优解</strong>。</p>
<p>贪心算法没有固定的算法框架，算法设计的关键是<strong>贪心策略的选择</strong>。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择贪心策略必须具备无后效性，即<strong>某个状态以后的过程不会影响以前的状态，只与当前状态有关</strong>。</p>
<p>所以对所采取的贪心策略一定要仔细分析其是否满足无后效性。</p>
<h2 id="贪心策略的选择"><a href="#贪心策略的选择" class="headerlink" title="贪心策略的选择"></a>贪心策略的选择</h2><p>因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p>
<h2 id="贪心算法的基本思路"><a href="#贪心算法的基本思路" class="headerlink" title="贪心算法的基本思路"></a>贪心算法的基本思路</h2><ul>
<li>建立数学模型来描述问题</li>
<li>把求解的问题分成若干个子问题</li>
<li>对每一子问题求解，得到子问题的局部最优解</li>
<li>把子问题的局部最优解合成原来解问题的一个解</li>
</ul>
<h2 id="贪心算法适用的问题"><a href="#贪心算法适用的问题" class="headerlink" title="贪心算法适用的问题"></a>贪心算法适用的问题</h2><p>贪心策略适用的前提是：<strong>局部最优策略能导致产生全局最优解</strong>。</p>
<p>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript高级类型</title>
    <url>/2020/04/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TypeScript%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="TypeScript-的高级类型"><a href="#TypeScript-的高级类型" class="headerlink" title="TypeScript 的高级类型"></a>TypeScript 的高级类型</h1><p>TypeScript 提供了高级类型，来满足更多类型的处理，主要分为：</p>
<ul>
<li>交叉类型：多种类型之和</li>
<li>联合类型：多种类型之一</li>
</ul>
<h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>交叉类型是<strong>将多个类型合并为一个类型</strong>。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p>
<p> 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。就是说这个类型的对象同时拥有了这两种类型的成员。</p>
<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; (<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125; <span class="keyword">as</span> T &amp; U</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">    result[id] = first[id] <span class="keyword">as</span> any</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      result[id] = second[id] <span class="keyword">as</span> any</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (public name: string) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Loggable &#123;</span><br><span class="line">  log (): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="title">implements</span> <span class="title">Loggable</span> </span>&#123;</span><br><span class="line">  log () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">'Jim'</span>), <span class="keyword">new</span> ConsoleLogger())</span><br><span class="line"><span class="keyword">var</span> n = jim.name</span><br><span class="line">jim.log()</span><br></pre></td></tr></table></figure>



<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: string, padding: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">' '</span>) + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">padLeft(<span class="string">'Hello world'</span>, <span class="number">4</span>) <span class="comment">// returns "    Hello world"</span></span><br></pre></td></tr></table></figure>

<p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。 这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 TypeScript 却不报错。</p>
<p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: string, padding: string | number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">'Hello world'</span>, <span class="literal">true</span>) <span class="comment">// 编译阶段报错</span></span><br></pre></td></tr></table></figure>

<p>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code> 或 <code>string</code>。</p>
<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">  fly()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Fish &#123;</span><br><span class="line">  swim()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet()</span><br><span class="line">pet.layEggs() <span class="comment">// okay</span></span><br><span class="line">pet.swim()    <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Fish</code> 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 <code>Bird</code> 类型，那么调用 <code>pet.swim()</code> 就出错了。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript高级类型</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝和浅拷贝</title>
    <url>/2020/04/01/JavaScript/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><h2 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝"></a>什么是浅拷贝</h2><p>如果是一个引用类型，比如说一个数组直接赋值给另一个新数组，当对这个新数组进行改变的时候，由于是同一个引用，原来的数组也会跟着改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr;</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[100, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>如果对其进行一次浅拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>当修改newArr的时候，arr的值并不改变。什么原因?因为这里newArr是arr浅拷贝后的结果，newArr和arr现在引用的已经不是同一块空间啦！</p>
<p>但是又会存在一个潜在的问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">val</span>: <span class="number">4</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">2</span>].val = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ 1, 2, &#123; val: 1000 &#125; ]</span></span><br></pre></td></tr></table></figure>

<p>这就是浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，它能 解决无限极的对象嵌套问题，实现彻底的拷贝。</p>
<h2 id="实现浅拷贝的几种方式"><a href="#实现浅拷贝的几种方式" class="headerlink" title="实现浅拷贝的几种方式"></a>实现浅拷贝的几种方式</h2><h3 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">target</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">                cloneTarget[prop] = target[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">'sy'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj, &#123;<span class="attr">name</span>: <span class="string">'sss'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">//&#123; name: 'sss', age: 18 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="concat浅拷贝数组"><a href="#concat浅拷贝数组" class="headerlink" title="concat浅拷贝数组"></a>concat浅拷贝数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat();</span><br><span class="line">newArr[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="slice浅拷贝"><a href="#slice浅拷贝" class="headerlink" title="slice浅拷贝"></a>slice浅拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="…展开运算符"><a href="#…展开运算符" class="headerlink" title="…展开运算符"></a>…展开运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr];<span class="comment">//跟arr.slice()是一样的效果</span></span><br></pre></td></tr></table></figure>



<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">        <span class="comment">//判断obj子元素是否为对象</span></span><br><span class="line">        <span class="keyword">if</span>(obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>)&#123;</span><br><span class="line">          obj[key] = deepClone(obj[key])</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          objClone[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考：<a href="[http://47.98.159.95/my_blog/js-api/005.html#_1-%E7%AE%80%E6%98%93%E7%89%88%E5%8F%8A%E9%97%AE%E9%A2%98](http://47.98.159.95/my_blog/js-api/005.html#_1-简易版及问题)">如何写一个完整的深拷贝？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深拷贝和浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>SPA应用的优缺点</title>
    <url>/2020/04/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SPA%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="SPA应用的优缺点"><a href="#SPA应用的优缺点" class="headerlink" title="SPA应用的优缺点"></a>SPA应用的优缺点</h1><p>SPA（single-page application）仅在 web 页面初始化时加载相应的HTML、JavaScript和CSS。一旦加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交换，避免页面的重新加载。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染</li>
<li>基于上面一点，SPA相对对服务器压力小</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后台负责数据处理</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有页面切换需要自己建立堆栈管理</li>
<li>SEO 难度大：由于所有的内容都在一个页面中动态替换显示，所以在不利于 SEO</li>
</ul>
]]></content>
      <categories>
        <category>SPA</category>
      </categories>
      <tags>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑距离</title>
    <url>/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>难度 <em>困难</em>   运用动态规划的思路进行解题</p>
<p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">LeetCode–编辑距离</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (删除 &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (删除 &apos;e&apos;)</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &apos;t&apos;)</span><br><span class="line">inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)</span><br><span class="line">enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)</span><br><span class="line">exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)</span><br><span class="line">exection -&gt; execution (插入 &apos;u&apos;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>


<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题运用动态规划的思路，自底向下开始求解答案</p>
<ul>
<li><p><code>dp[i][j]</code> 代表 word1 到 i 位置转换成 Word2 到 j 位置需要最少的步数</p>
</li>
<li><p>当 word1[i] == word2[j] 时，由于遍历到了 i 和 j，说明 <code>word1 的 0~i-1 和 word2 的 0~j-1</code> 的匹配结果已经生成，由于当前匹配的单词相同，因此无需做任何操作，<code>dp[i][j] = dp[i-1][j-1]</code></p>
</li>
<li><p>当  word1[i] ！= word2[j] 时，有以下三个操作</p>
<ul>
<li>替换操作： word1 的 <code>0~i-1 和 word2 的 0~j-1</code> 位置字符都相同，只是当前位置字符不匹配，进行替换操作使其相同，所以就有 <code>dp[i][j] = dp[i-1][j-1]+1</code></li>
<li>删除操作： word1 的 <code>0~i-1 和 word2 的 0~j</code> 位置字符已经匹配，此时多出了 word1 的 i 位置字符，应该将其删除，才能使此时 <code>word1 的 0~i</code> (这个i是执行了删除操作后新的i)和 word2 的 0~j 位置匹配,因此此时<code>dp[i][j]=dp[i-1][j]+1</code></li>
<li>插入操作：若此时 <code>word1 的 0~i 位置只是和 word2 的 0~j-1</code> 位置匹配,此时只需要在原来的i位置后面插入一个和 word2 的 j 位置相同的字符使得此时的 <code>word1 的 0~i</code> (这个i是执行了插入操作后新的i)和 word2 的 0~j 匹配得上,所以此时<code>dp[i][j]=dp[i][j-1]+1</code></li>
<li>由于题目所要求的是要最少的操作数:所以当 word1[i]  !=  word2[j] 时,需要在这三个操作中选取一个最小的值赋格当前的<code>dp[i][j]</code></li>
</ul>
</li>
<li><p>状态方程式为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(word1[i] == word2[j]):</span><br><span class="line">	dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="number">1</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; word1</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; word2</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDistance = <span class="function"><span class="keyword">function</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = word1.length,</span><br><span class="line">        n2 = word2.length;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(n1+<span class="number">1</span>),()=&gt;<span class="keyword">new</span> <span class="built_in">Array</span>(n2+<span class="number">1</span>).fill(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">//第一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;=n2;j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n1;i++) dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>编辑距离</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">力扣–三数之和</a></p>
</blockquote>
<a id="more"></a>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul>
<li>首先对数组进行排序，按照从大到小进行排列</li>
<li>遍历每一个元素，用一个元素去找另外两个队友，其中该元素为<code>i</code>，<code>L=i+1</code>，<code>R=len-1</code></li>
<li>根据<code>sum=nums[i]+nums[L]+nums[R]</code>，判断<code>sum</code>是否等于0</li>
<li><code>nums[i]&gt;0</code>，表示三数之和再怎么计算也无法等于0，跳出循环</li>
<li><code>nums[i]==nums[i-1]</code>，表示数据重复，将导致结果重复，跳过</li>
<li><code>sum==0,nums[L]==nums[L+1]</code>，去重，否则结果重复，跳过</li>
<li><code>sum==1,nums[R]==nums[R-1]</code>，同上</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">//三数之和无法等于0，结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] === nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//数据重复，跳过，否则结果重复</span></span><br><span class="line">        <span class="keyword">let</span> L = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> R = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                res.push([nums[i],nums[L],nums[R]]);</span><br><span class="line">                <span class="keyword">while</span>(L&lt;R &amp;&amp; nums[L] === nums[L+<span class="number">1</span>]) L++; <span class="comment">//去重,否则结果重复</span></span><br><span class="line">                <span class="keyword">while</span>(L&lt;R &amp;&amp; nums[R] === nums[R<span class="number">-1</span>]) R--; <span class="comment">//同上</span></span><br><span class="line">                L++;</span><br><span class="line">                R--; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>三数之和</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP缓存</title>
    <url>/2020/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/HTTP%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="Http-缓存"><a href="#Http-缓存" class="headerlink" title="Http 缓存"></a>Http 缓存</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点，主要可分为两点：</p>
<ul>
<li>强缓存</li>
<li>协商缓存</li>
</ul>
<h2 id="什么是HTTP缓存"><a href="#什么是HTTP缓存" class="headerlink" title="什么是HTTP缓存"></a>什么是HTTP缓存</h2><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当Web缓存发现请求资源已经被存储，它会拦截请求，返回该资源的拷贝，而不去起源服务器重新下载。</p>
<p><strong>优点：</strong>缓解服务端压力，提升性能</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>浏览器中的缓存分为两种，一种是需要发送HTTP请求，一种是不需要发送。</p>
<p>首先是检查强缓存，这个阶段<strong>不需要</strong>发送HTTP请求。</p>
<p>在<code>HTTP/1.0</code>和<code>HTTP/1.1</code>当中，这个字段是不一样的。<code>HTTP/1.0</code>使用的是<strong>Expires</strong>，<code>HTTP/1.1</code>使用的是<strong>Cache-Control</strong>。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code>即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Nov <span class="number">2019</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure>

<p>表示资源在<code>2019年11月22号8点41分</code>过期，过期了就得向服务端发请求。</p>
<p>但这种方式存在一个隐患，就是<strong>服务器的时间和浏览器的时间可能不一致</strong>，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的<code>HTTP1.1</code>版本中被抛弃了。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在<code>HTTP1.1</code>中，新增了一个字段：<code>Cache-Control</code>。它和 <code>Expires</code> 本质上不同在于它并没有采取<strong>具体过期时间点</strong> 这个方式，而是采取 <strong>过期时长</strong> 来控制缓存，对应的字段是 <code>max-age</code>。如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cache-Control:max-age=<span class="number">3600</span></span><br></pre></td></tr></table></figure>

<p>代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。</p>
<p><code>Cache-Control</code>有很多指令，完成更多场景的缓存判断, 将一些关键的属性列举如下: </p>
<ul>
<li><strong>public</strong>: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的<code>代理服务器</code>最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。</li>
<li><strong>private</strong>： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</li>
<li><strong>no-cache</strong>: 跳过当前的强缓存，发送HTTP请求，即直接进入<code>协商缓存阶段</code>。</li>
<li><strong>no-store</strong>：非常粗暴，不进行任何形式的缓存。</li>
<li><strong>s-maxage</strong>：这和<code>max-age</code>长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。</li>
</ul>
<p>当<strong>Expires</strong>和<strong>Cache-Control</strong>同时存在的时候，<strong>Cache-Control</strong>会优先考虑。</p>
<p>当资源缓存时间超时了，也就是<strong>强缓存</strong>失效了，就进入<strong>协商缓存</strong>。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存失效之后，浏览器在请求头中携带相应的<code>缓存tag</code>来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是<strong>协商缓存</strong>。</p>
<p>具体来说，这样的缓存tag分为两种: <strong>Last-Modified</strong> 和 <strong>ETag</strong>。这两者各有优劣，并不存在谁对谁有<strong>绝对的优势</strong>，跟上面强缓存的两个 tag 不一样。</p>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</p>
<p>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。</p>
<p>服务器拿到请求头中的<code>If-Modified-Since</code>的字段后，其实会和这个服务器中<code>该资源的最后修改时间</code>对比:</p>
<ul>
<li>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li>
<li>否则返回304，告诉浏览器直接用缓存。</li>
</ul>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p><code>ETag</code> 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过<code>响应头</code>把这个值给浏览器。</p>
<p>浏览器接收到<code>ETag</code>的值，会在下次请求时，将这个值作为<strong>If-None-Match</strong>这个字段的内容，并放到请求头中，然后发给服务器。</p>
<p>服务器接收到<strong>If-None-Match</strong>后，会跟服务器上该资源的<strong>ETag</strong>进行比对:</p>
<ul>
<li>如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li>
<li>否则返回304，告诉浏览器直接用缓存。</li>
</ul>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ol>
<li>在<code>精准度</code>上，<code>ETag</code>优于<code>Last-Modified</code>。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:</li>
</ol>
<ul>
<li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li>
<li>Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li>
</ul>
<ol>
<li>在性能上，<code>Last-Modified</code>优于<code>ETag</code>，也很简单理解，<code>Last-Modified</code>仅仅只是记录一个时间点，而 <code>Etag</code>需要根据文件的具体内容生成哈希值。</li>
</ol>
<p>另外，如果两种方式都支持的话，服务器会优先考虑<code>ETag</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先通过 <code>Cache-Control</code> 验证强缓存是否可用</p>
<ul>
<li><p>如果强缓存可用，直接使用</p>
</li>
<li><p>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-Modified-Since</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-None-Match</span><br></pre></td></tr></table></figure>

<p>字段检查资源是否更新</p>
<ul>
<li>若资源更新，返回资源和200状态码</li>
<li>否则，返回304，告诉浏览器直接从缓存获取资源</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5ca2e0c0f265da30d561ed8b#heading-1" target="_blank" rel="noopener">深入现代浏览器的HTTP缓存机制</a></p>
<p><a href="https://juejin.im/post/5df5bcea6fb9a016091def69" target="_blank" rel="noopener">神三元</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>HTTP缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收机制</title>
    <url>/2020/03/30/%E5%91%A8%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>JavaScript 之所以能在浏览器环境和NodeJs环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行及垃圾回收等整个过程，都离不开它。</p>
<p>下面对垃圾回收做一个归纳总结。</p>
<h2 id="为什么会有垃圾回收？"><a href="#为什么会有垃圾回收？" class="headerlink" title="为什么会有垃圾回收？"></a>为什么会有垃圾回收？</h2><p>JS 语言不想 C/C++，让程序员自己去开辟或释放内存，而是类似Java，采用自己的一套垃圾回收算法进行自动的内存管理。</p>
<p>垃圾回收的喊出是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但如果写代码时不注意，可能导致循环引用等情况，导致内存泄漏。</p>
<h2 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h2><p>在其他的后端语言中，如Java/Go, 对于内存的使用没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，具体来说，在<code>64</code>位系统下，V8最多只能分配<code>1.4G</code>, 在 32 位系统中，最多只能分配<code>0.7G</code>。你想想在前端这样的大内存需求其实并不大，但对于后端而言，nodejs如果遇到一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。</p>
<h3 id="为什么要限制其大小？"><a href="#为什么要限制其大小？" class="headerlink" title="为什么要限制其大小？"></a>为什么要限制其大小？</h3><ul>
<li>js是单线程的执行机制</li>
<li>垃圾回收非常耗时</li>
</ul>
<p>首先JS是单线程执行的，一旦进入到垃圾回收，其它的各种运行逻辑都要暂停；另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的:</p>
<blockquote>
<p>以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式的垃圾回收甚至要 1s 以上。</p>
</blockquote>
<h2 id="js的垃圾回收机制"><a href="#js的垃圾回收机制" class="headerlink" title="js的垃圾回收机制"></a>js的垃圾回收机制</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ol>
<li>标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。</li>
<li>清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。</li>
<li>缺点：垃圾收集后有可能会造成大量的 <strong>内存碎片</strong>。</li>
</ol>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><ol>
<li>引用计数的含义是跟踪记录每个值被引用的次数，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</li>
<li>缺点： 循环引用没法回收。</li>
</ol>
<h2 id="V8垃圾回收机制"><a href="#V8垃圾回收机制" class="headerlink" title="V8垃圾回收机制"></a>V8垃圾回收机制</h2><p>自动垃圾回收有很多算法，由于不同对象的生存周期不同，所以无法只用一种回收策略来解决问题，这样效率会很低。</p>
<p>所以，V8采用了一种代回收的策略，将内存分为两个生代：<strong>新生代（new generation）</strong>和<strong>老生代（old generation）</strong>。</p>
<p><img src="./2.jpg" alt="2"></p>
<p>新生代：临时分配的内存，存活时间较短的对象</p>
<p>老生代：常驻内存，存活时间长的对象</p>
<p>分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫晋升。</p>
<h3 id="分代内存"><a href="#分代内存" class="headerlink" title="分代内存"></a>分代内存</h3><p>默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。</p>
<p>新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。</p>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>首先将新生代内存空间一分为二：</p>
<p><img src="./3.jpg" alt="3"></p>
<p>其中From部分表示正在使用的内存，To是目前闲置的内存。</p>
<p>当进行垃圾回收时，V8将From的对象检查一遍，如果是存活对象那么复制到To内存中（在To内存中按照顺序从头放置），如果是非存活对象直接回收即可。</p>
<p>当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色<code>对调</code>，From现在被闲置，To为正在使用，如此循环。</p>
<p>在To内存中按照顺序从头放置的，这是为了应对这样的场景:</p>
<p><img src="./4.jpg" alt="4"></p>
<p>深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做<strong>内存碎片</strong>。刚刚介绍的新生代垃圾回收算法也叫<strong>Scavenge算法</strong>。</p>
<p>Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:</p>
<p><img src="./5.jpg" alt="5"></p>
<p>不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象<code>一般很少</code>，因此<code>时间</code>性能非常优秀。</p>
<h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到<code>老生代内存</code>中，这种现象就叫<code>晋升</code>。</p>
<p>生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:</p>
<ul>
<li>已经经历过一次 Scavenge 回收。</li>
<li>To（闲置）空间的内存占用超过25%。</li>
</ul>
<p>现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用<code>Scavenge</code>算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是劳民伤财？</p>
<p>V8在老生代中主要采用了<strong>Mark-Sweep</strong>和<strong>Mark-Compact</strong>相结合的方式进行垃圾回收。</p>
<h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h4><p>Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。</p>
<p>与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。</p>
<p>也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。</p>
<p>我们还是通过流程图来看一下：</p>
<p><strong>step1</strong>. 老生代中有对象A、B、C、D、E、F</p>
<img src="./M.jpg" alt="M" style="zoom:50%;" />

<p><strong>step2</strong>. GC进入标记阶段，将A、C、E标记为存活对象</p>
<img src="./MS2.jpg" alt="MS2" style="zoom:50%;" />

<p><strong>step3</strong>. GC进入清除阶段，回收掉死亡的B、D、F对象所占用的内存空间</p>
<img src="./MS3.jpg" alt="MS3" style="zoom:50%;" />

<p>可以看到，Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。</p>
<p>如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p>
<h4 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h4><p>为了解决Mark-Sweep的内存碎片问题，Mark-Compact就被提出来了。</p>
<p><strong>Mark-Compact是标记整理的意思，</strong>是在Mark-Sweep的基础上演变而来的。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。如下图所示：</p>
<p><strong>step1</strong>. 老生代中有对象A、B、C、D、E、F（和Mark—Sweep一样）</p>
<img src="./M.jpg" alt="M" style="zoom:50%;" />



<p><strong>step2</strong>. GC进入标记阶段，将A、C、E标记为存活对象（和Mark—Sweep一样）</p>
<img src="./MS2.jpg" alt="MS2" style="zoom:50%;" />



<p><strong>step3</strong>. GC进入整理阶段，将所有存活对象向内存空间的一侧移动，灰色部分为移动后空出来的空间</p>
<img src="./MC2.jpg" alt="MC2" style="zoom:50%;" />

<p><strong>step4</strong>. GC进入清除阶段，将边界另一侧的内存一次性全部回收</p>
<img src="./MC3.jpg" alt="MC3" style="zoom:50%;" />



<h4 id="两者结合"><a href="#两者结合" class="headerlink" title="两者结合"></a>两者结合</h4><p>在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。</p>
<p>由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>V8的垃圾回收机制分为新生代和老生代。</p>
<p>新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。</p>
<p>老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。</p>
<blockquote>
<p> 参考：</p>
<p><a href="[http://47.98.159.95/my_blog/js-v8/002.html#v8-%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6](http://47.98.159.95/my_blog/js-v8/002.html#v8-内存限制)">V8 引擎如何进行垃圾内存的回收</a></p>
<p><a href="https://juejin.im/post/5ad3f1156fb9a028b86e78be#heading-3" target="_blank" rel="noopener">聊聊V8引擎的垃圾回收</a></p>
</blockquote>
]]></content>
      <categories>
        <category>垃圾回收机制</category>
      </categories>
      <tags>
        <tag>垃圾回收机制</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算符</title>
    <url>/2020/03/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><h2 id="七种位运算符"><a href="#七种位运算符" class="headerlink" title="七种位运算符"></a>七种位运算符</h2><table>
<thead>
<tr>
<th align="center">位运算符</th>
<th align="center">描述</th>
<th align="center">运算规则</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移</td>
<td align="center">各二进制位全部左移若干位，高位丢弃，地位补0</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移</td>
<td align="center">各二进制位全部右移若干位，正数高位补0，负数高位补1</td>
</tr>
<tr>
<td align="center">&gt;&gt;&gt;</td>
<td align="center">无符号右移</td>
<td align="center">各二进制全部右移若干位，高位补0</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">位与</td>
<td align="center">两个位都位1时，结果才为1</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">位或</td>
<td align="center">两个位都是0时，结果才为0</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">位非</td>
<td align="center">0变1,1变0</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">位异或</td>
<td align="center">两个位相同时为0，相异为1</td>
</tr>
</tbody></table>
<p>其中位非（~）是一元运算符，其他都是二元运算符。</p>
<a id="more"></a>

<h2 id="位与运算符（-amp-）"><a href="#位与运算符（-amp-）" class="headerlink" title="位与运算符（&amp;）"></a>位与运算符（&amp;）</h2><p><strong>运算规则</strong>：两个数都为二进制，然后从高位比较，如果两个数都为1则为1，否则为0。</p>
<p><em>例如</em>：130&amp;129</p>
<p>130        =&gt;      10000010<br>129        =&gt;      10000001<br>130&amp;129   =&gt;  10000000  =&gt; 128</p>
<h2 id="左移（-lt-lt-）"><a href="#左移（-lt-lt-）" class="headerlink" title="左移（&lt;&lt;）"></a>左移（&lt;&lt;）</h2><p><strong>运算规则</strong>：各二进位全部左移若干位，高位丢弃，低位补0。</p>
<p><em>例如</em>：6 &lt;&lt; 2 = 24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0110     -&gt; 6</span><br><span class="line">0000 0000 0000 0000 0000 0000 0001 1000     -&gt; 6 &lt;&lt; 2 = 24</span><br></pre></td></tr></table></figure>

<p>我们将6的二进位向左移动两位，低位补上两个0，高位丢弃，得出来的结果就是24。 </p>
<p>左移常被用来做 <code>x * (2 ^ n)</code> 的运算，因为直接基于二进制运算，所以左移效率比 <code>x* (2 ^ n)</code> 高。</p>
<h2 id="右移（-gt-gt-）"><a href="#右移（-gt-gt-）" class="headerlink" title="右移（&gt;&gt;）"></a>右移（&gt;&gt;）</h2><p><strong>运算规则</strong>：各二进位全部右移若干位，正数高位补0，负数高位补1，低位丢弃。</p>
<p><em>例如</em>：12 &gt;&gt; 2 = 3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 1100     -&gt; 12</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0011     -&gt; 12 &gt;&gt; 2 = 3</span><br><span class="line">复</span><br></pre></td></tr></table></figure>

<p>因为12是正数，右移过程中高位补上两个0，低位丢弃，得出来的结果就是3。 例如：-12 &gt;&gt; 2 = -3</p>
<p>负数的二进制 = 正数二进制的反码 + 1</p>
<h2 id="无符号右移（-gt-gt-gt-）"><a href="#无符号右移（-gt-gt-gt-）" class="headerlink" title="无符号右移（&gt;&gt;&gt;）"></a>无符号右移（&gt;&gt;&gt;）</h2><p><strong>运算规则</strong>：各二进位全部右移若干位，高位补0，低位丢弃。</p>
<p>其实无符合右移和右移的区别就是不用关心是正数还是负数，右移时高位都补0。</p>
<p><em>例如</em>：-12 &gt;&gt;&gt; 2 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 0100    -&gt; -12</span><br><span class="line">0011 1111 1111 1111 1111 1111 1111 1101    -&gt; -12 &gt;&gt; 2 = 1073741821</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考:  <a href="https://juejin.im/post/5df1a02ee51d4558181d2a5a#heading-5" target="_blank" rel="noopener">java位运算符</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>位运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>Set和Map</title>
    <url>/2020/03/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Set%E5%92%8CMap/</url>
    <content><![CDATA[<h1 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li><code>Set.prototype.keys()</code>：返回键名的遍历器</li>
<li><code>Set.prototype.values()</code>：返回键值的遍历器</li>
<li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<ul>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 数据结构，类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>
<h3 id="Map-实例的属性和方法"><a href="#Map-实例的属性和方法" class="headerlink" title="Map 实例的属性和方法"></a>Map 实例的属性和方法</h3><p>Map 结构的实例有以下属性和操作方法：</p>
<ul>
<li>size</li>
<li>Map.prototype.set(k,v)：<code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li>
<li>Map.prototype.get(key)</li>
<li>Map.prototype.has(key)</li>
<li>Map.prototype.delete(key)</li>
<li>Map.prototype.clear()</li>
</ul>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>
<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li>
<li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li>
</ul>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p>
<p><code>WeakMap</code>与<code>Map</code>的区别有两点：</p>
<ul>
<li><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</li>
<li><code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</li>
</ul>
<p>参考：<a href="https://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">阮一峰–Set和Map</a></p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Set和Map</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2020/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跨域是一个常考点，平常也有所了解，在这里做一个简单的总结。</p>
<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>跨域是指当前域名下想请求另一个域名下的资源但是由于同源策略的限制，而不能直接发送请求请求。</p>
<h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>同源是指：协议+域名+端口 三者相同，如果缺少同源策略很容易受到XSS、CSFR等攻击。</p>
<h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h3><p>通常为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一个独立域名的服务器上，在html页面中通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p>
<p>利用<code>&lt;script&gt;</code>标签没有跨域限制，将src设置为需要访问的url，并提供一个回调函数来接收数据。只限于get请求。</p>
<p>具体代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url,jsonpCallback,success</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.creatElement(<span class="string">'script'</span>)</span><br><span class="line">    script.src = url</span><br><span class="line">    script.async = <span class="literal">true</span></span><br><span class="line">    script.type = <span class="string">'text/javascript'</span></span><br><span class="line">    <span class="comment">// 约定一个callback字段名，来传递函数名，前端通过该函数来拿到数据</span></span><br><span class="line">    <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        success &amp;&amp; success(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="JSONP的缺点"><a href="#JSONP的缺点" class="headerlink" title="JSONP的缺点"></a>JSONP的缺点</h4><ul>
<li>由于是 <code>script</code> 标签，所以读不到 <code>ajax</code> 那么精确的状态，不知道状态码是什么，也不知道响应头是什么，它只知道成功和失败。</li>
<li>不支持<code>post</code>（因为是 <code>script</code> 标签，所以只支持 <code>get</code> 请求）</li>
</ul>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><h4 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h4><p><code>CORS</code> 的全称是 <strong>跨域资源共享</strong>(Cross-origin resource sharing)。它允许浏览器向跨域服务器，发出 <code>XMLHTTPRequest</code>，从而克服了 AJAX 只能同源使用的限制。</p>
<p>如果<code>wang.com</code>和<code>ergou.com</code>这两个网站都是我的，我就是想让<code>wang.com</code>去访问<code>ergou.com</code>里面的数据应该怎么办呢？</p>
<p>只需要<code>wang.com</code>在响应头里写<code>ergou.com</code>可以访问即可。这就是<code>CORS</code>。</p>
<p>实现<code>CORS</code>通信的关键是服务器。只要服务器实现了<code>CORS</code>接口，就可以跨源通信。</p>
<h4 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h4><p><code>CORS</code> 跨域分为两种请求，一种是<strong>简单请求</strong>，另一种是<strong>复杂请求</strong>。</p>
<h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>只要满足以下条件的就是简单请求：</p>
<ul>
<li><p>请求方式为<code>HEAD</code>、<code>POST</code> 或者 <code>GET</code></p>
</li>
<li><p>http头信息不超出以下字段：<code>Accept</code>、<code>Accept-Language</code> 、 <code>Content-Language</code>、 <code>Last-Event-ID</code>、 <code>Content-Type</code>(限于三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)</p>
</li>
</ul>
<p>简单请求的实现具体来说就是在信息头中加入一个<code>Origin</code>字段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//wang.com</span></span><br><span class="line">Host: api.ergou.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>Origin</code>的作用就是用来说明本次请求来自哪个源，服务器会根据<code>Origin</code>的值来判断是否接受本次请求。</p>
<p>如果<code>Origin</code>所表示的源不被服务器接受，即浏览器发现回应的信息头中没有<code>Access-Control-Allow-Origin</code>字段，就会自动抛出一个错误。</p>
<p>注意：这种错误是无法通过状态码识别的，这也是通过<code>CORS</code>实现跨域请求的一个弊端。</p>
<p>如果<code>Origin</code>所表示的源被服务器端所接受，那么服务器就会返回如下响应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.ergou.com</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Access-Control-Allow-Origin</code> :该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求</p>
</li>
<li><p><code>Access-Control-Allow-Credentials</code>: 该字段可选。它的值是一个布尔值，表示是否允许发送<code>Cookie</code>。默认情况下，<code>Cookie</code>不包括在<code>CORS</code>请求之中。设为<code>true</code>，即表示服务器明确许可，<code>Cookie</code>可以包含在请求中，一起发给服务器。这个值也<strong>只能设为<code>true</code></strong>，如果服务器不要浏览器发送<code>Cookie</code>，删除该字段即可。(注意：如果要发送<code>cookie</code>，不仅要进行上述的设置，还要在<code>AJAX</code>请求中设置<code>withCredentials</code>属性）</p>
</li>
<li><p><code>Access-Control-Expose-Headers</code>:该字段可选。<code>CORS</code>请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</p>
</li>
</ul>
<h5 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h5><p>所谓复杂请求，即不满足上述条件的请求就是复杂请求。</p>
<p>比如请求的方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>复杂请求首先会发起一个预检请求，该请求是 <code>option</code> 方法的，通过该请求来知道服务端是否允许跨域请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://api.wang.com/cors'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>上面的请求就是一个复杂请求，当浏览器发现这是一个复杂请求之后，就会主动发出一个预检请求，询问服务器是否允许本次请求。</p>
<p>服务器收到预检请求之后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，才会做出相应的回应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.wang.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="CORS存在的问题"><a href="#CORS存在的问题" class="headerlink" title="CORS存在的问题"></a>CORS存在的问题</h4><p>不支持<code>IE8/9</code>，如果要在<code>IE8/9</code>使用<code>CORS</code>跨域需要使用<code>XDomainRequest</code>对象来支持<code>CORS</code>。</p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>CORS</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title>for-in和for-of</title>
    <url>/2020/03/13/JavaScript/for-in%E5%92%8Cfor-of/</url>
    <content><![CDATA[<h1 id="for-in-和-for-of"><a href="#for-in-和-for-of" class="headerlink" title="for in 和 for of"></a>for in 和 for of</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li>推荐在循环对象属性的时候，使用<code>for...in</code>,在遍历数组的时候的时候使用<code>for...of</code>。</li>
<li><code>for...in</code>循环出的是key，<code>for...of</code>循环出的是value</li>
<li>注意，<code>for...of</code>是ES6新引入的特性。修复了ES5引入的<code>for...in</code>的不足</li>
<li><code>for...of</code>不能循环普通的对象，需要通过和<code>Object.keys()</code>搭配使用</li>
</ol>
<h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h2><p>for in 作用于数组的话，循环除了遍历数组元素以外，还会遍历自定义属性，如果你的数组中有一个可枚举的类型 a.name，那么循环将额外遍历一次，遍历名为 name 的索引，甚至数组原型上的属性都能访问到，所以不适用于数组的遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// arrCustom</span></span><br><span class="line"><span class="comment">// objCustom</span></span><br></pre></td></tr></table></figure>

<p>遍历了原型对象，在实际工作中是不需要的，多此一举</p>
<p>用 hasOwnProperty</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="keyword">if</span> (arr.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>数组本身的属性还是会遍历出来，用 forEach </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>但是 forEach 只能遍历数组，而且在遍历数组的时候无法 break 或 return false 中断</p>
<h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h2><p>for of 弥补了 for in 循环的所有缺点，一般用于数组的遍历，也支持大部分类数组对象。 </p>
<p><strong>注意:<code>for-of</code>循环不支持普通对象,但是如果你想迭代一个对象的属性,可以使用<code>for-in</code>循环(这也是它的本职工作)或者内建的<code>Object.keys()方法</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student=&#123;</span><br><span class="line">    name:<span class="string">'wujunchuan'</span>,</span><br><span class="line">    age:<span class="number">22</span>,</span><br><span class="line">    locate:&#123;</span><br><span class="line">    country:<span class="string">'china'</span>,</span><br><span class="line">    city:<span class="string">'xiamen'</span>,</span><br><span class="line">    school:<span class="string">'XMUT'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(student))&#123;</span><br><span class="line">    <span class="comment">//使用Object.keys()方法获取对象key的数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(key+<span class="string">": "</span>+student[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还不如用 for in来遍历</p>
<p><strong>for of 的其他应用场景：</strong></p>
<p>for of可以用来迭代字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'boo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br></pre></td></tr></table></figure>

<p>可以迭代 arguments类数组对象，迭代NodeList这类DOM集合，无需<code>[].slice.call()</code>，也不需要<code>Array.from()</code>进行数组转化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> elements = <span class="built_in">document</span>.querySelectorAll(<span class="string">'body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> elements) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element.tagName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// "BODY"</span></span><br></pre></td></tr></table></figure>

<p>还可以迭代类型数组、Map、Set、generators</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/11" target="_blank" rel="noopener">JavaScript中的for-of循环</a></p>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/08/for-in-es6-for-of/" target="_blank" rel="noopener">看，for..in和for..of在那里吵架！</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>for-in 和 for-of</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现new</title>
    <url>/2020/02/22/JavaScript/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0new/</url>
    <content><![CDATA[<h1 id="模拟实现new"><a href="#模拟实现new" class="headerlink" title="模拟实现new"></a>模拟实现new</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今日复习一下new操作符，new是用于创建构造函数的实例，其中创建的实例对象拥有构造函数的属性、方法和原型上的属性和方法。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>分析</strong>：</p>
<p>因为 new 的结构是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，obj会具有构造函数里的属性，根据经典继承的例子，可以使用 Constructor.apply(obj,arguments) 来给 obj 添加新的属性。</p>
<p>根据原型及原型链的知识，我们可以知道实例的 <code>__proto__</code> 属性会指向构造函数的 prototype，所以用这个特性来实现实例访问原型上的属性</p>
<p><strong>代码</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj =  <span class="keyword">new</span> <span class="built_in">Object</span>(), <span class="comment">//从Object.prototype上克隆一个对象</span></span><br><span class="line">        Constructor = [].shift.call(<span class="built_in">arguments</span>); <span class="comment">//取得外部传入的构造器</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj,<span class="built_in">arguments</span>);<span class="comment">//借用外部传入的构造器给obj设置属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;<span class="comment">//确保构造器总是返回一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">参考文献</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>new的模拟实现</tag>
      </tags>
  </entry>
  <entry>
    <title>轮询、长轮询、长连接、websocket</title>
    <url>/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81websocket/</url>
    <content><![CDATA[<h1 id="轮询、长轮询、SSE、websocket"><a href="#轮询、长轮询、SSE、websocket" class="headerlink" title="轮询、长轮询、SSE、websocket"></a>轮询、长轮询、SSE、websocket</h1><h2 id="短轮询和长轮询"><a href="#短轮询和长轮询" class="headerlink" title="短轮询和长轮询"></a>短轮询和长轮询</h2><p>短轮询和长轮询的目的都是用哦关于实现客户端和服务端的一个即时通讯</p>
<h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h3><p>短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。</p>
<p>这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接收请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务端的数据变化</p>
<p><strong>优缺点</strong>：</p>
<p>这种方式的优点就是比较简单，易于理解。</p>
<p>缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务端和客户端的资源。当用户增加时，服务端的压力就会变大。</p>
<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>长轮询的基本思路是，首先由客户端向服务端发送请求，当服务端收到客户端发来的请求后，服务端不会直接进行响应，而是先将这个请求挂起，然后判断服务器数据是否有更新。如果有更新则进行响应，如果一直没有数据，则到达一定的事件限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</p>
<p><strong>优缺点</strong>：</p>
<p>长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。缺点是连接挂起也会导致资源的浪费。</p>
<h2 id="SSE（Sever-Send-Events）"><a href="#SSE（Sever-Send-Events）" class="headerlink" title="SSE（Sever-Send Events）"></a>SSE（Sever-Send Events）</h2><p>SSE是 H5 新增的功能，它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询和短轮询不同，虽然都是基于 http 协议，但是轮询需要客户端先发送请求。而 SSE 最大的特点就是不需要客户端发送请求，可以实现只要服务端数据有更新，就可以马上发送到客户端。</p>
<p>SSE优点就是不需要建立或保持大量的客户端发送服务端的请求，节约了很多资源，提升应用性能。</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。</p>
<p>WebSocket 是 H5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务端主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务端的配置比较复杂。</p>
<p>websocket 是一个全双工协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信，只能有服务端向客户端推送信息，如果客户端需要发送消息就是属于下一个 http 请求了。</p>
<blockquote>
<p>参考资料：<a href="https://cloud.tencent.com/developer/article/1076547" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1076547</a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>轮询</tag>
        <tag>SSE</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于算法之类的问题，知识点还是有点薄弱，今天就来认识一下什么是动态规划算法，查漏补缺，每天学习一点。</p>
<p>动态规划是一种分阶段解决问题的数学思想，简单的来说就是<strong>大事化小，小事化了</strong>。</p>
<p>动态规划中有三个核心概念：</p>
<ul>
<li>最优子结构</li>
<li>边界</li>
<li>状态转移公式</li>
</ul>
<p><strong>举一个例子</strong>：</p>
<p><img src="dp.png" alt="dp"></p>
<p>假设只能通过road1或road2两条路径到达终点，到达road1有x条路径，到达road2有y条路径，所以到达终点的可能性就是 x+y </p>
<p><strong>另一个列子</strong>：</p>
<p>有一个只能容纳10本书的单层书架，你每次只能放1本或2本书。要求用程序求出你将书架填满一共有多少种方法。</p>
<p>从书架上为0到放满的方法总数<strong>等于</strong>0本到9本的方法总数<strong>加</strong>0到8本的方法总数。也就是F(10)=F(8)+F(9)，依次类推得到：<strong>F(n) = F(n-1)+F(n-2)（n&gt;=3）</strong></p>
<ul>
<li>最优子结构：F(10)=F(8)+F(9)</li>
<li>边界：当书架直接只有1 或 2 本书要放时，我们可以直接得到结果，无需花间，我们称F(1)和F(2)为边界。</li>
<li>状态转移公式：F(n) = F(n-1)+F(n-2)</li>
</ul>
<h2 id="leecode"><a href="#leecode" class="headerlink" title="leecode"></a>leecode</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">原题地址</a></p>
<h3 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="robot_maze.png" alt="robot_maze"></p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>说明：</strong> <em>m</em> 和 <em>n</em> 的值均不超过 100。</p>
<blockquote>
<p>示例 1:</p>
<p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; obstacleGrid</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span>(<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.length,</span><br><span class="line">        n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//用数组记录每一次的结果</span></span><br><span class="line">    <span class="keyword">let</span> dp = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i]=[];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 若该节点为0，表示通向该节点的路径为0</span></span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//对于n行1列来说，该节点的路径是依赖于左边的节点</span></span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><blockquote>
<p><a href="https://juejin.im/post/5cde316f6fb9a07ed9118f01#heading-2" target="_blank" rel="noopener">https://juejin.im/post/5cde316f6fb9a07ed9118f01#heading-2</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题</title>
    <url>/2020/02/19/%E6%AF%8F%E6%97%A5%E9%95%80%E9%87%91/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前端面试每日一题"><a href="#前端面试每日一题" class="headerlink" title="前端面试每日一题"></a>前端面试每日一题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习前端也有一年多了，也算是一个入门小菜了。为了更好的提高自己，每天都要学习一点知识，以面试来驱动学习，每天一道大厂前端面试题。让努力成为一种习惯，让奋斗成为一种享受！一定要坚持，不要半途放弃。</p>
<blockquote>
<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md" target="_blank" rel="noopener">题库</a></p>
</blockquote>
<h2 id="‘1’-‘2’-‘3’-map-parseInt-what-amp-why-2020-02-18"><a href="#‘1’-‘2’-‘3’-map-parseInt-what-amp-why-2020-02-18" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ? (2020/02/18)"></a>[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ? (2020/02/18)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>].map(<span class="built_in">parseInt</span>); <span class="comment">//[1, NaN, NaN]</span></span><br></pre></td></tr></table></figure>

<h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h3><p><code>parseInt()</code> 函数解析一个字符串参数，并返回一个指定基数的整数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intValue = <span class="built_in">parseInt</span>(string[, radix]);</span><br></pre></td></tr></table></figure>

<p><code>string</code> 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。</p>
<p><code>radix</code> 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。</p>
<p><code>返回值</code> 返回一个整数或NaN。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>, <span class="number">10</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>, <span class="number">2</span>); <span class="comment">// 4 -&gt; converts 100 in base 2 to base 10</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><br>在<code>radix</code>为 undefined，或者<code>radix</code>为 0 或者没有指定的情况下，JavaScript 作如下处理：</p>
<ul>
<li>如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).</li>
<li>如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。</li>
<li>如果字符串 string 以其它任何值开头，则基数是10 (十进制)。</li>
</ul>
<p>更多详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener">parseInt | MDN</a></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var new_array = arr.map(function callback(currentValue[,index[, array]]) &#123;</span><br><span class="line"> // Return element for new_array</span><br><span class="line"> &#125;[, thisArg])</span><br></pre></td></tr></table></figure>

<p>可以看到<code>callback</code>回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。<br><code>currentValue</code> 是callback 数组中正在处理的当前元素。<br><code>index</code>可选, 是callback 数组中正在处理的当前元素的索引。<br><code>array</code>可选, 是callback map 方法被调用的数组。<br>另外还有<code>thisArg</code>可选, 执行 callback 函数时使用的this 值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">arr.map((num) =&gt; num + 1); // [2, 3, 4]</span><br></pre></td></tr></table></figure>

<p>更多详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">Array.prototype.map() | MDN</a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于每个迭代<code>map</code>, <code>parseInt()</code>传递两个参数: <strong>字符串和基数</strong>。<br>所以实际执行的的代码是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>(item, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>即返回的值分别为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>) <span class="comment">// NaN, 3 不是二进制</span></span><br></pre></td></tr></table></figure>

<p>所以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="built_in">parseInt</span>)</span><br><span class="line"><span class="comment">// 1, NaN, NaN</span></span><br></pre></td></tr></table></figure>



<h2 id="什么是防抖和节流？有什么区别？如何实现？-2020-02-19"><a href="#什么是防抖和节流？有什么区别？如何实现？-2020-02-19" class="headerlink" title="什么是防抖和节流？有什么区别？如何实现？(2020/02/19)"></a>什么是防抖和节流？有什么区别？如何实现？(2020/02/19)</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则将取消前一次并重新计算执行时间。</p>
<p><strong>思路</strong>：</p>
<p>每次触发事件时都取消之前的延时调用方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">delay, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            cb();</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>函数节流的基本思想是函数预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p>
<p><strong>思路</strong>：</p>
<p>每次触发事件时都判断当前是否有等待执行的延时函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> canRun = <span class="literal">true</span>; <span class="comment">// 通过闭包保存一个标记</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>; <span class="comment">// 在函数开头判断标记是否为true，不为true则return</span></span><br><span class="line">        canRun = <span class="literal">false</span>; <span class="comment">// 立即设置为false</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 将外部传入的函数的执行放在setTimeout中</span></span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">            <span class="comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span></span><br><span class="line">            canRun = <span class="literal">true</span>;</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="介绍下-Set、Map、WeakSet-和-WeakMap-的区别？"><a href="#介绍下-Set、Map、WeakSet-和-WeakMap-的区别？" class="headerlink" title="介绍下 Set、Map、WeakSet 和 WeakMap 的区别？"></a>介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</h2><p>Set 和 Map 主要的应用场景在于 <strong>数组重组</strong> 和 <strong>数据存储</strong></p>
<p>Set是一种叫做<strong>集合</strong>的数据结构，Map是一种叫做<strong>字典</strong>的数据结构</p>
<h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><p>ES6 新增的一种新的数据结构，只有键值，没有键名，类似于数组，但成员是唯一且无序的，没有重复的值。</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 对象允许你将<strong>弱引用对象</strong>存储在一个集合中</p>
<p>WeakSet 与 Set 的区别：</p>
<ul>
<li>WeakSet 只能存储对象引用，不能存放值，而 Set 对象都可以</li>
<li>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的引用，如果没有其他的变量或属性引用这个对象值，则这个对象将被垃圾回收掉。</li>
</ul>
<h3 id="字典（Map）"><a href="#字典（Map）" class="headerlink" title="字典（Map）"></a>字典（Map）</h3><p><strong>集合</strong> 与 <strong>字典</strong> 与的区别：</p>
<ul>
<li>共同点：集合、字典可以存储不重复的值</li>
<li>不同点：集合是以[value,value]的形式存储元素，字典是以[key,value]的形式存储</li>
</ul>
<p><strong>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构</strong>都可以当作<code>Map</code>构造函数的参数，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([</span><br><span class="line">  ['foo', 1],</span><br><span class="line">  ['bar', 2]</span><br><span class="line">]);</span><br><span class="line">const m1 = new Map(<span class="keyword">set</span>);</span><br><span class="line">m1.<span class="keyword">get</span>('foo') // 1</span><br><span class="line"></span><br><span class="line">const m2 = new Map([['baz', 3]]);</span><br><span class="line">const m3 = new Map(m2);</span><br><span class="line">m3.<span class="keyword">get</span>('baz') // 3</span><br></pre></td></tr></table></figure>

<p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。</p>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakMap 对象是一组键值对的集合，其中的<strong>键是弱引用对象，而值可以是任意</strong>。</p>
<p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Set<ul>
<li>成员唯一、无序且不重复</li>
<li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）</li>
<li>可以遍历，方法有：add、delete、has</li>
</ul>
</li>
<li>WeakSet<ul>
<li>成员都是对象</li>
<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏</li>
<li>不能遍历，方法有add、delete、has</li>
</ul>
</li>
<li>Map<ul>
<li>本质上是键值对的集合，类似集合</li>
<li>可以遍历，方法很多可以跟各种数据格式转换</li>
</ul>
</li>
<li>WeakMap<ul>
<li>只接受对象作为键名（null除外），不接受其他类型的值作为键名</li>
<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li>
<li>不能遍历，方法有get、set、has、delete</li>
</ul>
</li>
</ul>
<h2 id="介绍下深度优先遍历和广度优先遍历，如何实现？（2020-02-21）"><a href="#介绍下深度优先遍历和广度优先遍历，如何实现？（2020-02-21）" class="headerlink" title="介绍下深度优先遍历和广度优先遍历，如何实现？（2020/02/21）"></a>介绍下深度优先遍历和广度优先遍历，如何实现？（2020/02/21）</h2><p>深度优先遍历和广度优先遍历是图和树的两种遍历算法。</p>
<p>深度优先：找到一个节点后，把它的后辈都找出来，最常用递归法。<br>广度优先：找到一个节点后，把他同级的兄弟节点都找出来放在前边，把孩子放到后边，最常用 while</p>
<blockquote>
<p>详情请见：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9</a></p>
</blockquote>
<h2 id="ES5-ES6-的继承除了写法以外还有什么区别？（2020-02-22）"><a href="#ES5-ES6-的继承除了写法以外还有什么区别？（2020-02-22）" class="headerlink" title="ES5/ES6 的继承除了写法以外还有什么区别？（2020/02/22）"></a>ES5/ES6 的继承除了写法以外还有什么区别？（2020/02/22）</h2><blockquote>
<p>详情请见：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20</a></p>
</blockquote>
<h2 id="setTimeout、Promise、Async-Await-的区别"><a href="#setTimeout、Promise、Async-Await-的区别" class="headerlink" title="setTimeout、Promise、Async/Await 的区别"></a>setTimeout、Promise、Async/Await 的区别</h2><blockquote>
<p>详情请见：<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33</a></p>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>坚持</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的进制转换</title>
    <url>/2020/02/29/JavaScript/JavaScript%E7%9A%84%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="JavaScript的进制转换"><a href="#JavaScript的进制转换" class="headerlink" title="JavaScript的进制转换"></a>JavaScript的进制转换</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在刷算法题的时候，突然碰到了进制转换的相关问题。以前就有所了解，但还是做一下总结吧。</p>
<h2 id="神奇的JavaScript"><a href="#神奇的JavaScript" class="headerlink" title="神奇的JavaScript"></a>神奇的JavaScript</h2><p>JS 是一个很神奇的语言，内置的很多函数可以帮我们进行进制转换。</p>
<p>JS中可以直接使用16进制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0x5f</span>; <span class="comment">//95</span></span><br></pre></td></tr></table></figure>



<p>将任意进制字符串转换为十进制，利用parseInt()，其中第一个参数为需要转换的字符串；第二个参数从 <code>2</code> 到 <code>36</code>，代表该进位系统的数字，如果不传默认为十进制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"11"</span>, <span class="number">2</span>); <span class="comment">// 3 2进制转10进制 </span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"77"</span>, <span class="number">8</span>); <span class="comment">// 63 8进制转10进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"af"</span>, <span class="number">16</span>); <span class="comment">//175 16进制转10进制</span></span><br></pre></td></tr></table></figure>



<p>将10进制转换为2进制，八进制，十六进制字符串<br>Object.toString(n) : 即 (n) 表示进制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">152</span>).toString(<span class="number">2</span>) <span class="comment">// "10011000" ; 先用括号将152转换“包”成一个对象， 或者如下写法;</span></span><br><span class="line"><span class="number">152.</span>.toString(<span class="number">2</span>) <span class="comment">// 这里第一个点将152转换成float类型的小数，第二个点是引出对象方法;</span></span><br><span class="line"><span class="number">152.</span>.toString(<span class="number">16</span>) <span class="comment">// "98" : 十进制转16进制</span></span><br><span class="line"><span class="number">152.</span>.toString(<span class="number">32</span>) <span class="comment">// "4o" ：十提制转32进制</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2020/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/HTTP/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>超文本传输协议（HyperText Transfer Protocol）</p>
<p>HTTP协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据时，会发出一次HTTP请求。HTTP会通过TCP建立起一个到服务器的连接通道，当本次请求完毕后，HTTP会立即将TCP连接断开，这个过程很短。所以HTTP连接是一个短连接，是一种无状态连接。</p>
<h2 id="http传输流"><a href="#http传输流" class="headerlink" title="http传输流"></a>http传输流</h2><p><img src="https://user-gold-cdn.xitu.io/2018/4/17/162d19df66466f6b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>常用状态码：</p>
<h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>
<li>206 Partial Content，进行范围请求</li>
</ul>
<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的URL</li>
<li>303 see other，表示资源存在着另一个URL，应使用GET方法定向获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redirect，临时重定向，和302含义相同</li>
</ul>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul>
<li>400 bad request，请求报文存在语法错误</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
</ul>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul>
<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>
</ul>
<h2 id="http1-0-http1-1-http2-0-特性及区别"><a href="#http1-0-http1-1-http2-0-特性及区别" class="headerlink" title="http1.0 http1.1 http2.0 特性及区别"></a>http1.0 http1.1 http2.0 特性及区别</h2><h3 id="http1-0特性"><a href="#http1-0特性" class="headerlink" title="http1.0特性"></a>http1.0特性</h3><ul>
<li>无状态：服务器不跟踪记录请求过的状态</li>
<li>无连接：浏览器每次请求都需要建立tcp连接</li>
</ul>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录</p>
<h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>无连接导致性能缺陷有两种：</p>
<ol>
<li>无复用连接：<br>每次发送请求都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低</li>
<li>队头阻塞<br>http1.0规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也会阻塞</li>
</ol>
<h3 id="http1-1特性"><a href="#http1-1特性" class="headerlink" title="http1.1特性"></a>http1.1特性</h3><p>http1.1的出现是为了解决http1.0性能缺陷</p>
<p>http1.1特性：</p>
<ul>
<li>长连接：新增connection字段，可以设置keep-alive值保持连接不断开</li>
<li>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回</li>
<li>缓存处理：新增字段cache-control</li>
<li>断点传输</li>
</ul>
<h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>http1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据</p>
<h4 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h4><p>基于长连接的基础，我们先看没有管道化请求响应：</p>
<p>tcp没有断开，用的同一个通道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</span><br></pre></td></tr></table></figure>

<p>管道化的请求响应：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求1 --&gt; 请求2 --&gt; 请求3 &gt; 响应1 --&gt; 响应2 --&gt; 响应3</span><br></pre></td></tr></table></figure>

<p>即使服务器先准备好响应2,也是按照请求顺序先返回响应1</p>
<p>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p>
<h4 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h4><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求</p>
<p>通过设置字段cache-control来控制</p>
<h4 id="断点传输"><a href="#断点传输" class="headerlink" title="断点传输"></a>断点传输</h4><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p>
<p>在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range</p>
<h3 id="http2-0特性"><a href="#http2-0特性" class="headerlink" title="http2.0特性"></a>http2.0特性</h3><ul>
<li>二进制分帧</li>
<li>多路复用：在共享TCP连接的基础上同时发送请求和响应</li>
<li>头部压缩</li>
<li>服务器推送：服务器可以额外的项客户端推送资源，而无需客户端明确的请求</li>
</ul>
<h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>http1.0 到http1.1的主要区别，就是从无连接到长连接</li>
<li>http2.0对比1.X版本主要区别就是多路复用</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>http1.0 http1.1 http2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="归并排序、快速排序、希尔排序、堆排序"><a href="#归并排序、快速排序、希尔排序、堆排序" class="headerlink" title="归并排序、快速排序、希尔排序、堆排序"></a>归并排序、快速排序、希尔排序、堆排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之所以把这几类排序放在一起比较，是因为它们的平均时间复杂度都为 <code>O(nlogn)</code> </p>
<h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分进行排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p>归并排序采用的是 <code>分治思想</code>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400a4920693?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="merge-sort-example.png"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 拆分成两个子数组</span></span><br><span class="line">  <span class="keyword">let</span> left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">    right = arr.slice(middle);</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="comment">// 比较两个数组大小排序</span></span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length) result.push(left.shift());</span><br><span class="line">  <span class="keyword">while</span> (right.length) result.push(right.shift());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr :'</span>, mergeSort(arr));</span><br><span class="line"><span class="comment">// arr : [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>

<p>空间复杂度O(n)，时间复杂度O(nlogn)</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400a943f4fc?imageslim" alt="merge-sort.gif"></p>
<h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p>快速排序顾名思义速度快，而且效率高，是处理大数据最快的排序算法之一。</p>
<h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><ul>
<li>先找到一个基准点（一般只数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，小的放左边，反之放右边</li>
<li>左右分别用一个空数组存储比较后的数据</li>
<li>循环执行上述操作</li>
</ul>
<p>特点： 快速，常用<br>缺点： 需要另外声明两个数组，浪费了内存空间资源</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 取基准点</span></span><br><span class="line">  <span class="keyword">var</span> pivot = arr.splice(pivotIndex,<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> left = [] <span class="comment">//存放比基准点小的数组</span></span><br><span class="line">  <span class="keyword">var</span> right = [] <span class="comment">//存放比基准点大的数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat(pivot,quickSort(right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(array));</span><br><span class="line"><span class="comment">//[17, 24, 31, 45,50, 63, 85, 96]</span></span><br></pre></td></tr></table></figure>

<h3 id="归并和快排的区别"><a href="#归并和快排的区别" class="headerlink" title="归并和快排的区别"></a>归并和快排的区别</h3><p>快排和归并都是用分治思想，也是利用递归实现，它们之间的区别在哪里呢？</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400af40f991?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="快速排序与归并排序"></p>
<p>区别：</p>
<ul>
<li>归并排序的处理过程是<code>由下而上</code>的，先处理子问题，然后再合并。</li>
<li>而快排正好相反，它的处理过程是<code>由上而下</code>的，先分区，然后再处理子问题。</li>
<li>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。</li>
<li>归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。</li>
<li>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</li>
</ul>
<h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><ul>
<li>先将整个待排序的记录序列分割成为若干子序列</li>
<li>分别进行直接插入排序</li>
<li>待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>举个易于理解的例子：[35, 33, 42, 10, 14, 19, 27, 44]，我们采取间隔 4。创建一个位于 4 个位置间隔的所有值的虚拟子列表。下面这些值是 { 35, 14 }，{ 33, 19 }，{ 42, 27 } 和 { 10, 44 }。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400c7272496?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="栗子"></p>
<ol start="2">
<li>我们比较每个子列表中的值，并在原始数组中交换它们（如果需要）。完成此步骤后，新数组应如下所示。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400d228f608?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="栗子"></p>
<ol start="3">
<li>然后，我们采用 2 的间隔，这个间隙产生两个子列表：{ 14, 27, 35, 42 }， { 19, 10, 33, 44 }。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400d8c0378c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="栗子"></p>
<ol start="4">
<li>我们比较并交换原始数组中的值（如果需要）。完成此步骤后，数组变成：[14, 10, 27, 19, 35, 33, 42, 44]，图如下所示，10 与 19 的位置互换一下。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400deeea4b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p>
<ol start="5">
<li>最后，我们使用值间隔 1 对数组的其余部分进行排序，Shell sort 使用插入排序对数组进行排序。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400f86526f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="栗子"></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shellSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length,</span><br><span class="line">    temp, gap = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 动态定义间隔序列</span></span><br><span class="line">    gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      temp = arr[i];</span><br><span class="line">      <span class="keyword">let</span> j = i - gap;</span><br><span class="line">      <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">        arr[j + gap] = arr[j]</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + gap] = temp;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'arr  :'</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">35</span>, <span class="number">33</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">44</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'原始array:'</span>, array);</span><br><span class="line"><span class="keyword">const</span> newArr = shellSort(array);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'newArr:'</span>, newArr);</span><br><span class="line"><span class="comment">// 原始 array:   [35, 33, 42, 10, 14, 19, 27, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 33, 42, 10, 35, 19, 27, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 19, 42, 10, 35, 33, 27, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [10, 14, 19, 27, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [10, 14, 19, 27, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]</span></span><br><span class="line"><span class="comment">// newArr:     [10, 14, 19, 27, 33, 35, 42, 44]</span></span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>第一，希尔排序是原地排序算法吗 ？ 希尔排序过程中，只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1) 。所以，希尔排序是<code>原地排序</code>算法。</li>
<li>第二，希尔排序是稳定的排序算法吗 ？ 我们知道，单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素相对顺序发生变化。 因此，希尔排序<code>不稳定</code>。</li>
<li>第三，希尔排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n logn)。 最差情况：T(n) = O(n (log(n))2)。 平均情况：T(n) = 取决于间隙序列。</li>
</ul>
<h3 id="动画-1"><a href="#动画-1" class="headerlink" title="动画"></a>动画</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400f870146a?imageslim" alt="shell-sort.gif"></p>
<h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p><strong>堆的定义</strong></p>
<p>堆其实是一种特殊的树。只要满足这两点，它就是一个堆。</p>
<ul>
<li>堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li>
<li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</li>
</ul>
<p>对于每个节点的值都<code>大于等于</code>子树中每个节点值的堆，我们叫作<code>大顶堆</code>。 对于每个节点的值都<code>小于等于</code>子树中每个节点值的堆，我们叫作<code>小顶堆</code>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f40107bab9d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="区分堆、大顶堆、小顶堆"></p>
<p>其中图 1 和 图 2 是大顶堆，图 3 是小顶堆，图 4 不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。</p>
<h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><ol>
<li>将初始待排序关键字序列 (R1, R2 …. Rn) 构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1, R2, ….. Rn-1) 和新的有序区 (Rn) ，且满足 R[1, 2 … n-1] &lt;= R[n]。</li>
<li>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1, R2 …… Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1, R2 …. Rn-2) 和新的有序区 (Rn-1, Rn)。不断重复此过程，直到有序区的元素个数为 n - 1，则整个排序过程完成。</li>
</ol>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="keyword">const</span> heapSort = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.time(<span class="string">'堆排序耗时'</span>);</span><br><span class="line">	<span class="comment">// 初始化大顶堆，从第一个非叶子结点开始</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		heapify(array, i, array.length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排序，每一次 for 循环找出一个当前最大值，数组长度减一</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(array.length - <span class="number">1</span>); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="comment">// 根节点与最后一个节点交换</span></span><br><span class="line">		swap(array, <span class="number">0</span>, i);</span><br><span class="line">		<span class="comment">// 从根节点开始调整，并且最后一个结点已经为当前最大值，不需要再参与比较，所以第三个参数为 i，即比较到最后一个结点前一个即可</span></span><br><span class="line">		heapify(array, <span class="number">0</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.timeEnd(<span class="string">'堆排序耗时'</span>);</span><br><span class="line">	<span class="keyword">return</span> array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个节点</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">array, i, j</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> temp = array[i];</span><br><span class="line">	array[i] = array[j];</span><br><span class="line">	array[j] = temp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 i 结点以下的堆整理为大顶堆，注意这一步实现的基础实际上是：</span></span><br><span class="line"><span class="comment">// 假设结点 i 以下的子堆已经是一个大顶堆，heapify 函数实现的</span></span><br><span class="line"><span class="comment">// 功能是实际上是：找到 结点 i 在包括结点 i 的堆中的正确位置。</span></span><br><span class="line"><span class="comment">// 后面将写一个 for 循环，从第一个非叶子结点开始，对每一个非叶子结点</span></span><br><span class="line"><span class="comment">// 都执行 heapify 操作，所以就满足了结点 i 以下的子堆已经是一大顶堆</span></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function">(<span class="params">array, i, length</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> temp = array[i]; <span class="comment">// 当前父节点</span></span><br><span class="line">	<span class="comment">// j &lt; length 的目的是对结点 i 以下的结点全部做顺序调整</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span> * i + <span class="number">1</span>; j &lt; length; j = <span class="number">2</span> * j + <span class="number">1</span>) &#123;</span><br><span class="line">		temp = array[i]; <span class="comment">// 将 array[i] 取出，整个过程相当于找到 array[i] 应处于的位置</span></span><br><span class="line">		<span class="keyword">if</span> (j + <span class="number">1</span> &lt; length &amp;&amp; array[j] &lt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">			j++; <span class="comment">// 找到两个孩子中较大的一个，再与父节点比较</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp &lt; array[j]) &#123;</span><br><span class="line">			swap(array, i, j); <span class="comment">// 如果父节点小于子节点:交换；否则跳出</span></span><br><span class="line">			i = j; <span class="comment">// 交换后，temp 的下标变为 j</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'原始array:'</span>, array);</span><br><span class="line"><span class="keyword">const</span> newArr = heapSort(array);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'newArr:'</span>, newArr);</span><br><span class="line"><span class="comment">// 原始 array:  [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]</span></span><br><span class="line"><span class="comment">// 堆排序耗时: 0.15087890625ms</span></span><br><span class="line"><span class="comment">// newArr:     [1, 2, 2, 3, 4, 5, 5, 6, 8, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>第一，堆排序是原地排序算法吗 ？ 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。</p>
</li>
<li><p>第二，堆排序是稳定的排序算法吗 ？ 因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。 所以，堆排序是<code>不稳定</code>的排序算法。</p>
</li>
<li><p>第三，堆排序的时间复杂度是多少 ？ 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。 最佳情况：T(n) = O(nlogn)。 最差情况：T(n) = O(nlogn)。 平均情况：T(n) = O(nlogn)。</p>
</li>
</ul>
<h3 id="动画-2"><a href="#动画-2" class="headerlink" title="动画"></a>动画</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f40108015de8?imageslim" alt="heap-sort.gif"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f4011e30a700?imageslim" alt="heap-sort2.gif"></p>
<h2 id="排序算法的复杂性对比"><a href="#排序算法的复杂性对比" class="headerlink" title="排序算法的复杂性对比"></a>排序算法的复杂性对比</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">最好</th>
<th align="center">平均</th>
<th align="center">最坏</th>
<th align="center">内存</th>
<th align="center">稳定性</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">归并排序</td>
<td align="center">nlog(n)</td>
<td align="center">nlog(n)</td>
<td align="center">nlog(n)</td>
<td align="center">n</td>
<td align="center">Yes</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">nlog(n)</td>
<td align="center">nlog(n)</td>
<td align="center">n2</td>
<td align="center">log(n)</td>
<td align="center">No</td>
<td align="center">在 in-place 版本下，内存复杂度通常是 O(log(n))</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">nlog(n)</td>
<td align="center">取决于差距序列</td>
<td align="center">n(log(n))2</td>
<td align="center">1</td>
<td align="center">No</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">nlog(n)</td>
<td align="center">nlog(n)</td>
<td align="center">nlog(n)</td>
<td align="center">1</td>
<td align="center">No</td>
<td align="center">…</td>
</tr>
</tbody></table>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢前辈的文章：</p>
<ul>
<li><a href="https://juejin.im/post/5d371aa6e51d455d850d3bbe" target="_blank" rel="noopener">数据结构与算法之美</a></li>
</ul>
<ul>
<li><a href="https://segmentfault.com/a/1190000015487916" target="_blank" rel="noopener">JS 实现堆排序</a></li>
<li><a href="https://time.geekbang.org/column/article/41913" target="_blank" rel="noopener">数据结构与算法之美</a></li>
<li><a href="https://juejin.im/post/57dcd394a22b9d00610c5ec8" target="_blank" rel="noopener">十大经典排序算法总结（JavaScript 描述）</a></li>
<li><a href="https://juejin.im/post/58c9d5fb1b69e6006b686bce" target="_blank" rel="noopener">JS 中可能用得到的全部的排序算法</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
        <tag>快速排序</tag>
        <tag>希尔排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟实现call、apply和bind</title>
    <url>/2020/02/22/JavaScript/call%E3%80%81apply%E5%92%8Cbind/</url>
    <content><![CDATA[<h1 id="模拟实现call、apply和bind"><a href="#模拟实现call、apply和bind" class="headerlink" title="模拟实现call、apply和bind"></a>模拟实现call、apply和bind</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>手动实现call、apply和bind是面试常考题，对这方面做一次梳理。</p>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;<span class="comment">//此处this是指调用myCall的function</span></span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn; <span class="comment">//将该函数删除</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.protptype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">        result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = context.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> != <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'not a function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> resFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> resFn?<span class="keyword">this</span>:context,args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>模拟实现call、apply和bind</tag>
      </tags>
  </entry>
  <entry>
    <title>数组降维</title>
    <url>/2019/12/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4/</url>
    <content><![CDATA[<h1 id="数组降维"><a href="#数组降维" class="headerlink" title="数组降维"></a>数组降维</h1><h2 id="二维数组降一维数组"><a href="#二维数组降一维数组" class="headerlink" title="二维数组降一维数组"></a>二维数组降一维数组</h2><p>以 <code>var oldArr=[1, 2, [3, 4]];</code> 为例：</p>
<ul>
<li><p>reduce() 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = oldArr.reduce(<span class="function">(<span class="params">accu,curr</span>)=&gt;</span>&#123;<span class="keyword">return</span> accu.concat(curr)&#125;,[])</span><br></pre></td></tr></table></figure>
</li>
<li><p>concat() 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = [].concat(...oldArr)</span><br><span class="line"><span class="keyword">var</span> newArr2 = <span class="built_in">Array</span>.prototype.concat.apply([],oldArr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>flat() 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = oldArr.flat()</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="多维降一维"><a href="#多维降一维" class="headerlink" title="多维降一维"></a>多维降一维</h2><h3 id="递归降维"><a href="#递归降维" class="headerlink" title="递归降维"></a>递归降维</h3><p>递归降维这里有两种方法：</p>
<ol>
<li><code>forEach</code> 递归</li>
<li><code>reduce</code> 递归</li>
</ol>
<p>举例：</p>
<ul>
<li><p>forEach递归降维</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> oldArr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],<span class="number">10</span>,<span class="number">11</span>,],<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,[<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newArr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ergodic = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//判断是否是数组，是就递归到深层    </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">      ergodic(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newArr.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ergodic(oldArr, newArr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce 递归降维</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> oldArr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],<span class="number">10</span>,<span class="number">11</span>,],<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,[<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ergodic = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.reduce(<span class="function">(<span class="params">prev, curr, index, list</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(curr)) &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.concat(...ergodic(curr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev.concat(curr);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newArr = ergodic(oldArr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ]</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="flat-降维"><a href="#flat-降维" class="headerlink" title="flat() 降维"></a>flat() 降维</h3><p>flat(depth) depth这个参数默认是一层，可以填写数字按照查找层次，如下所示</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二维数组：默认拉平一层</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>]]].flat();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四维数组：设置拉平两层</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]]].flat(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, [6, 7]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置拉平所有层</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>]]].flat(<span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>外卖项目总结</title>
    <url>/2020/02/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="基于Vue做的外卖项目"><a href="#基于Vue做的外卖项目" class="headerlink" title="基于Vue做的外卖项目"></a>基于Vue做的外卖项目</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于外卖项目做一个总结，写一些心得和在项目中遇到的难点和一些常用知识点，让自己对于 <code>Vue</code> 有更加深刻的体会。</p>
<h2 id="首页轮播区域"><a href="#首页轮播区域" class="headerlink" title="首页轮播区域"></a>首页轮播区域</h2><p>首页轮播区域是用 Swiper 插件做的，Swiper 常用于移动端网站的内容触摸滑动，是存 <code>JavaScript</code> 打造的滑动特效插件。</p>
<p>其中后台传过来的内容是一维数组，而首页的逻辑是只显示8条数据，多出来的放在下一页，所以需要对数据进行进一步的封装，封装成二维数组，这其中就需要一个外部数组和内部数组，通过判断内部数组的长度再将内部数组放入外部数组，以此类推。</p>
<p>而对于用 Swiper 插件会遇到插件不起作用的问题，这就是异步加载数据的问题。我们需要用 <code>watch</code> 和 <code>nextTick</code> 一起使用解决这个问题。其中 <code>watch</code> 是监听数据的改变,数据更新了在更新界面之前执行， 而 <code>nextTick</code>  是在界面更新之后立即执行。</p>
<h2 id="Star组件"><a href="#Star组件" class="headerlink" title="Star组件"></a>Star组件</h2><p>这是一个评分组件，其中需要通过 props 传递  <code>Size</code> 和 <code>score</code> 其中需要 v-for 渲染 class，来决定星星的数量，通过 <code>score</code> 来计算用的是全星还是半星，其中需要 Math.floor() 计算出整数，在四舍五入计算出半星，最后补全。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理是运行到前台服务器，拦截前台服务器发送过来的请求，转发给后台获取后台的响应，再将响应发送给前台服务器 </p>
<h2 id="mock-js"><a href="#mock-js" class="headerlink" title="mock.js"></a>mock.js</h2><p>生成随机数据，拦截 Ajax 请求</p>
<h2 id="shopGoods"><a href="#shopGoods" class="headerlink" title="shopGoods"></a>shopGoods</h2><p>在 shopGoods 组件中，有一个左右联动的菜单页面，左侧和右侧列表相关联</p>
<p>当滑动右侧列表时，左侧列表会更新到当前分类，</p>
<p>当点击左侧某个分类时，右侧会滑动到对应的分类位置</p>
<p>对于滑动用的是 better-scroll 库，其中点击右侧列表然后左侧列表到达对应的类用的是 scrollTo</p>
<p>在 tops 数组中找到对应的区间是使用 findIndex，传入回调函数计算对应的区间</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于左右侧列表我们需要以下条件来实现：</p>
<ul>
<li>current类，来对当前分类进行高亮显示</li>
<li>currentIndex，一个计算属性来判断和哪一个分类的下标一样</li>
<li>scrollY，右侧列表滑动到的Y坐标</li>
<li>tops，所有右侧分类 li 的 top 组成的数组</li>
</ul>
<h2 id="cartControl"><a href="#cartControl" class="headerlink" title="cartControl"></a>cartControl</h2><p>其中有一个对 count 的加减，因为 count 是新增属性，是不会显示到页面上（没有数据绑定）</p>
<p>通过 Vue.set，让新增的属性也有数据绑定</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>购物车部分包括：</p>
<p>对物品的添加和删减的操作，这就是 cartControl 组件，</p>
<p>其中要通过记录购物车有哪些物品和物品的数量计算总价格，通过 Vuex 来管理，将商品保存到state里，对于计算物品的价格和数量放在 getter 里进行计算，最后通过取出这些数据进行显示，当商品达到起送价格后方可结算</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>外卖项目</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP、UDP、HTTP、SOCKET、WebSocket之间的区别</title>
    <url>/2020/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/http,websocket%E5%92%8Csocket/</url>
    <content><![CDATA[<h1 id="TCP、UDP、HTTP、SOCKET、WebSocket之间的区别"><a href="#TCP、UDP、HTTP、SOCKET、WebSocket之间的区别" class="headerlink" title="TCP、UDP、HTTP、SOCKET、WebSocket之间的区别"></a>TCP、UDP、HTTP、SOCKET、WebSocket之间的区别</h1><p>TCP/IP协议族主要分为四层：应用层、传输层、网络层、数据链路层</p>
<p>每层协议都有响应的协议，如下图：<br><img src="http://images.cnblogs.com/cnblogs_com/goodcandle/socket2.jpg" alt="img"></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>应用层协议，HTTP（超文本传输协议）是利用TCP在两台电脑（通常是Web服务器和客户端）之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器接收到请求处理后发送响应给客户端。</p>
<h2 id="SOCKET"><a href="#SOCKET" class="headerlink" title="SOCKET"></a>SOCKET</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p>
<h2 id="TCP与UPP"><a href="#TCP与UPP" class="headerlink" title="TCP与UPP"></a>TCP与UPP</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>传输控制协议（Transmission Control Protocol）</p>
<p><strong>优点</strong>：面向连接、传输可靠（保证数据正确性）、有序（保证数据顺序）、传输大量数据</p>
<p>速度慢、对系统资源要求多、程序结构较复杂。</p>
<p>每一条TCP连接只能是点对点，TCP首部开销20字节。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>用户数据报协议（User Data Protocol）</p>
<p>无连接、传输不可靠（丢包）、无序、传输少量数据、速度快、对系统资源要求少、程序结构较简单</p>
<p>UDP支持一对一、一对多、多对一和多对多的交互通信</p>
<p>UDP首部开销小，只有8个字节</p>
<h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><p>Websocket协议解决了服务器与客户端全双工通信的问题</p>
<p>Websocket协议包含两部分：一部分是握手，一部分是数据传输</p>
<h3 id="什么是单工，半双工，全双工"><a href="#什么是单工，半双工，全双工" class="headerlink" title="什么是单工，半双工，全双工"></a>什么是单工，半双工，全双工</h3><p>信息只能单向传送为单工</p>
<p>信息双向传送但不能同时双向传送为半双工</p>
<p>信息能够同时双向传送则称为全双工</p>
<h2 id="WebSocket和Socket区别"><a href="#WebSocket和Socket区别" class="headerlink" title="WebSocket和Socket区别"></a>WebSocket和Socket区别</h2><p>可以把WebSocket想象成HTTP(应用层)，HTTP和Socket什么关系，WebSocket和Socket就是什么关系。</p>
<p>HTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>SOCKET</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript实现继承的方式</title>
    <url>/2020/02/12/JavaScript/%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="JavaScript实现继承的方式"><a href="#JavaScript实现继承的方式" class="headerlink" title="JavaScript实现继承的方式"></a>JavaScript实现继承的方式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于 <code>JavaScript</code> 继承有过认识，但是如果想在脑海中复述一遍，发现对于这一块还是很模糊。所以对于以下 <code>JavaScript</code> 实现继承的方式做一个总结：</p>
<ul>
<li>类式继承</li>
<li>构造函数继承</li>
<li>组合继承</li>
<li>寄生组合继承</li>
<li>extends继承</li>
</ul>
<h2 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'animal'</span></span><br><span class="line">  <span class="keyword">this</span>.type = [<span class="string">'pig'</span>,<span class="string">'cat'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明父类的方法</span></span><br><span class="line">Animal.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params">sound</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sound)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'dog'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承父类</span></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.greet(<span class="string">'汪汪'</span>)  <span class="comment">//汪汪</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.type)  <span class="comment">//[ 'pig', 'cat' ]</span></span><br></pre></td></tr></table></figure>

<p><strong>原理说明</strong>： 在实例化一个类时，新创建的对象复制了父类构造函数内的属性和方法并且将原型 <code>_proto_</code> 指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法。</p>
<p>但是类式继承有两个缺陷：</p>
<ol>
<li><p>引用缺陷</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dog.type.push(<span class="string">'dog'</span>)</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog()</span><br><span class="line"><span class="built_in">console</span>.log(dog2.type) <span class="comment">//[ 'pig', 'cat', 'dog' ]</span></span><br></pre></td></tr></table></figure>

<p>通过上述执行结果，如果我们通过一个子类实例对象，修改继承自父类的引用对象，另一个新创建的实例对象也会受到影响。</p>
</li>
<li><p>无法为不同的实例初始化继承来的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal(<span class="string">'白色'</span>);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">console</span>.log(dog.color); <span class="comment">// "白色"</span></span><br><span class="line"><span class="built_in">console</span>.log(do2.color); <span class="comment">// "白色"</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>构造函数继承可以解决类式继承存在的缺陷</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'animal'</span>;</span><br><span class="line">  <span class="keyword">this</span>.type = [<span class="string">'pig'</span>,<span class="string">'cat'</span>];</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加共有方法</span></span><br><span class="line">Animal.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params">sound</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sound);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">  Animal.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'白色'</span>);</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">'黑色'</span>);</span><br><span class="line"></span><br><span class="line">dog.type.push(<span class="string">'dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.color);  <span class="comment">// "白色"</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.type);  <span class="comment">// ["pig", "cat", "dog"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog2.type);  <span class="comment">// ["pig", "cat"]</span></span><br><span class="line"><span class="built_in">console</span>.log(dog2.color);  <span class="comment">// "黑色"</span></span><br></pre></td></tr></table></figure>

<p><strong>原理说明</strong>：调用 <code>apply</code> 方法，更改函数的作用域，在子类中调用这个方法也就是将子类的变量在父类中执行一遍。这样子类就拥有父类的属性和方法。</p>
<p>但是构造函数继承也有缺陷，那就是我们无法获取父类的公有方法，也就是通过 <code>prototype</code> 绑定的方法。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承就是将类式继承和构造函数继承组合在一起</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明父类   </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'animal'</span>;</span><br><span class="line">  <span class="keyword">this</span>.type = [<span class="string">'pig'</span>, <span class="string">'cat'</span>];</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加共有方法  </span></span><br><span class="line">Animal.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params">sound</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sound);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明子类   </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数继承    </span></span><br><span class="line">  Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类式继承</span></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'白色'</span>);</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">'黑色'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog.type.push(<span class="string">'dog'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.color); <span class="comment">// "白色"</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.type); <span class="comment">// ["pig", "cat", "dog"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog2.type); <span class="comment">// ["pig", "cat"]</span></span><br><span class="line"><span class="built_in">console</span>.log(dog2.color); <span class="comment">// "黑色"</span></span><br><span class="line"></span><br><span class="line">dog.greet(<span class="string">'汪汪'</span>); <span class="comment">// "汪汪"</span></span><br></pre></td></tr></table></figure>

<p><strong>原理说明</strong>：在上面例子中，我们在子类构造函数中执行父类构造函数，在子类原型上实例化父类，这就是组合继承。可以看到它综合了类式继承和构造函数继承的优点，同时去除了缺陷。</p>
<p>这种组合继承也是有缺陷的，那就是它调用了两次父类构造函数。</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>寄生组合继承强化的部分就是在组合继承的基础上减少一次多余的调用父类的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'animal'</span>;</span><br><span class="line">  <span class="keyword">this</span>.type = [<span class="string">'pig'</span>, <span class="string">'cat'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.greet = <span class="function"><span class="keyword">function</span>(<span class="params">sound</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sound);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意下面两行 */</span></span><br><span class="line">Dog.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line">Dog.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'白色'</span>);   </span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">'黑色'</span>);     </span><br><span class="line"></span><br><span class="line">dog.type.push(<span class="string">'dog'</span>);   </span><br><span class="line"><span class="built_in">console</span>.log(dog.color);   <span class="comment">// "白色"</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.type);   <span class="comment">// ["pig", "cat", "dog"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog2.type);  <span class="comment">// ["pig", "cat"]</span></span><br><span class="line"><span class="built_in">console</span>.log(dog2.color);  <span class="comment">// "黑色"</span></span><br><span class="line"></span><br><span class="line">dog.greet(<span class="string">'汪汪'</span>);  <span class="comment">//  "汪汪"</span></span><br></pre></td></tr></table></figure>

<p><strong>原理说明</strong>：在上面的例子中，我们并不像类继承一样直接将父类 <code>Animal</code> 的一个实例赋值给 <code>Dog.prototype</code>，而是使用 <code>Object.create()</code> 进行一次浅拷贝，将父类原型上的方法拷贝后赋给 <code>Dog.prototype</code>，这样子类是哪个就能拥有了父类的共有方法，而且少了一次调用父类的构造函数。</p>
<h2 id="extends-继承"><a href="#extends-继承" class="headerlink" title="extends 继承"></a>extends 继承</h2><p><code>Class</code> 和 <code>extends</code> 是在 ES6 中新增的，class 用来创建一个类， extends 涌来了实现继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">constructor</span>(color) &#123;   </span><br><span class="line">    <span class="keyword">this</span>.color = color;   </span><br><span class="line">  &#125;   </span><br><span class="line">  greet(sound) &#123;   </span><br><span class="line">    <span class="built_in">console</span>.log(sound);   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;   </span><br><span class="line">  <span class="keyword">constructor</span>(color) &#123;   </span><br><span class="line">    <span class="keyword">super</span>(color);   </span><br><span class="line">    <span class="keyword">this</span>.color = color;   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">'黑色'</span>);  </span><br><span class="line">dog.greet(<span class="string">'汪汪'</span>);  <span class="comment">// "汪汪"</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.color); <span class="comment">// "黑色"</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中创建了父类 Animal，然后 Dog 子类继承父类，两个类中都有一个 constructor 构造方法，实质就是构造函数 Animal 和 Dog。其中在子类构造方法中调用了 super 方法，它表示父类的构造函数，用来新建父类的 this 对象。</p>
<p><em>注意</em>：子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这就是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>事件机制</title>
    <url>/2020/01/17/JavaScript/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节是对事件机制做一些总结，看了一篇文章感觉写的还不错，就稍微总结了一下。</p>
<h2 id="什么是事件机制"><a href="#什么是事件机制" class="headerlink" title="什么是事件机制"></a>什么是事件机制</h2><p>事件机制就是根据不同的用户操作（如：点击、选择、滚动屏幕等）进行响应变化，这种基于事件的处理方式，本质上是一种消息传递机制。</p>
<p>事件机制有三样重要的东西：</p>
<ul>
<li>事件生产者</li>
<li>事件对象</li>
<li>事件消费者</li>
</ul>
<h2 id="事件流及事件绑定"><a href="#事件流及事件绑定" class="headerlink" title="事件流及事件绑定"></a>事件流及事件绑定</h2><p>EMCAScript 标准规定事件流包含三个阶段，分别为事件捕获阶段、目标阶段、事件冒泡阶段。<img src="https://user-gold-cdn.xitu.io/2017/12/21/1607805fb19b8e42?imageView2/0/w/1280/h/960/format/webp/Rignore-error/1" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target.addEventListener(type, listener, useCapture);  </span><br><span class="line">    <span class="comment">// 标准注册事件函数</span></span><br><span class="line">    <span class="comment">// target:文档节点、document、window 或 XMLHttpRequest。</span></span><br><span class="line">    <span class="comment">// 函数的参数：注册事件类型type，事件的回调函数，事件注册在捕获期间还是冒泡期间</span></span><br><span class="line">    <span class="comment">// 例如：给button注册onclick事件，要是在捕获阶段注册，则 button.addEventListener("click",function()&#123;&#125;,true);</span></span><br><span class="line">target.removeEventListener(type, listener, useCapture);  <span class="comment">//在某一个元素上撤销已注册的事件。</span></span><br></pre></td></tr></table></figure>



<p>上面是标准的事件流，而IE浏览器的事件流却是非标准的。其中只有两个阶段：目标阶段、冒泡阶段。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/21/1607806e0032e337?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target.attachEvent(type, listener);  <span class="comment">//target： 文档节点、document、window 或 XMLHttpRequest。</span></span><br><span class="line">                                     <span class="comment">//函数参数： type：注册事件类型；</span></span><br><span class="line">                                     <span class="comment">//         listener：事件触发时的回调函数。</span></span><br><span class="line">target.detachEvent(type,listener);   <span class="comment">//参数与注册参数相对应。</span></span><br></pre></td></tr></table></figure>

<p>然而有时候事件的捕获机制以及冒泡机制也会带来副作用，比如冒泡机制会触发父节点上原本并不希望被触发的监听函数，所以有办法可以使得冒泡提前结束吗？我们只需要在希望事件停止冒泡的位置，调用event对象的 <code>stopPropagation</code> 函数(IE浏览器中为 <code>cancelBubble</code> )即可终止事件冒泡了。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><h3 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h3><p>事件委托就是利用事件冒泡机制，指定一个事件处理程序，来管理某一类型的所有事件。</p>
<p>举个例子来说公司员工取快递，为了方便签收快递，有两种方法：一种是快递到了之后收件人亲自去拿快递；另一种是委托前台代为签收，前台按照要求进行签收。很显然第二种更为方便高效，同时这种方案还有一种优势，那就是新员工入职，前台可以代替新员工签收快递。</p>
<p>这个例子包含了委托的两层意思：</p>
<p>首先，现公司员工可以委托前台代为签收快递，即程序中现有的dom节点是有事件的并可以进行事件委托；其次，新入职的新员工也可以让前台代签收快递，即程序中新添加的dom节点也是有事件的，并且也能委托处理事件。</p>
<h3 id="为什么要用事件委托"><a href="#为什么要用事件委托" class="headerlink" title="为什么要用事件委托"></a>为什么要用事件委托</h3><p>当需要给多个节点添加相同的事件时，如果遍历所有节点去添加事件，那就会直接影响页面整体运行性能，因为这需要不停地与dom节点进行交互，访问dom的次数越多，引起浏览器重绘和重排的次数越多，自然会延长页面的交互就绪事件。而如果使用委托，我们可以将事件的操作统一放在js代码里，这样与dom的操作就可以减少到一次，大大减少与dom节点的交互次数提高性能。同时，将事件的操作进行统一管理也能节约内存，因为每个js函数都是一个对象，自然就会占用内存，给dom节点添加的事件处理程序越多，对象越多，占用的内存也就越多；而使用委托，我们就可以只在dom节点的父级添加事件处理程序，那么自然也就节省了很多内存，性能也更好。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"list"</span>&gt;</span><br><span class="line">    &lt;li id=<span class="string">"item1"</span> &gt;item1&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li id="item2" &gt;item2&lt;/</span>li&gt;</span><br><span class="line">    &lt;li id=<span class="string">"item3"</span> &gt;item3&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> item1 = <span class="built_in">document</span>.getElementById(<span class="string">"item1"</span>);</span><br><span class="line"><span class="keyword">var</span> item2 = <span class="built_in">document</span>.getElementById(<span class="string">"item2"</span>);</span><br><span class="line"><span class="keyword">var</span> item3 = <span class="built_in">document</span>.getElementById(<span class="string">"item3"</span>);</span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</span><br><span class="line">list.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> target = event.target;</span><br><span class="line"> <span class="keyword">if</span>(target == item1)&#123;</span><br><span class="line">    alert(event.target.nodeName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello item1"</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == item2)&#123;</span><br><span class="line">    alert(event.target.nodeName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello item2"</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == item3)&#123;</span><br><span class="line">    alert(event.target.nodeName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello item3"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>



<p>添加dom：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"list"</span>&gt;</span><br><span class="line">    &lt;li id=<span class="string">"item1"</span> &gt;item1&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li id="item2" &gt;item2&lt;/</span>li&gt;</span><br><span class="line">    &lt;li id=<span class="string">"item3"</span> &gt;item3&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</span><br><span class="line">  </span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = event.target;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName == <span class="string">"LI"</span>)&#123;</span><br><span class="line">        alert(target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> node=<span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line"><span class="keyword">var</span> textnode=<span class="built_in">document</span>.createTextNode(<span class="string">"item4"</span>);</span><br><span class="line">node.appendChild(textnode);</span><br><span class="line">list.appendChild(node);</span><br><span class="line">  </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js事件机制</tag>
        <tag>事件流</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次周总结</title>
    <url>/2019/10/27/%E5%91%A8%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="JS对象序列化详解"><a href="#JS对象序列化详解" class="headerlink" title="JS对象序列化详解"></a>JS对象序列化详解</h2><h3 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h3><p>对象序列化是将对象状态转化成一个字符串</p>
<p>序列化是将对象的状态信息转换成一个可以存储和传输的形式的过程</p>
<h3 id="为什么会有对象序列化"><a href="#为什么会有对象序列化" class="headerlink" title="为什么会有对象序列化"></a>为什么会有对象序列化</h3><p>简单的说就是方便对象<strong>传输和存储</strong></p>
<blockquote>
<p>当这句代码运行时，对象obj的内容会存储在一块内存中，而obj本身存储的只是这块内存的地址的映射而已。简单的说，对象obj就是我们的程序在电脑通电时在内存中维护的一种东西，如果我们程序停止了或者电脑断电了，对象obj将不复存在。那么如何把对象obj的内容保存在磁盘上呢（也就是说在没电时继续保留着）？这时就需要把对象obj序列化，也就是说把obj的内容转换成一个字符串的形式，然后再保存在磁盘上。另外，我们又怎么通过HTTP协议把对象obj的内容发送到客户端呢？没错，还是需要先把对象obj序列化，然后客户端根据接收到的字符串再反序列化（也就是将字符串还原为对象）解析出相应的对象。</p>
</blockquote>
<h3 id="JS中的对象序列化"><a href="#JS中的对象序列化" class="headerlink" title="JS中的对象序列化"></a>JS中的对象序列化</h3><p> JSON 的全称是”JavaScript Object Notation“——JavaScript对象表示法。ECMAScript 5中提供了内置函数JSON.stringify()和JSON.parse()用来序列化和还原JavaScript对象。<br> JSON是一种语法，用来序列化字符串，数值，数组，对象，布尔值和null</p>
<hr>
<h2 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h2><blockquote>
<p>你不知道的js上</p>
</blockquote>
<h3 id="为什么要用this"><a href="#为什么要用this" class="headerlink" title="为什么要用this"></a>为什么要用this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">"Hello,I'm "</span> + identify.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(greeting)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me =&#123;</span><br><span class="line">  name:<span class="string">'Kele'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you =&#123;</span><br><span class="line">  name:<span class="string">'Reader'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify.call(me)</span><br><span class="line">identify.call(you)</span><br><span class="line"></span><br><span class="line">speak.call(me)</span><br><span class="line">speak.call(you)</span><br></pre></td></tr></table></figure>

<p>在不同的上下文对象中，重复使用函数的情况下，使用this就不用针对每个对象编写不同版本的函数，如上面代码如果不使用this，则需显示的传入一个上下文对象。</p>
<h3 id="对this常见的两种误解"><a href="#对this常见的两种误解" class="headerlink" title="对this常见的两种误解"></a>对this常见的两种误解</h3><ol>
<li><p>指向自身<br>从函数对象内部引用它自身 ，只使用this是不够的。<br>一般来说需通过一个指向函数对象的此法标识符（变量）来引用它:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>)</span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo:"</span>+num)</span><br><span class="line">  <span class="comment">// 记录foo被调用的次数,foo代替this来引用函数对象</span></span><br><span class="line">  foo.count++</span><br><span class="line">&#125;</span><br><span class="line">foo.count=<span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;<span class="number">5</span>)&#123;</span><br><span class="line">    foo(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo被调用几次</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.count);</span><br></pre></td></tr></table></figure>

<p>回避了this问题，完全依赖于变量foo的词法作用域</p>
<p>另一种方法是强制this指向foo函数对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo:"</span>+num)</span><br><span class="line">  <span class="comment">// 记录foo被调用的次数</span></span><br><span class="line">  <span class="keyword">this</span>.count++</span><br><span class="line">&#125;</span><br><span class="line">foo.count=<span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;<span class="number">5</span>)&#123;</span><br><span class="line">    foo.call(foo,i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo被调用几次</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.count);</span><br></pre></td></tr></table></figure>
</li>
<li><p>它的作用域</p>
</li>
</ol>
<h4 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h4><p>通过对象访问属性的方式调用函数，this就指向这个对象；其他情况，在严格模式下，指向undefined，在非严格模式下指向全局对象。</p>
<p><strong>总结</strong>：this是在运行时绑定的而不是在编写时绑定，它的上下文取决于函数调用时的条件。this实际是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里调用。</p>
<h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>理解调用位置分析调用栈，调用位置就在当前执行的函数的前一个调用中</p>
<p>四条绑定规则：</p>
<ul>
<li>默认调用</li>
<li>隐式调用</li>
<li>显示调用<ul>
<li>call（）和apply（）方法</li>
</ul>
</li>
<li>new绑定<ul>
<li>首先理解new的机制和面向类的语言完全不同，js中的构造函数只是一些使用new操作符时被调用的函数。并不属于某个类，也不会实例一个类，只是一个普通函数</li>
</ul>
</li>
</ul>
<h3 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h3><p>判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序判断：</p>
<ol>
<li>函数是否在 new 中调用？如果是的话 this 绑定的是新创建的对象</li>
<li>函数是否通过call、apply或者硬绑定？如果是，this 绑定的是指定的对象</li>
<li>函数是否在某个上下文对象中调用？this绑定的是那个上下文对象</li>
<li>如果都不是，使用默认绑定</li>
</ol>
<h3 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h3><p>ES6中有一种无法使用这些规则的特殊函数类型：箭头函数</p>
<p>箭头函数的绑定，无法被修改常用于回调函数</p>
<hr>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>对象可以通过两种方式定义：声明（文字）形式和构造形式</p>
<p>两种定义出来的对象是一样的<strong>区别</strong>在于：声明方式可以在文字声明中添加多个键值对，但是构造形式只能逐个添加属性</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对象是 JavaScript 的基础。有六种主要类型（语言类型）</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>null</li>
<li>undefined</li>
</ul>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>JavaScript 中还有一些对象子类型，通常被称为内置对象。</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error  </li>
</ul>
<p>思考下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"I'm a string"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length) <span class="comment">//13</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">3</span>)) <span class="comment">//m</span></span><br></pre></td></tr></table></figure>

<p>我们可以直接在字符串字面量上访问属性或者方法，是因为引擎自动把字面量转换成 String 对象，所以才可以访问属性和方法。</p>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。</p>
<p>这些值存储方式多钟多样，一般并不会存储在对象容器内部。存储在内部的是这些属性的名称，它们就像指针（引用）一样，指向这些值真正的存储位置。</p>
<p>.属性访问，[]键访问</p>
<h4 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h4><p>在JavaScript中，函数并不是方法，函数和方法在JavaScript中是可以互换的。</p>
<p>即使在对象的文字形式中声明一个函数表达式，这个函数也不会属于这个对象，他们只是对于相同函数对象的多个引用。</p>
<h4 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h4><p>ES5后，所有属性都具备了属性描述符，属性的特性可以通过属性描述符来控制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject,<span class="string">"a"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject,<span class="string">"a"</span>));</span><br><span class="line">&#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,   <span class="comment">//可写</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,   <span class="comment">//可枚举</span></span><br><span class="line">    configurable: <span class="literal">true</span>  <span class="comment">//可配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，可以使用Object.preventExtensions(…)，Object.seal(…)，Object.freeze(…) 来设置对象（及其属性）的不可变性级别。</p>
<p>在创建普通属性时属性描述符会使用默认值，可以使用Object.definePropertty(…)来添加一个新属性或者修改一个已有属性（如果它是configurable）并对特性进行设置。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject,<span class="string">"a"</span>,&#123;</span><br><span class="line">  value:<span class="number">2</span>,</span><br><span class="line">  writable:<span class="literal">true</span>,</span><br><span class="line">  configurable:<span class="literal">true</span>,</span><br><span class="line">  enumerable:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myObject.a  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h4 id="Get"><a href="#Get" class="headerlink" title="[Get]"></a>[Get]</h4><p>对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性。如果找到就返回这个属性的值，否则就遍历可能存在的 [[Prototype]] 链，也就是原型链。如若还没找到，返回 undefined</p>
<h4 id="Put"><a href="#Put" class="headerlink" title="[[Put]]"></a>[[Put]]</h4><p>[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（重要因素）</p>
<p>如果已经<strong>存在</strong>这个属性，[[put]] 算法大致会检查下面这些内容：</p>
<ol>
<li>属性是否是访问描述符（参见Getter和Setter）?如果是并且存在 setter 就调用 setter</li>
<li>属性的数据描述符中 writable 是否是 false？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常</li>
<li>如果不是，将该值设置为属性的值</li>
</ol>
<p>如果对象中<strong>不存在</strong>这个属性，[[Put]]操作会更加复杂。参见 [[Prototype]]</p>
<h4 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h4><p>ES5中可以使用 getter 和 setter 部分改写默认操作，但只能应用在单个属性上，无法应用到整个对象。它们都是隐藏函数，getter 获取属性值时调用，setter 在设置属性值时调用。</p>
<p>JavaScript 会忽略它们的 value 和 writable ，只关心 set 和 get（还有configurable和enumerable）特性。</p>
<p>为了让属性更合理，getter 和 setter 是成对出现的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="comment">// 给 a 定义一个 getter</span></span><br><span class="line">  <span class="keyword">get</span> a()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._a_</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 给 a 定义一个 setter</span></span><br><span class="line">  <span class="keyword">set</span> a(val)&#123;</span><br><span class="line">    <span class="keyword">this</span>._a_ = val*<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.a); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h4 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h4><p>in 和 hasOwnProperty区别在于是否查找 [[Prototype]] 链</p>
<p>in 会检查是否在对象及其 [[Prototype]] 原型链中</p>
<p>in 检查的是某个属性名是否存在</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>for…in 循环可以遍历对象的可枚举属性列表（[[Prototype]]链）。使用它遍历对象是无法直接获取属性值，只是遍历对象中的可枚举属性，需要手动获取属性值。</p>
<p>ES5数组辅助迭代器，接收一个回调函数并应用到数组的每个元素上，区别是对于回调函数的返回值的处理方式不同：</p>
<ul>
<li>forEach(…)会遍历数组中的所有值并忽略回调函数的返回值</li>
<li>every(…)会一直运行直到回调函数返回false（或假值）</li>
<li>some(…)会一直运行直到回调函数返回true（或真值）</li>
</ul>
<p>every 和 some 中特殊的返回值和普通函数 for 循环中的 break 语句类似，会提前终止遍历</p>
<p>ES6增加了一种用来遍历数组的 for…of 循环语句，直接遍历值而不是数组下标</p>
<p>for…of 循环首先会向被访问的对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。细节请见数组内置的 @@iterator 来手动遍历数组是怎么工作的。</p>
<p>和数组不同，普通对象没有内置的 @@iterator，所有无法完成 for…of 遍历。</p>
<h2 id="RSA非对称加密"><a href="#RSA非对称加密" class="headerlink" title="RSA非对称加密"></a>RSA非对称加密</h2><p>RSA 不需要双方协商一个保密的密钥，而是有一对钥匙，一个是保密的，成为私钥；另一个是公开的，称为公钥。</p>
<p>用私钥加密的数据，只有对应的公钥才能解密；用公钥加密的数据，只有对应的私钥才能解密。</p>
<p>但由于RSA算法的加密和解密速度有点慢，先用 RSA 的方式将对称加密算法的密钥发给对方，随后利用对称密钥通信。</p>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
      <tags>
        <tag>周总结</tag>
        <tag>this指向</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2020/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97%E5%92%8C%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="队列和双端队列"><a href="#队列和双端队列" class="headerlink" title="队列和双端队列"></a>队列和双端队列</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>我们可以像栈那样使用数组来储存队列中元素的数据结构，但用对象的方式，更高效。<br>关于用对象来存储，和栈一样。但队列遵循先进先出的原则，从队列前端移除元素，所以需要一个变量来追踪第一个元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.lowestCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enqueue(element(s))：向队列尾部添加一个（或多个）新的项。</span></span><br><span class="line">  enqueue(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items[<span class="keyword">this</span>.count] = element</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// dequeue()：移除队列的第一项（即排在队列最前面的项）并返回被移除的元素。</span></span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount];</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount];</span><br><span class="line">    <span class="keyword">this</span>.lowestCount++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// peek()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做</span></span><br><span class="line">  <span class="comment">// 任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。该方</span></span><br><span class="line">  <span class="comment">// 法在其他语言中也可以叫作 front 方法。</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// isEmpty()：如果队列中不包含任何元素，返回 true，否则返回 false。</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count - <span class="keyword">this</span>.lowestCount === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// size()：返回队列包含的元素个数，与数组的 length 属性类似。</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count - <span class="keyword">this</span>.lowestCount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空队列</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.lowestCount + <span class="number">1</span>; i &lt; <span class="keyword">this</span>.count; i++) &#123;</span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Queue类</span></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line"><span class="built_in">console</span>.log(queue.isEmpty());   <span class="comment">//输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队列中添加元素</span></span><br><span class="line">queue.enqueue(<span class="string">'John'</span>)</span><br><span class="line">queue.enqueue(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(queue.toString());  <span class="comment">//输出 John,Bob</span></span><br><span class="line"></span><br><span class="line">queue.enqueue(<span class="string">'Jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(queue.toString());  <span class="comment">//输出 John,Bob,Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.size());    <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.isEmpty());   <span class="comment">//输出 false</span></span><br><span class="line">queue.dequeue()</span><br><span class="line">queue.dequeue()</span><br><span class="line"><span class="built_in">console</span>.log(queue.toString());  <span class="comment">//输出 Jack</span></span><br></pre></td></tr></table></figure>

<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列有所不同的是，它允许在前端和后端进行添加和删除元素的操作。<br>双端队列常见应用是存储一系列撤销操作，双端队列同时遵循先进先出和后进先出的原则，把栈和队列同时结合的数据结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.lowestCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于双端队列是特殊的队列，有一些方法是相同的，如：isEmpty、clear、size、toString</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count - <span class="keyword">this</span>.lowestCount === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count - <span class="keyword">this</span>.lowestCount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.lowestCount + <span class="number">1</span>; i &lt; <span class="keyword">this</span>.count; i++) &#123;</span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// addFront(element)：该方法在双端队列前端添加新的元素。考虑三种情况</span></span><br><span class="line">  addFront(element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addBack(element)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.lowestCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.lowestCount--</span><br><span class="line">      <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount] = element</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.count; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.items[i] = <span class="keyword">this</span>.items[i - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.count++</span><br><span class="line">      <span class="keyword">this</span>.lowestCount = <span class="number">0</span></span><br><span class="line">      <span class="keyword">this</span>.items[<span class="number">0</span>] = element</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// addBack(element)：该方法在双端队列后端添加新的元素（实现方法和 Queue 类中的enqueue 方法相同）。</span></span><br><span class="line">  addBack(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items[<span class="keyword">this</span>.count] = element</span><br><span class="line">    <span class="keyword">this</span>.count++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// removeFront()：该方法会从双端队列前端移除第一个元素（实现方法和 Queue 类中的 dequeue 方法相同）。</span></span><br><span class="line">  removeFront() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount];</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount];</span><br><span class="line">    <span class="keyword">this</span>.lowestCount++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// removeBack()：该方法会从双端队列后端移除第一个元素（实现方法和 Stack 类中的 pop 方法一样）。</span></span><br><span class="line">  removeBack() &#123;</span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.count--;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.items[<span class="keyword">this</span>.count];</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// peekFront()：该方法返回双端队列前端的第一个元素（实现方法和 Queue 类中的 peek 方法一样）。</span></span><br><span class="line">  peekFront() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.lowestCount];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// peekBack()：该方法返回双端队列后端的第一个元素（实现方法和 Stack 类中的 peek 方法一样）。</span></span><br><span class="line">  peekBack() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 Deque 类 */</span></span><br><span class="line"><span class="keyword">const</span> deque=<span class="keyword">new</span> Deque()</span><br><span class="line"><span class="built_in">console</span>.log(deque.isEmpty());  <span class="comment">//true</span></span><br><span class="line">deque.addBack(<span class="string">'Jack'</span>)</span><br><span class="line">deque.addBack(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(deque.toString());<span class="comment">//Jack,Bob</span></span><br><span class="line">deque.addBack(<span class="string">'Ricardo'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(deque.size());<span class="comment">//3</span></span><br><span class="line">deque.removeFront()</span><br><span class="line"><span class="built_in">console</span>.log(deque.toString());<span class="comment">//Bob,Ricardo</span></span><br><span class="line">deque.removeBack()</span><br><span class="line"><span class="built_in">console</span>.log(deque.toString());<span class="comment">//Bob</span></span><br><span class="line">deque.addFront(<span class="string">'Jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(deque.toString());<span class="comment">//Jack,Bob</span></span><br></pre></td></tr></table></figure>

<h2 id="使用队列和双端队列来解决问题"><a href="#使用队列和双端队列来解决问题" class="headerlink" title="使用队列和双端队列来解决问题"></a>使用队列和双端队列来解决问题</h2><h3 id="循环队列—-击鼓传花（使用-Queue-类）"><a href="#循环队列—-击鼓传花（使用-Queue-类）" class="headerlink" title="循环队列—-击鼓传花（使用 Queue 类）"></a>循环队列—-击鼓传花（使用 Queue 类）</h3><p>循环队列的一个例子就是击鼓传花游戏（ hotpotato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotPotato</span>(<span class="params">elementList, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line">  <span class="keyword">const</span> eliminatedList = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elementList.length; i++) &#123;</span><br><span class="line">    queue.enqueue(elementList[i])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      queue.enqueue(queue.dequeue())</span><br><span class="line">    &#125;</span><br><span class="line">    eliminatedList.push(queue.dequeue())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    eliminated: eliminatedList,</span><br><span class="line">    winner: queue.dequeue()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">'John'</span>, <span class="string">'Jack'</span>, <span class="string">'Camila'</span>, <span class="string">'Ingrid'</span>, <span class="string">'Carl'</span>];</span><br><span class="line"><span class="keyword">const</span> result = hotPotato(names, <span class="number">7</span>);</span><br><span class="line">result.eliminated.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>在击鼓传花游戏中被淘汰。 `</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`胜利者： <span class="subst">$&#123;result.winner&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// Camila在击鼓传花游戏中被淘汰。</span></span><br><span class="line"><span class="comment">// Jack在击鼓传花游戏中被淘汰。</span></span><br><span class="line"><span class="comment">// Carl在击鼓传花游戏中被淘汰。</span></span><br><span class="line"><span class="comment">// Ingrid在击鼓传花游戏中被淘汰。</span></span><br><span class="line"><span class="comment">// 胜利者： John</span></span><br></pre></td></tr></table></figure>

<h3 id="回文检查器（使用-Deque-类）"><a href="#回文检查器（使用-Deque-类）" class="headerlink" title="回文检查器（使用 Deque 类）"></a>回文检查器（使用 Deque 类）</h3><p>回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam 或 racecar。有不同的算法可以检查一个词组或字符串是否为回文。最简单的方式是将字符串反向排列并检查它和原字符串是否相同。如果两者相同，那么它就是一个回文。我们也可以用栈来完成，但是利用数据结构来解决这个问题的最简单方法是使用双端队列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">palindromeChecker</span>(<span class="params">aString</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查传入的字符串参数是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (aString === <span class="literal">undefined</span> || aString === <span class="literal">null</span> || (aString !== <span class="literal">null</span> &amp;&amp; aString.length === <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> deque = <span class="keyword">new</span> Deque();</span><br><span class="line">  <span class="comment">// 将所有字母转化为小写，同时移除所有的空格</span></span><br><span class="line">  <span class="keyword">const</span> lowerString = aString.toLocaleLowerCase().split(<span class="string">' '</span>).join(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">let</span> isEqual = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">let</span> firstChar, lastChar;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lowerString.length; i++) &#123;</span><br><span class="line">    deque.addBack(lowerString.charAt(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (deque.size() &gt; <span class="number">1</span> &amp;&amp; isEqual) &#123;</span><br><span class="line">    firstChar = deque.removeFront();</span><br><span class="line">    lastChar = deque.removeBack();</span><br><span class="line">    <span class="keyword">if</span> (firstChar !== lastChar) &#123;</span><br><span class="line">      isEqual = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isEqual;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>, palindromeChecker(<span class="string">'a'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'aa'</span>, palindromeChecker(<span class="string">'aa'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'kayak'</span>, palindromeChecker(<span class="string">'kayak'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'level'</span>, palindromeChecker(<span class="string">'level'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Was it a car or a cat I saw'</span>, palindromeChecker(<span class="string">'Was it a caror a cat I saw'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Step on no pets'</span>, palindromeChecker(<span class="string">'Step on no pets'</span>));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>双端队列</tag>
        <tag>击鼓传花</tag>
        <tag>回文检查器</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>存储多个元素，最常用的是数组，访问元素很方便。<br>但是用数组这个数据结构有一个缺点，数组的大小是固定的。意味着对数组中进行添加或删除元素的成本很高，需要移动元素。</p>
<p>链表同样是存储有序的元素集合，但是不同于数组，链表中的元素在内存中并不是连续存放的。每个元素由一个存储元素本身的节点，和一个指向下一个元素的指针。</p>
<p>如下图：<br><img src="http://q2e38owot.bkt.clouddn.com/image/study/linked-list.png" alt="linked-list"></p>
<h2 id="创建链表以及链表的方法"><a href="#创建链表以及链表的方法" class="headerlink" title="创建链表以及链表的方法"></a>创建链表以及链表的方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 linkedList 类的开发者可以自行传入用于比较两个 JavaScript 对象或值是否相等的自定义函数</span></span><br><span class="line"><span class="comment">// 如果没有传入这个自定义函数，defaultEquals 函数作为默认的相等性比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultEquals</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a === b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义每个元素节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">    <span class="keyword">this</span>.equalsFn = equalsFn;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push(element)：向链表尾部添加一个新元素。</span></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">let</span> current; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">this</span>.head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = <span class="keyword">this</span>.head; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123; <span class="comment">// &#123;5&#125; 获得最后一项</span></span><br><span class="line">        current = current.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将其 next 赋为新元素，建立链接</span></span><br><span class="line">      current.next = node; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count++; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// removeAt(position)：从链表的特定位置移除一个元素。</span></span><br><span class="line">  removeAt(index) &#123;</span><br><span class="line">    <span class="comment">// 检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>.head; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="comment">// 移除第一项</span></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        <span class="keyword">this</span>.head = current.next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// let previous; // &#123;4&#125;</span></span><br><span class="line">        <span class="comment">// for (let i = 0; i &lt; index; i++) &#123; // &#123;5&#125;</span></span><br><span class="line">        <span class="comment">//   previous = current; // &#123;6&#125;</span></span><br><span class="line">        <span class="comment">//   current = current.next; // &#123;7&#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">        current = previous.next;</span><br><span class="line">        <span class="comment">// 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它</span></span><br><span class="line">        previous.next = current.next; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.count--; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">      <span class="keyword">return</span> current.element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getElementAt(index)：返回链表中特定位置的元素。如果链表中不存在这样的元素，则返回 undefined。</span></span><br><span class="line">  getElementAt(index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">this</span>.head; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index &amp;&amp; node != <span class="literal">null</span>; i++) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        node = node.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> node; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// insert(element, position)：向链表的特定位置插入一个新元素。</span></span><br><span class="line">  insert(element, index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// 在第一个位置添加</span></span><br><span class="line">        <span class="keyword">const</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">        node.next = current; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">        <span class="keyword">this</span>.head = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        <span class="keyword">const</span> current = previous.next; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">        node.next = current; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        previous.next = node; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.count++; <span class="comment">// 更新链表的长度</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// indexOf(element)：返回元素在链表中的索引。如果链表中没有该元素则返回-1。</span></span><br><span class="line">  indexOf(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.count &amp;&amp; current != <span class="literal">null</span>; i++) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.equalsFn(element, current.element)) &#123; <span class="comment">// &#123;3&#125;验证 current 节点的元素和目标元素是否相等</span></span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">      current = current.next; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// remove(element)：从链表中移除一个元素。</span></span><br><span class="line">  remove(element) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// size()：返回链表包含的元素个数，与数组的 length 属性类似。</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// isEmpty()：如果链表中不包含任何元素， 返回 true，如果链表长度大于 0则返回 false。</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size() === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getHead() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// toString()：返回表示整个链表的字符串。由于列表项使用了 Node 类，就需要重写继</span></span><br><span class="line">  <span class="comment">// 承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。</span></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.head.element&#125;</span>`</span>; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head.next; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.size() &amp;&amp; current != <span class="literal">null</span>; i++) &#123; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;current.element&#125;</span>`</span>;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从链表中移除元素（removeAt方法）"><a href="#从链表中移除元素（removeAt方法）" class="headerlink" title="从链表中移除元素（removeAt方法）"></a>从链表中移除元素（removeAt方法）</h3><p>对于从链表中移除元素也存在两种场景：第一种是移除第一个元素，第二种是移除第一个元素之外的其他元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="comment">// 检查越界值</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="comment">// 移除第一项</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">this</span>.head = current.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// let previous; // &#123;4&#125;</span></span><br><span class="line">      <span class="comment">// for (let i = 0; i &lt; index; i++) &#123; // &#123;5&#125;</span></span><br><span class="line">      <span class="comment">//   previous = current; // &#123;6&#125;</span></span><br><span class="line">      <span class="comment">//   current = current.next; // &#123;7&#125;</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">      current = previous.next;</span><br><span class="line">      <span class="comment">// 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它</span></span><br><span class="line">      previous.next = current.next; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count--; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">    <span class="keyword">return</span> current.element;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一起来为第一种场景编写代码：我们要从链表中移除第一个元素（ position === 0——行{3}）。</p>
<p>下图展示了这个过程:<br><img src="http://q2e38owot.bkt.clouddn.com/image/study/removeAt1.png" alt="removeAt1"></p>
<p>因此，如果想移除第一个元素，要做的就是让 head 指向列表的第二个元素。我们将用 current 变量创建一个对链表中第一个元素的引用（行{2}——我们还会用它来迭代链表，但稍等一下再说）。这样 current 变量就是对链表中第一个元素的引用。如果把 head 赋为 current.next，就会移除第一个元素。我们也可以直接把 head 赋为 head.next（不使用 current 变量作为替代）。</p>
<p>现在，假设我们要移除链表的最后一个或者中间某个元素。为此，需要迭代链表的节点，直到到达目标位置（行{5}）。一个重要细节是： current 变量总是为对所循环列表的当前元素的引用（行{7}）。我们还需要一个对当前元素的前一个元素的引用（行{6}），它被命名为 previous（行{4}）。</p>
<p>在迭代到目标位置之后， current 变量会持有我们想从链表中移除的节点。因此，要从链表中移除当前元素，要做的就是将 previous.next 和 current.next 链接起来（行{8}）。这样，当前节点就会被丢弃在计算机内存中，等着被垃圾回收器清除。</p>
<p>试着借助一些图表来更好地理解这段代码。首先考虑移除最后一个元素。<br><img src="http://q2e38owot.bkt.clouddn.com/image/study/removeAt2.png" alt="removeAt2"><br>对于最后一个元素，当我们在行{8}跳出循环时， current 变量将是对链表中最后一个节点的引用（要移除的节点）。 current.next 的值将是 undefined（因为它是最后一个节点）。由于还保留了对 previous 节点的引用（当前节点的前一个节点）， previous.next 就指向了current。那么要移除 current，要做的就是把 previous.next 的值改变为 current.next。</p>
<p>对于链表中间的元素:<br><img src="http://q2e38owot.bkt.clouddn.com/image/study/removeAt3.png" alt="removeAt3"><br>current 变量是对要移除节点的引用。 previous 变量是对要移除节点的前一个节点的引用。那么要移除 current 节点，需要做的就是将 previous.next 与 current.next 链接起来。因此，我们的逻辑对这两种情况都适用。</p>
<h3 id="在任意位置插入元素（insert方法）"><a href="#在任意位置插入元素（insert方法）" class="headerlink" title="在任意位置插入元素（insert方法）"></a>在任意位置插入元素（insert方法）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">insert(element, index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// 在第一个位置添加</span></span><br><span class="line">      <span class="keyword">const</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">      node.next = current; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">this</span>.head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">      <span class="keyword">const</span> current = previous.next; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">      node.next = current; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      previous.next = node; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count++; <span class="comment">// 更新链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果位置合法，我们就要处理不同的场景。第一种场景是需要在链表的起点添加一个元素，也就是第一个位置，如下图所示。<br><img src="http://q2e38owot.bkt.clouddn.com/image/study/insert1.png" alt="insert1"><br>在上图中， current 变量是对链表中第一个元素的引用。我们需要做的是把 node.next 的值设为 current（链表中第一个元素，或简单地设为 head）。现在 head 和 node.next 都指向了 current。接下来要做的就是把 head 的引用改为 node（行{2}），这样链表中就有了一个新元素。</p>
<p>现在来处理第二种场景：在链表中间或尾部添加一个元素。首先，我们需要迭代链表，找到目标位置（行{3}）。这个时候，我们会循环至 index - 1 的位置，表示需要添加新节点位置的前一个位置。</p>
<p>当跳出循环时， previous 将是对想要插入新元素的位置之前一个元素的引用， current变量（行{4}）将是我们想要插入新元素的位置之后一个元素的引用。在这种情况下，我们要在 previous 和 current 之间添加新元素。因此，首先需要把新元素（ node）和当前元素链接起来（行{5}），然后需要改变 previous 和 current 之间的链接。我们还需要让 previous.next 指向 node（行{6}），取代 current。</p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/insert2.png" alt="insert2"><br>如果试图向最后一个位置添加一个新元素， previous 将是对链表最后一个元素的引用，而current 将是 undefined。在这种情况下， node.next 将指向 current，而 previous.next将指向 node，这样链表中就有了一个新元素。</p>
<p>现在来看看如何向链表中间添加一个新元素:<br><img src="http://q2e38owot.bkt.clouddn.com/image/study/insert3.png" alt="insert3"><br>在这种情况下，我们试图将新元素（ node）插入 previous 和 current 元素之间。首先，我们需要把 node.next 的值指向 current，然后把 previous.next 的值设为 node。这样列表中就有了一个新元素。</p>
<hr>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的连接；而双向链表中，连接是双向的：一个链向下一个元素，另一个链向前一个元素。</p>
<p>如下图所示：</p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/DoublyLinkedList.png" alt="双向链表"></p>
<h3 id="实现代码部分"><a href="#实现代码部分" class="headerlink" title="实现代码部分"></a>实现代码部分</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>(element, next, prev) &#123;</span><br><span class="line">    <span class="keyword">super</span>(element, next); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.prev = prev; <span class="comment">// &#123;3&#125; 新增的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="literal">undefined</span>; <span class="comment">// &#123;6&#125; 新增的，保存对链表最后一个元素的引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DoublyLinkedList 类是一种特殊的 LinkedList 类，所以很多属性和方法可以从 LinkedList 类中继承。</p>
<p>双向链表提供了两种迭代方法：从头到尾，或者从尾到头。我们也可以访问一个特定节点的下一个或前一个元素。  所以除了 Node 类中的 element 和 next 属性，还需要一个 prev 的属性。</p>
<h4 id="在任意位置插入新元素"><a href="#在任意位置插入新元素" class="headerlink" title="在任意位置插入新元素"></a>在任意位置插入新元素</h4><p>双向链表需要同时控制 next 和 prev 两个指针。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">insert(element, index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> DoublyNode(element);</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123; <span class="comment">// &#123;1&#125; 新增的,双向链表为空</span></span><br><span class="line">                <span class="keyword">this</span>.head = node;</span><br><span class="line">                <span class="keyword">this</span>.tail = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// current变量是双向链表中第一个元素的引用</span></span><br><span class="line">                node.next = <span class="keyword">this</span>.head; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">                current.prev = node; <span class="comment">// &#123;3&#125; 新增的，current.prev指针由undefined指向新元素</span></span><br><span class="line">                <span class="keyword">this</span>.head = node; <span class="comment">// &#123;4&#125;将head指向node</span></span><br><span class="line">                <span class="comment">// node.prev指针指向undefined</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="keyword">this</span>.count) &#123; <span class="comment">// 最后一项 // 新增的</span></span><br><span class="line">            current = <span class="keyword">this</span>.tail; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">            current.next = node; <span class="comment">// &#123;6&#125;基于构造函数的缘故，node.next已经指向了undefined</span></span><br><span class="line">            node.prev = current; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">            <span class="keyword">this</span>.tail = node; <span class="comment">// &#123;8&#125;更新tail，由current变为指向node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>); <span class="comment">// &#123;9&#125;迭代双向链表，直到到要找到的位置</span></span><br><span class="line">            current = previous.next; <span class="comment">// &#123;10&#125;</span></span><br><span class="line">            node.next = current; <span class="comment">// &#123;11&#125;</span></span><br><span class="line">            previous.next = node; <span class="comment">// &#123;12&#125;</span></span><br><span class="line">            current.prev = node; <span class="comment">// &#123;13&#125; 新增的</span></span><br><span class="line">            node.prev = previous; <span class="comment">// &#123;14&#125; 新增的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在双向链表的第一个位置插入第一个新元素：</p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/doubly-insert.png" alt=""></p>
<p>在双向链表最后添加一个新元素：</p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/doubly-insert2.png" alt=""></p>
<p>在双向链表中间插入一个新元素 ：</p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/doubly-insert3.png" alt=""></p>
<h4 id="从任意位置移除元素"><a href="#从任意位置移除元素" class="headerlink" title="从任意位置移除元素"></a>从任意位置移除元素</h4><p>从双向链表中移除元素跟链表非常类似。唯一的区别就是，还需要设置前一个位置的指针。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = current.next; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">            <span class="comment">// 如果只有一项，更新 tail // 新增的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.count === <span class="number">1</span>) &#123; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">                <span class="keyword">this</span>.tail = <span class="literal">undefined</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.head.prev = <span class="literal">undefined</span>; <span class="comment">// &#123;3&#125;更新current.next指向上一个元素的指针</span></span><br><span class="line">                <span class="comment">// 因为head也指向双向链表中新的第一个元素，也可以用current.next.prev</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="keyword">this</span>.count - <span class="number">1</span>) &#123; <span class="comment">// 最后一项 //新增的</span></span><br><span class="line">            current = <span class="keyword">this</span>.tail; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">            <span class="keyword">this</span>.tail = current.prev; <span class="comment">// &#123;5&#125;把tail的引用更新为双向链表中倒数第二个元素</span></span><br><span class="line">            <span class="keyword">this</span>.tail.next = <span class="literal">undefined</span>; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = <span class="keyword">this</span>.getElementAt(index); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">            <span class="keyword">const</span> previous = current.prev; <span class="comment">// &#123;8&#125;</span></span><br><span class="line">            <span class="comment">// 将 previous 与 current 的下一项链接起来——跳过 current</span></span><br><span class="line">            previous.next = current.next; <span class="comment">// &#123;9&#125;</span></span><br><span class="line">            current.next.prev = previous; <span class="comment">// &#123;10&#125; 新增的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count--;</span><br><span class="line">        <span class="keyword">return</span> current.element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们需要处理三种场景：从头部、从中间和从尾部移除一个元素。  </p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/doubly-removeAt.png" alt="移除第一个元素"></p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/doubly-removeAt2.png" alt="移除最后一个元素"></p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/doubly-removeAt3.png" alt="从中间移除一个元素  "></p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表又分为单向循环链表和双向循环列表。</p>
<p>循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（ tail.next）不是引用 undefined，而是指向第一个元素（ head），如下图所示。  </p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/CircularLinkedList1.png" alt=""></p>
<p>双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev。  </p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/CircularLinkedList2.png" alt=""></p>
<h3 id="实现代码部分-1"><a href="#实现代码部分-1" class="headerlink" title="实现代码部分"></a>实现代码部分</h3><p>CircularLinkedList 类不需要任何额外的属性，所以直接扩展 LinkedList 类并覆盖需要改写的方法即可。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CircularLinkedList extends LinkedList &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="在任意位置插入新元素-1"><a href="#在任意位置插入新元素-1" class="headerlink" title="在任意位置插入新元素"></a>在任意位置插入新元素</h4><p>向循环链表中插入元素的逻辑和向普通链表中插入元素的逻辑是一样的。不同之处在于我们需要将循环链表尾部节点的 next 引用指向头部节点。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">insert(element, index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = node; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        node.next = <span class="keyword">this</span>.head; <span class="comment">// &#123;2&#125; 新增的，将最后一个节点链接到 head</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.next = current; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        current = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.size()); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">        <span class="comment">// 更新最后一个元素</span></span><br><span class="line">        <span class="keyword">this</span>.head = node; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        current.next = <span class="keyword">this</span>.head; <span class="comment">// &#123;6&#125; 新增的</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这种场景没有变化</span></span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">      node.next = previous.next;</span><br><span class="line">      previous.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来分析一下不同的场景。</p>
<p>在循环链表第一个位置插入新元素  :</p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/circular-insert1.png" alt=""></p>
<p>第二种情况是在一个非空循环链表的第一个位置插入元素：</p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/circular-insert2.png" alt=""></p>
<h4 id="从任意位置移除元素-1"><a href="#从任意位置移除元素-1" class="headerlink" title="从任意位置移除元素"></a>从任意位置移除元素</h4><p>要从循环链表中移除元素，我们只需要考虑第二种情况，也就是修改循环链表的 head 元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.size() === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">undefined</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> removed = <span class="keyword">this</span>.head; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        current = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.size()); <span class="comment">// &#123;2&#125; 新增的</span></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">        current.next = <span class="keyword">this</span>.head; <span class="comment">// &#123;4&#125;</span></span><br><span class="line">        current = removed; <span class="comment">// &#123;5&#125;更新 current 变量的引用，这样就能返回它</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不需要修改循环链表最后一个元素</span></span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">      current = previous.next;</span><br><span class="line">      previous.next = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count--;</span><br><span class="line">    <span class="keyword">return</span> current.element; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个场景是从只有一个元素的循环链表中移除一个元素。 这种情况下，我们只需要将 head<br>赋值为 undefined，和 LinkedList 类中的实现一样。  </p>
<p>第二种情况是从一个非空循环链表中移除第一个元素。由于 head 的指向会改变，我们需要修改最后一个节点的 next 属性。那么，我们首先保存现在的 head 元素的引用，它将从循环链表中移除（行{1}）。与我们在 insert 方法中所做的一样，同样需要获得循环链表最后一个元素的引用（行{2}），它会被存储在 current 变量中。在取得所有所需节点的引用后，我们可以开始构建新的节点指向了。先更新 head element，将其指向第二个元素（ head.next ——行{3}），然后我们将最后一个 element（ current.next）指向新的 head（行{4}）。我们可以更新 current 变量的引用（行{5}），这样就能返回它（行{6}）来表示移除元素的值。</p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/circular-remove.png" alt=""></p>
<h2 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h2><p>有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。  </p>
<h3 id="实现代码部分-2"><a href="#实现代码部分-2" class="headerlink" title="实现代码部分"></a>实现代码部分</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Compare = &#123;</span><br><span class="line">  LESS_THAN: <span class="number">-1</span>,</span><br><span class="line">  BIGGER_THAN: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals, compareFn = defaultCompare) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn);</span><br><span class="line">    <span class="keyword">this</span>.compareFn = compareFn; <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SortedLinkedList 类会从 LinkedList 类中继承所有的属性和方法，但是由于这个类有特别的行为，我们需要一个用来比较元素的函数。因此，还需要声明 compareFn（行{3}），用来比较元素。该函数会默认使用 defaultCompare。如果元素有相同的引用，它就返回 0（行{1}）。如果第一个元素小于第二个元素，它就返回-1，反之则返回 1。为了保证代码优雅，我们可以声明一个 Compare 常量来表示每个值。如果用于比较的元素更复杂一些，我们可以创建自定义的比较函数并将它传入 SortedLinkedList 类的构造函数中。</p>
<h4 id="有序插入元素"><a href="#有序插入元素" class="headerlink" title="有序插入元素"></a>有序插入元素</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">insert(element, index = <span class="number">0</span>) &#123; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.insert(element, <span class="number">0</span>); <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> pos = <span class="keyword">this</span>.getIndexNextSortedElement(element); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.insert(element, pos); <span class="comment">// &#123;4&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getIndexNextSortedElement(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="keyword">this</span>.size() &amp;&amp; current; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> comp = <span class="keyword">this</span>.compareFn(element, current.element); <span class="comment">// &#123;5&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (comp === Compare.LESS_THAN) &#123; <span class="comment">// &#123;6&#125;</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// &#123;7&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章介绍了链表这种数据结构，以及其变体：双向链表、循环链表和有序链表。你学习了如何在任意位置添加和移除元素，以及如何循环访问链表。你还学习了链表相比数组最重要的优点，那就是无须移动链表中的元素，就能轻松地添加和移除元素。因此，当你需要添加和移除很多元素时，最好的选择就是链表，而非数组。 </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双向链表</tag>
        <tag>循环链表</tag>
        <tag>有序链表</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2019/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>我们了解到，可以在数组的任意位置进行添加或者删除元素，但是如果想在添加和删除元素时进行更多的操作，还提供了两种类似数组的数据结构：栈和队列</p>
<h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><p>栈是遵循后进先出（LIFO）原则的有序集合</p>
<h3 id="创建一个基于数组的栈"><a href="#创建一个基于数组的栈" class="headerlink" title="创建一个基于数组的栈"></a>创建一个基于数组的栈</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个类来表示栈，声明一个Stack类,并定义栈的一些方法方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 声明一个数组来保存栈内元素</span></span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push(element(s))：添加一个（或几个）新元素到栈顶</span></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(element)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// pop()：移除栈顶的元素，同时返回被移除的元素。</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// peek()： 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素， 仅仅返回它）。</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// clear()：移除栈里的所有元素。</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// size()：返回栈里的元素个数。该方法和数组的 length 属性很类似。</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty()); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">5</span>)</span><br><span class="line">stack.push(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek());  <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stack.size());  <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty()); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="创建一个基于对象的栈"><a href="#创建一个基于对象的栈" class="headerlink" title="创建一个基于对象的栈"></a>创建一个基于对象的栈</h3><p>用数组创建的栈，有以下缺点：</p>
<ul>
<li>大多数方法的时间复制度为 O(n)，意思是我们需要迭代整个数组，直到找到要找的那个元素，耗时</li>
<li>数组是一个有序集合，为了保证元素排列有序，它会占用更多的内存空间，耗空间</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// count 记录栈的大小</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items[<span class="keyword">this</span>.count] = element;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.count--;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.items[<span class="keyword">this</span>.count];</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.items[<span class="number">0</span>]&#125;</span>`</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;<span class="keyword">this</span>.count;i++)&#123;</span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.items[i]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用栈解决问题"><a href="#用栈解决问题" class="headerlink" title="用栈解决问题"></a>用栈解决问题</h2><h3 id="用于解决十进制转二进制"><a href="#用于解决十进制转二进制" class="headerlink" title="用于解决十进制转二进制"></a>用于解决十进制转二进制</h3><p>思路：</p>
<ul>
<li>声明一个循环，将十进制除二的余数放入栈中</li>
<li>声明另一个循环，将存入栈的余数弹出，并转换为 String 类型</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToBinary</span>(<span class="params">decNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> remStack = <span class="keyword">new</span> Stack()</span><br><span class="line">  <span class="keyword">let</span> rem;</span><br><span class="line">  <span class="keyword">let</span> number = decNumber</span><br><span class="line">  <span class="keyword">let</span> binaryString = <span class="string">''</span></span><br><span class="line">  <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(number % <span class="number">2</span>)</span><br><span class="line">    remStack.push(rem)</span><br><span class="line">    number = <span class="built_in">Math</span>.floor(number / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!remStack.isEmpty())&#123;</span><br><span class="line">    binaryString += remStack.pop().toString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> binaryString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(decimalToBinary(<span class="number">233</span>)); <span class="comment">//11101001</span></span><br><span class="line"><span class="built_in">console</span>.log(decimalToBinary(<span class="number">10</span>));  <span class="comment">//1010</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>十进制转二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2019/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>根据书上内容,对于数组的一些方法做了一些总结</p>
<h2 id="JavaScript-的数组方法参考"><a href="#JavaScript-的数组方法参考" class="headerlink" title="JavaScript 的数组方法参考"></a>JavaScript 的数组方法参考</h2><table>
<thead>
<tr>
<th>方 法</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>concat</td>
<td>连接 2 个或更多数组，并返回结果</td>
</tr>
<tr>
<td>every</td>
<td>对数组中的每个元素运行给定函数，如果该函数对每个元素都返回 true，则返回 true</td>
</tr>
<tr>
<td>some</td>
<td>对数组中的每个元素运行给定函数，如果任一元素返回 true，则返回 true</td>
</tr>
<tr>
<td>forEach</td>
<td>对数组中的每个元素运行给定函数。这个方法没有返回值</td>
</tr>
<tr>
<td>map</td>
<td>对数组中的每个元素运行给定函数，返回每次函数调用的结果组成的数组</td>
</tr>
<tr>
<td>filter</td>
<td>对数组中的每个元素运行给定函数，返回该函数会返回 true 的元素组成的数组</td>
</tr>
<tr>
<td>join</td>
<td>将所有的数组元素连接成一个字符串</td>
</tr>
<tr>
<td>indexOf</td>
<td>返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1</td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>返回在数组中搜索到的与给定参数相等的元素的索引里最大的值</td>
</tr>
<tr>
<td>reverse</td>
<td>颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个</td>
</tr>
<tr>
<td>slice</td>
<td>传入索引值，将数组里对应索引范围内的元素作为新数组返回</td>
</tr>
<tr>
<td>sort</td>
<td>按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数</td>
</tr>
<tr>
<td>toString</td>
<td>将数组作为字符串返回</td>
</tr>
<tr>
<td>valueOf</td>
<td>和 toString 类似，将数组作为字符串返回</td>
</tr>
</tbody></table>
<h3 id="迭代器函数"><a href="#迭代器函数" class="headerlink" title="迭代器函数"></a>迭代器函数</h3><p>JavaScript 内置了许多数组可用的迭代方法。我们需要一个数组和一个函数：假设数组中的值是从 1 到 15；如果数组里的元素可以被 2 整除（偶数），函数就返回 true，否则返回 false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果x是2的倍数，就返回true</span></span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>];</span><br></pre></td></tr></table></figure>

<ol>
<li>用 every 方法迭代<br>every 方法会迭代数组中的每个元素，直到返回 false。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">numbers.every(isEven);</span><br></pre></td></tr></table></figure>
在这个例子里，数组 numbers 的第一个元素是 1， 它不是 2 的倍数（ 1 是奇数）， 因此 isEven函数返回 false，然后 every 执行结束。</li>
</ol>
<h2 id="ECMAScript6-和数组的新功能"><a href="#ECMAScript6-和数组的新功能" class="headerlink" title="ECMAScript6 和数组的新功能"></a>ECMAScript6 和数组的新功能</h2><p>下表列出了 ES2015 和 ES2016 新增的数组方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@@iterator</td>
<td>返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对</td>
</tr>
<tr>
<td>copyWithin</td>
<td>复制数组中一系列元素到同一数组指定的起始位置</td>
</tr>
<tr>
<td>entries</td>
<td>返回包含数组所有键值对的@@iterator</td>
</tr>
<tr>
<td>includes</td>
<td>如果数组中存在某个元素则返回 true，否则返回 false。 E2016 新增</td>
</tr>
<tr>
<td>find</td>
<td>根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素</td>
</tr>
<tr>
<td>findIndex</td>
<td>根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引</td>
</tr>
<tr>
<td>fill</td>
<td>用静态值填充数组</td>
</tr>
<tr>
<td>from</td>
<td>根据已有数组创建一个新数组</td>
</tr>
<tr>
<td>keys</td>
<td>返回包含数组所有索引的@@iterator</td>
</tr>
<tr>
<td>of</td>
<td>根据传入的参数创建一个新数组</td>
</tr>
<tr>
<td>values</td>
<td>返回包含数组中所有值的@@iterator</td>
</tr>
</tbody></table>
<h3 id="使用-iterator-对象"><a href="#使用-iterator-对象" class="headerlink" title="使用 @@iterator 对象"></a>使用 @@iterator 对象</h3><p>ES2015 还为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问。代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = numbers[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>然后，不断调用迭代器的 next 方法，就能依次得到数组中的值。 numbers 数组中有 15 个值，因此需要调用 15 次 iterator.next().value。</p>
<p>我们可以用下面的代码来输出 numbers 数组中的 15 个值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">iterator = numbers[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> iterator) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组中的所有值都迭代完之后， iterator.next().value 会返回 undefined。</p>
<h3 id="数组的-entries、keys和values方法"><a href="#数组的-entries、keys和values方法" class="headerlink" title="数组的 entries、keys和values方法"></a>数组的 entries、keys和values方法</h3><p>entries 方法返回包含键值对的 @@iterator,使用集合、字典、散列表等数据结构时，能够取出键值对是很有用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aEntries = numbers.entries(); <span class="comment">// 得到键值对的迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries.next().value); <span class="comment">// [0, 1] - 位置 0 的值为 1</span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries.next().value); <span class="comment">// [1, 2] - 位置 1 的值为 2</span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries.next().value); <span class="comment">// [2, 3] - 位置 2 的值为 3</span></span><br></pre></td></tr></table></figure>

<p>keys 方法返回包含数组索引的 @@iterator,values 方法返回的 @@iterator 则包含数组的值</p>
<h2 id="fafa"><a href="#fafa" class="headerlink" title="fafa"></a>fafa</h2><p><strong>使用数组实现斐波拉契数列</strong><br>求斐波拉契数列的前 20 个数。已知斐波那契数列中的前两项是 1，从第三项开始，每一项都等于前两项之和。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fibonacci = []</span><br><span class="line">fibonacci[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">fibonacci[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">3</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">  fibonacci[i]=fibonacci[i<span class="number">-1</span>]+fibonacci[i<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;fibonacci.length;i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fibonacci[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6复习(二)</title>
    <url>/2019/12/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%A4%8D%E4%B9%A0%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="ES6复习"><a href="#ES6复习" class="headerlink" title="ES6复习"></a>ES6复习</h1><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 函数是 ES6 提供的一种异步解决方案，语法行为与传统的函数不同。</p>
<p>语法上，可以将 Generator 函数理解成一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说它也是一个遍历器对象生成函数。返回遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>形式上，Generator函数是一个普通的函数，有两个特征需要注意，</p>
<ol>
<li><code>function</code> 关键字与函数之间有一个星号</li>
<li>函数内部使用 <code>yield</code> 表达式，定义不同的内部状态</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>

<p>其中调用 Generator 函数后，函数并不执行，返回的也不是函数运行的结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。<br>所以是对返回的遍历器对象进行操作，所以要调用遍历器对象的 <code>next</code> 方法。Generator 函数是分段执行的，<code>yield</code> 表达式是暂停执行的标记，而 <code>next</code> 方法可以恢复执行。</p>
<p><code>for...of</code> 可以自动遍历 Generator 函数运行时生成的 Itearator 对象，且此时不再需要 <code>next</code> 方法。</p>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 函数就是 Generator 函数的语法糖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码的函数gen可以写成async函数，就是下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p>
<p>具体文章还是看阮老师的 ES6标准入门，讲的比较清楚。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>复习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6复习(一)</title>
    <url>/2019/12/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="ES6复习（Promise、Iterator）"><a href="#ES6复习（Promise、Iterator）" class="headerlink" title="ES6复习（Promise、Iterator）"></a>ES6复习（Promise、Iterator）</h1><p>参照阮老师的 ECMAScript 标准入门</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Promise 是一个对象，可以将异步操作以同步操作的流程表达出来，解决<em>回调地狱</em> 的层层嵌套。</p>
<p>其中包含三个状态：</p>
<ul>
<li>pending（进行中）</li>
<li>fulfilled（已成功）</li>
<li>rejected（已失败）</li>
</ul>
<p><code>Promise</code> 的状态改变只有两种：pending =&gt; fulfilled，pending =&gt; rejected。其中状态一旦改变，状态就凝固了，不会再改变，会一直保持这个结果，这时就称为 resolved（已定型）。</p>
<p>缺点：第一是无法取消，一旦新建就会立即执行，无法中途取消。第二是不设置回调函数会抛出错误。第三是当处于 <code>pending</code> 状态时，无法知道目前到哪一个阶段。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中函数里有两个 <code>resolve</code> 和 <code>reject</code> 函数，由 JavaScript 引擎提供。</p>
<p><code>resolve</code> 的作用是将 <code>Promise</code> 的状态从 pending =&gt; fulfilled，在异步操作成功后调用，并将异步操作的结果作为参数返回出去。<code>reject</code> 的作用是将 <code>Promise</code> 的状态从 pending =&gt; rejected，在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。</p>
<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>
<h2 id="Iterator（遍历器）"><a href="#Iterator（遍历器）" class="headerlink" title="Iterator（遍历器）"></a>Iterator（遍历器）</h2><p>Iterator 是一种统一接口，为不同数据结构提供统一的访问机制。任何数据结构只要部署了 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构中的所有成员。Iterator 遍历对象是一个指针对象，其中包含 next 方法，指向下一个数据结构的成员。返回包含 value 和 done 两种属性的对象， value 是当前成员的值，done 是一个布尔值，表示遍历是否结束。</p>
<p>JavaScript表示 “集合” 的数据结构有：</p>
<ul>
<li>数组</li>
<li>对象</li>
<li>ES6 新增的 Set、Map</li>
</ul>
<p>Iterator 的作用</p>
<ol>
<li>为各种数据结构提供统一的、简单的访问接口</li>
<li>使得数据结构的成员能够按照某种次序排列</li>
<li>ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费</li>
</ol>
<p>ES6 的一些数据原生具备 Iterator 接口（比如数组），即不用任何处理就可以被 for…of 处理，因为这些数据结构原生部署了 <code>Symbol.iterator</code>，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在  <code>Symbol.iterator</code> 属性上面部署，这样才会被<code>for...of</code>循环遍历。对象之所以没有默认部署 Iterator 接口，是因为对象中的数据是非线性的。</p>
<p>原生具备 Iterator 接口的数据结构如下：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>复习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo写作命令大全</title>
    <url>/2019/12/12/Hexo%E5%86%99%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="Hexo写作命令大全"><a href="#Hexo写作命令大全" class="headerlink" title="Hexo写作命令大全"></a>Hexo写作命令大全</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一名前端程序员当然要有自己的博客存，以前用 markdown 写一些自己的学习笔记，但是写完之后都不会去回顾，因为存放在电脑上回顾起来比较麻烦。所以最近在着手自己的博客项目，但是对于 hexo 的一些写作命令并不是很熟悉，所以在网上找到了一些牛人前辈写的博客，下面开始练练手吧。</p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>在博客目录下执行如下命令新建一篇文章</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new [layout] &lt;title&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果未指定文章的布局（layout），则默认使用 <code>post</code> 布局，生成的文档存放于 <code>source\_posts\</code> 目录下，打开后使用 Markdown 语法进行写作，保存后刷新浏览器即可看到文章。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>布局可以理解为新建文档时的一个模块，基于布局生成的文档将会继承布局的样式。</p>
<p>Hexo 默认有三种布局：<code>post</code>、 <code>page</code> 和 <code>draft</code>，用户可以在 <code>scaffolds</code> 目录下新建文档来自定义布局格式，还可以修改站点配置文件中的 <code>default_layout</code>参数来指定生成文档时的默认布局。</p>
<p><img src="http://q2e38owot.bkt.clouddn.com/image/study/hexo1.png" alt="image-20191212151710263"></p>
<h3 id="文章（post）"><a href="#文章（post）" class="headerlink" title="文章（post）"></a>文章（post）</h3><p>基于 <code>post</code> 布局生成的文档存在于 <code>source\_posts\</code> 目录下，该目录下的文档会作为博客正文显示在网站中。</p>
<h3 id="页面（page）"><a href="#页面（page）" class="headerlink" title="页面（page）"></a>页面（page）</h3><p><code>page</code> 布局用于生成类似 <strong>首页</strong> 和 <strong>归档</strong> 这样的页面。</p>
<h3 id="草稿（draft）"><a href="#草稿（draft）" class="headerlink" title="草稿（draft）"></a>草稿（draft）</h3><p><code>draft</code> 布局用于创建草稿，生成的文档存在于 source_drafts\ 目录中，默认配置下将不会把该目录下的文档渲染到网站中。</p>
<p>通过以下命令将草稿发布为正式文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><p><code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code> #新建文章<br><code>hexo p</code> == <code>hexo publish</code><br><code>hexo g</code> == <code>hexo generate</code>#生成<br><code>hexo s</code> == <code>hexo server</code> #启动服务预览<br><code>hexo d</code> == <code>hexo deploy</code>#部署</p>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><code>hexo server -s</code> #静态模式<br><code>hexo server -p 5000</code> #更改端口<br><code>hexo server -i 192.168.1.1</code> #自定义 IP</p>
<p><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略此条命令<br><code>hexo g</code> #生成静态网页<br><code>hexo d</code> #开始部署</p>
<hr>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>Markdown 并不会保存插入的图片资源本身，只是记录了获取资源的链接。<br>在 Markdown 中插入一张图片的步骤：</p>
<ol>
<li>将图片上床到图床上</li>
<li>获取图片的连接</li>
<li>插入到 Markdown 中</li>
</ol>
<blockquote>
<p>引用连接:<br><a href="http://yearito.cn/posts/hexo-writing-skills.html" target="_blank" rel="noopener">http://yearito.cn/posts/hexo-writing-skills.html</a><br><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002632530</a></p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo常用命令</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解JavaScript</title>
    <url>/2019/11/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3javascript/</url>
    <content><![CDATA[<h1 id="JS的参数传递"><a href="#JS的参数传递" class="headerlink" title="JS的参数传递"></a>JS的参数传递</h1><h2 id="参数到底如何传递"><a href="#参数到底如何传递" class="headerlink" title="参数到底如何传递"></a>参数到底如何传递</h2><blockquote>
<p>ECMAScript 中所有函数的参数都是按值传递的</p>
</blockquote>
<p>普通类型是按值传递，拷贝原值，引用类型是按共享传递拷贝了引用，都是拷贝值，所以都是按值传递</p>
<p>这个值如果是简单类型，那么就是其本身。如果是引用类型也就是对象传递就是指向这个对象的地址。故我们可以认为参数全部都是值传递，具体例子：</p>
<h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    n: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    data = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.n) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>传递引用类型传递的是指针。</p>
<p><img src="https://user-images.githubusercontent.com/15126694/30241403-3fafc13e-95b5-11e7-99f5-1f092c78c48a.png" alt="image"></p>
<p> 首先执行<code>var obj = {n: 1};</code>，可以看作在栈的011地址中存入了一个指向<code>{n:1}</code>堆的指针*p </p>
<p><img src="https://camo.githubusercontent.com/e97db40b68c6739348c68215b893e99aa6b044c5/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f392f3435333865666535373066656465313233323131653465313334336434326265" alt="img"></p>
<p> 接下来为声明<code>function foo</code>此时会创建函数执行上下文，产生一个变量对象，其中声明了形参data，由于函数没有执行，当前值为undefined。我们记data地址为022。关于更多变量对象的知识可以参考冴羽老师的这篇<a href="https://github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">JavaScript深入之变量对象</a>，本文不深入研究关于AO相关，你只需要知道在声明这个函数的时候里面的形参已经被创建出来了。 </p>
<p><img src="https://camo.githubusercontent.com/74cfb299ca39361602d9887579815203274faa97/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f392f6339343533643630346530653536383466646234396363623362363733323733" alt="img"></p>
<p> 执行<code>foo(obj)</code>其中会进行参数传递，其中将obj中存储的*p拷贝给处在022地址的data，那么此时它们就指向了同一个对象，如果某一个变量更改了n的值，另一个变量中n的值也会更改，因为其中保存的是指针。 </p>
<p><img src="https://camo.githubusercontent.com/35dc851e4ebcff7f39b5c3c0c646c49c97927473/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f392f3932313831323661303734336639646631356566333061366430366663336636" alt="img"></p>
<p> 进入函数内部，顺序执行<code>data = 2;</code>此时002地址存储了基本类型值，则直接存储在栈中，从而与堆中的{n:1}失去了联系。从而打印<code>console.log(data) // 2</code>，最后发现初始开辟的{n:1}对象没有过更改，故而<code>console.log(obj.n) // 1</code>仍然打印1。 </p>
<h3 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.n); <span class="comment">//1</span></span><br><span class="line">  obj.n=<span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.n) <span class="comment">//2</span></span><br><span class="line">&#125;)(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.n) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><img src="https://camo.githubusercontent.com/d68b740a7853af8053452f3951e355813c43702c/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f31302f3663393932636235653461306239363965353436343531303631306432643032" alt="img"></p>
<p> 声明函数，虽然同为obj变量名，但是形参obj为AO中的属性，不会与全局造成覆盖，其拥有新的地址记作022，在未执行前其值为undefined。 </p>
<p> 函数立即执行，此时将全局obj赋值给形参obj，我们忽略这个重复命名的问题，其实就是将011中的 指针*p拷贝了一份给了022。同时执行第一个<code>console.log(obj.n)</code>结果即为1。 </p>
<p><img src="https://camo.githubusercontent.com/14e00a0a7f9ab9a3ebf2a9e34cc67076052cee9e/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f31302f3762616537666632636134393132656530356139663139383762653434656136" alt="img"></p>
<p> 执行<code>obj.n=3</code>，此时为函数的形参即022中的obj来改变了对象内n的值。 </p>
<p><img src="https://camo.githubusercontent.com/2e191b1b44a608063fc851841c053aeb42b5b101/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f31302f3364646364386139666562346364336636663030393033613766656332376264" alt="img"></p>
<p><strong>最关键的一步</strong>：<code>var obj = {n:2};</code>由于对象命名的关系可能很多童鞋就会有点懵，但依然按照同样的方式来分析即可，由于使用了var那么就是新声明一个对象，从而会在栈中压入新的地址记作033，其中存入了新的指针指向了新的对象{n:2}。从而之后打印的<code>console.log(obj.n)</code>结果则应是新开辟的对象中的n的值。</p>
<p>最后打印<code>console.log(obj.n) //3</code>很显然，全局的对象有过一次更改其值为3。</p>
<hr>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是指程序源代码中定义变量的区域。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<h2 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h2><p>JavaScript 采用的词法作用域，也就是静态作用域，函数的作用域在函数定义的时候就决定了。</p>
<p>而词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 1</span></span><br></pre></td></tr></table></figure>

<p> 主要区别：<strong>词法作用域是在写代码或者定义时确定的，而动态作用域是在运行时确定的（this也是！）。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用</strong>。 </p>
<hr>
<h1 id="Js执行上下文栈"><a href="#Js执行上下文栈" class="headerlink" title="Js执行上下文栈"></a>Js执行上下文栈</h1><blockquote>
<p> <a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/4</a> </p>
</blockquote>
<h2 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h2><p>JavaScript 的可执行代码的类型有三种：</p>
<ul>
<li><p>全局代码</p>
</li>
<li><p>函数代码</p>
</li>
<li><p>eval代码</p>
<p>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。 </p>
</li>
</ul>
<p>当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。</p>
<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>我们可以把函数的执行过程看做一个执行上下文栈，当函数被创建时就会将函数推入执行上下文栈中，当函数执行完毕后，就将该函数从栈中弹出。</p>
<hr>
<h1 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h1><p>每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象</li>
<li>作用域链</li>
<li>this</li>
</ul>
<p>变量对象是与执行上下文相关的数据作用域，存储了上下文定义的变量和函数声明。</p>
<p>不同上下文的变量对象有所不同，可分为 <strong>全局上下文</strong> 下的变量对象和 <strong>函数上下文</strong> 下的变量对象</p>
<h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>全局对象：是预定义对象，在顶层 JavaScript 中，可以通过 this 引用全局变量，全局对象时作用域链的头，意味着在顶层 JavaScript 中声明的所有变量都可以成为全局对象的属性。</p>
<p>1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>2.全局对象是由 Object 构造函数实例化的一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure>

<p>3.预定义了一堆，嗯，一大堆函数和属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 都能生效</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.Math.random());</span><br></pre></td></tr></table></figure>

<p>4.作为全局变量的宿主。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br></pre></td></tr></table></figure>

<p>5.客户端 JavaScript 中，全局对象有 window 属性指向自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.window.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span><br></pre></td></tr></table></figure>

<p>全局上下文中的变量对象就是全局对象！</p>
<h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p> 在函数上下文中，我们活动对象（activation object，AO）来表示变量对象。</p>
<p>活动对象不可以在 JavaScript 环境中访问，只有当进入一个执行上下文中，这个执行上下文的变量对象才会被激活。而只有被激活的变量对象，也就是活动对象上的属性才能被访问。</p>
<p>活动对象是进入函数上下文被创建的，它通过函数的 arguments 属性初始化， arguments 属性值是 Arguments 对象。 </p>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：</p>
<ol>
<li>进入执行上下文</li>
<li>代码执行</li>
</ol>
<h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p>
<p>变量对象会包括：</p>
<ol>
<li>函数的所有形参 (如果是函数上下文)<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 undefined</li>
</ul>
</li>
<li>函数声明<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
</li>
<li>变量声明<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li>
</ul>
</li>
</ol>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b = 2;</span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line">  var d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1);</span><br></pre></td></tr></table></figure>

<p>在进入执行上下文后，这时候的 AO 是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p>
<p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p>
<ol>
<li>全局上下文的变量对象初始化是全局对象</li>
<li>函数上下文的变量对象初始化只包括 Arguments 对象</li>
<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li>
<li>在代码执行阶段，会再次修改变量对象的属性值</li>
</ol>
<p>分析：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>打印的是函数，而不是 undefined。</p>
<p>因为在进入函数上下文时，首先会处理函数声明，其次处理变量声明，如果变量声明名称的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p>
<hr>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>当查找变量的时候，会先从当前上下文的变量对象中进行查找，如果没有，会在父级中的执行上下文的变量对象中查找，还是没有，就一直查找上一级上下文中的变量对象。直到全局上下文中的变量对象。这种由多个执行上下文的对象构成的链就是作用域链。</p>
<p>用函数的创建和激活理解作用域链：</p>
<h2 id="函数的创建"><a href="#函数的创建" class="headerlink" title="函数的创建"></a>函数的创建</h2><p>函数作用域在函数被定义时就决定了。</p>
<p>这是由于函数内部有一个内部属性 <code>[[scope]]</code>，当函数创建的时候，就会保存所有父变量到其中，可以理解 <code>[scope]</code> 就是所有父变量的层级链。但是注意：<code>[[scope]]</code> 并不代表完整的作用域链。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数创建时，各自的[[scope]]为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数被激活时，进入执行上下文，创建 VO/AO 后，就会将活动对象添加到作用域链的前端。</p>
<p>这时候执行的作用域链我们命名为 Scope：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = [AO].concat([[scope]])</span><br></pre></td></tr></table></figure>

<p>至此作用域链创建完毕。</p>
<h1 id="进行梳理"><a href="#进行梳理" class="headerlink" title="进行梳理"></a>进行梳理</h1><p>结合下面例子，梳理前面讲过的执行上下文栈和变量对象，总结一下函数上下文中的作用域链和变量对象的创建过程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope2 = <span class="string">'local scope'</span>;</span><br><span class="line">    <span class="keyword">return</span> scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<p>执行过程如下：</p>
<p>1.checkscope 函数被创建，保存作用域链到内部属性[[scope]]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: <span class="literal">undefined</span></span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: &apos;local scope&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>执行函数，才会创建函数的执行上下文</p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><blockquote>
<p> <a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/7</a> </p>
</blockquote>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><blockquote>
<p> <a href="https://github.com/mqyqingfeng/Blog/issues/8" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/8</a> </p>
</blockquote>
<h1 id="闭包的问题"><a href="#闭包的问题" class="headerlink" title="闭包的问题"></a>闭包的问题</h1><blockquote>
<p> <a href="https://github.com/mqyqingfeng/Blog/issues/9" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/9</a> </p>
</blockquote>
<p>个人理解：闭包是一个有权访问另一个函数里的变量及方法的函数。</p>
<p>MND 对闭包的定义：</p>
<blockquote>
<p>闭包就是有权访问自由变量的函数。</p>
<p>自由变量是在函数中使用的，既不是函数的参数也不是函数的局部变量的变量。</p>
<p>闭包 = 函数 + 函数能够访问的自由变量</p>
</blockquote>
<p>举一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>函数 foo 可以访问变量 a，但是变量 a 既不是 foo 函数的参数，也不是局部变量，所以 a 就是自由变量。</p>
<p>所有的变量和方法都通过作用域保存起来了，即使外面的函数执行完毕被弹出执行上下文栈，内部函数也是可以通过作用域链找到相应的变量和方法。 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>第三次周总结</title>
    <url>/2019/11/10/%E5%91%A8%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h2><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，就是对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p>
<h3 id="Prototype-引用的用处"><a href="#Prototype-引用的用处" class="headerlink" title="[[Prototype]] 引用的用处"></a>[[Prototype]] 引用的用处</h3><p>当你试图引用对象的属性时会触发 [[Get]] 操作，比如 对象名.属性名。第一步是检查对象是否有这个 属性，如果有就是用它。如果没有，就需要使用对象的 [[Prototype]] 链了。</p>
<h3 id="Object-create-…-的原理"><a href="#Object-create-…-的原理" class="headerlink" title="Object.create(…)的原理"></a>Object.create(…)的原理</h3><p>创建一个对象并把这个对象的 [[Prototype]] 关联到指定的对象</p>
<h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>因为通过各种语法进行属性的查找时，都会查找 [[Prototype]] 链，直到找到属性或者查找完整条原型链。</p>
<p>所以哪里是 [[Prototype]] 的尽头呢？</p>
<p>所有普通的 [[Prototype]]链最终都会指向内置的 Object.Prototype。由于所有普通对象都源于这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。</p>
<h2 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h2><p>一个对象关于另一个对象</p>
<p>JavaScript和面向类的语言不同，JavaScript只有对象。它是可以不通过类，直接创建对象的语言。</p>
<h3 id="“类”函数"><a href="#“类”函数" class="headerlink" title="“类”函数"></a>“类”函数</h3><p>Js一直是在模仿类，这种”类似类”的行为利用了函数的一种特殊特性：所有的函数默认都会拥有一个名为 property 的公有并且不可枚举的属性，它指向另一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype</span><br></pre></td></tr></table></figure>

<p>这个对象通常被称为 Foo 的原型，因为通过名为 Foo.prototype 的属性引用来访问它。“被贴上 Foo.prototype 标签的对象”。</p>
<p>面向类语言，类是可以被复制（实例化）多次，但是在 JavaScript中，并没有类似的复制机制。不能创建一个类的多个实例，只能创建多个对象，它们 [[property]] <strong>关联</strong>的是同一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === Foo.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>new Foo() 会生成一个新对象（我们称之为a)，这个新对象的内部链接 [[Prototype]] 关联的是 Foo.prototype 对象。最后我们得到的两个对象，它们之间互相关联。我们并没有初始化一个类，实际上我们并没有从“类”中复制任何行为到另一个对象中，只是让两个对象互相关联。</p>
<p>new Foo()只是间接完成了我们的目标：一个关联到其他对象的新对象。</p>
<h4 id="关于名称"><a href="#关于名称" class="headerlink" title="关于名称"></a>关于名称</h4><p>在JavaScript中，我们并不会将一个对象（“类”）复制到另一个对象（“实例”），只是将它们关联起来。[[Prototype]] 机制如下图所示：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191107103923655.png" alt="image-20191107103923655"></p>
<p>这个机制被称为<strong>原型继承</strong></p>
<p>对象（实例）a1 到 Foo.prototype 的委托关系，还展示出 Bar.prototype 到 Foo.prototype 的委托关系，而后者和类继承很类似，只有箭头的方向不同。图中由下到上的箭头表明这是委托关联，不是复制操作。</p>
<h3 id="“构造函数”"><a href="#“构造函数”" class="headerlink" title="“构造函数”"></a>“构造函数”</h3><p>到底是什么原因让我们认为 Foo 是一个 “类” 呢？</p>
<p>一个原因是使用了关键字 new ，在面向类的语言中构造类函数实例时会用到它。另一个原因是，看起来我们执行了类的构造函数方法，Foo()的调用方式很想初始化类时类构造函数的调用方式。</p>
<p>还有另一个原因:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.constructor === Foo;  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.constructor === Foo;  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>Foo.prototype 默认（在代码第一行声明中）有一个公有并且不可枚举的属性 .constructor，这个属性引用的是对象关联的函数（本例中是 Foo）。此外，可以看到通过 “构造函数” 调用 new Foo() 创建的对象也有一个 .constructor 属性，指向 “创建这个对象的函数” 。</p>
<h4 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h4><p>上面 Foo 和你程序中的其他函数没有任何区别。函数本身并不是构造函数，然而，当你在普通函数调用前面加上 new 关键字之后，就会把这个函数调用变成一个 “构造函数调用”。实际上，new 会劫持所有普通函数并用构造对象的形式来调用它。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NothingSpecial</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Don't mind me!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> NothingSpecial();</span><br><span class="line"><span class="comment">//  "Don't mind me!"</span></span><br><span class="line"></span><br><span class="line">a; <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>NothingSpecial 只是一个普通的函数，但是使用 new 调用时，它就会构造一个对象并赋值给 a，这看起来像是 new 的一个副作用（无论如何都会构造一个对象）。这个调用是一个构造函数调用，但是 NothingSpecial 本身并不是一个构造函数。</p>
<p>在 JavaScript 中对于 “构造函数” 最准确的解释是，所有带 new 的函数调用。函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成 “构造函数调用”。</p>
<h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>参见 p151 页</p>
<p>JavaScript中的.constructor</p>
<hr>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>原型风格：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.myName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name, label</span>) </span>&#123;</span><br><span class="line">    Foo.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.label = label</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个新的 Bar.prototype 对象并关联到 Foo.prototype</span></span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，现在没有 Bar.prototype.constructor</span></span><br><span class="line"><span class="comment">// 如果你需要这个属性的话可能需要手动修复一下它</span></span><br><span class="line"></span><br><span class="line">Bar.prototype.myLabel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.label</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">"a"</span>, <span class="string">"obj a"</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="string">"b"</span>, <span class="string">"obj b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.myName()); <span class="comment">//a</span></span><br><span class="line"><span class="built_in">console</span>.log(a.myLabel()); <span class="comment">//obj a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b.myName()); <span class="comment">//b</span></span><br><span class="line"><span class="comment">//console.log(b.myLabel()); //b.myLabel is not a function</span></span><br></pre></td></tr></table></figure>

<p>调用 Object.create(..) 会凭空创建一个”新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中 Foo.prototype）。换句话说：“创建一个新的 Bar.prototype 对象并把它关联到 Foo.prototype”。</p>
<p>声明 function Bar(){..} 时，和其他函数一样，Bar 会有一个 .prototype 关联到默认的对象，但是这个对象并不是我们想要的 Foo.prototype。因此我们创建一个新对象并把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉。</p>
<p>ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法修改关联。<br>Object.setPrototypeOf(Bar.prototype，Foo.prototype)</p>
<h2 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h2><p>[[Prototype]] 机制是存在于对象的一个内部链接，它会引用其他对象。</p>
<p>通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的连接被称为“原型链”。</p>
<h2 id="原型链图："><a href="#原型链图：" class="headerlink" title="原型链图："></a>原型链图：</h2><img src="https://zacharykwan.com/uploads/prototype/prototype.jpg" alt="“复杂的原型链图”的图片搜索结果" style="zoom: 50%;" />



<h1 id="浏览器与Node的事件循环"><a href="#浏览器与Node的事件循环" class="headerlink" title="浏览器与Node的事件循环"></a>浏览器与Node的事件循环</h1><h2 id="浏览器与Node的事件循环-Event-Loop-有何区别"><a href="#浏览器与Node的事件循环-Event-Loop-有何区别" class="headerlink" title="浏览器与Node的事件循环(Event Loop)有何区别?"></a>浏览器与Node的事件循环(Event Loop)有何区别?</h2><blockquote>
<p> <a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218" target="_blank" rel="noopener">https://juejin.im/post/5c337ae06fb9a049bc4cd218</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
  <entry>
    <title>第二次周总结</title>
    <url>/2019/11/03/%E5%91%A8%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%91%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="JS的执行机制"><a href="#JS的执行机制" class="headerlink" title="JS的执行机制"></a>JS的执行机制</h1><h2 id="关于JavaScript"><a href="#关于JavaScript" class="headerlink" title="关于JavaScript"></a>关于JavaScript</h2><p>JavaScript是一门单线程语言，所有一切 JavaScript 多线程都是用但线程模拟出来的</p>
<h2 id="JavaScript事件循环"><a href="#JavaScript事件循环" class="headerlink" title="JavaScript事件循环"></a>JavaScript事件循环</h2><ul>
<li>同步任务进入主线程</li>
<li>异步任务进入Event Table</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>主线程执行完后，发现执行栈为空，就会去Event Queue中去取相应的函数。</p>
<p>事件循环的顺序，决定 js 代码的执行顺序。进入整体代码（宏任务）后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有微任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'console'</span>);复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码作为宏任务，进入主线程。</li>
<li>先遇到<code>setTimeout</code>，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li>
<li>接下来遇到了<code>Promise</code>，<code>new Promise</code>立即执行，<code>then</code>函数分发到微任务Event Queue。</li>
<li>遇到<code>console.log()</code>，立即执行。</li>
<li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了<code>then</code>在微任务Event Queue里面，执行。</li>
<li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中<code>setTimeout</code>对应的回调函数，立即执行。</li>
<li>结束。</li>
</ul>
<h2 id="宏任务、微任务与Event-Loop"><a href="#宏任务、微任务与Event-Loop" class="headerlink" title="宏任务、微任务与Event Loop"></a>宏任务、微任务与Event Loop</h2><p>JavaScript中执行的过程可以看成宏任务和微任务的执行，由于单线程的工作原理，js会一步一步的执行代码，这是第一个整体代码（宏任务），也就是主线程，如果遇到一些回调函数就会注册分发到宏任务 Event Queue（任务队列）中，继续执行，当遇到微任务时，也分发到任务队列中，待第一个宏任务执行完毕后，在执行此次的微任务，然后通过 Event Loop 执行下一个宏任务（刚刚在第一次宏任务中注册的回调函数），以此类推。直到循环结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">12</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>周总结</category>
      </categories>
      <tags>
        <tag>周总结</tag>
      </tags>
  </entry>
</search>
