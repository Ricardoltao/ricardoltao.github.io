<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RicardoJiang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-28T02:41:38.491Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ricardo Jiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>栈</title>
    <link href="http://yoursite.com/2019/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/"/>
    <id>http://yoursite.com/2019/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/</id>
    <published>2019-12-28T02:38:52.000Z</published>
    <updated>2019-12-28T02:41:38.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>我们了解到，可以在数组的任意位置进行添加或者删除元素，但是如果想在添加和删除元素时进行更多的操作，还提供了两种类似数组的数据结构：栈和队列</p><h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><p>栈是遵循后进先出（LIFO）原则的有序集合</p><h3 id="创建一个基于数组的栈"><a href="#创建一个基于数组的栈" class="headerlink" title="创建一个基于数组的栈"></a>创建一个基于数组的栈</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个类来表示栈，声明一个Stack类,并定义栈的一些方法方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 声明一个数组来保存栈内元素</span></span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push(element(s))：添加一个（或几个）新元素到栈顶</span></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(element)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// pop()：移除栈顶的元素，同时返回被移除的元素。</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// peek()： 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素， 仅仅返回它）。</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// clear()：移除栈里的所有元素。</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// size()：返回栈里的元素个数。该方法和数组的 length 属性很类似。</span></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty()); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">5</span>)</span><br><span class="line">stack.push(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek());  <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">11</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stack.size());  <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty()); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="创建一个基于对象的栈"><a href="#创建一个基于对象的栈" class="headerlink" title="创建一个基于对象的栈"></a>创建一个基于对象的栈</h3><p>用数组创建的栈，有以下缺点：</p><ul><li>大多数方法的时间复制度为 O(n)，意思是我们需要迭代整个数组，直到找到要找的那个元素，耗时</li><li>数组是一个有序集合，为了保证元素排列有序，它会占用更多的内存空间，耗空间</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// count 记录栈的大小</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items[<span class="keyword">this</span>.count] = element;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.count--;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.items[<span class="keyword">this</span>.count];</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.count - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.items[<span class="number">0</span>]&#125;</span>`</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;<span class="keyword">this</span>.count;i++)&#123;</span><br><span class="line">      objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="keyword">this</span>.items[i]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用栈解决问题"><a href="#用栈解决问题" class="headerlink" title="用栈解决问题"></a>用栈解决问题</h2><h3 id="用于解决十进制转二进制"><a href="#用于解决十进制转二进制" class="headerlink" title="用于解决十进制转二进制"></a>用于解决十进制转二进制</h3><p>思路：</p><ul><li>声明一个循环，将十进制除二的余数放入栈中</li><li>声明另一个循环，将存入栈的余数弹出，并转换为 String 类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimalToBinary</span>(<span class="params">decNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> remStack = <span class="keyword">new</span> Stack()</span><br><span class="line">  <span class="keyword">let</span> rem;</span><br><span class="line">  <span class="keyword">let</span> number = decNumber</span><br><span class="line">  <span class="keyword">let</span> binaryString = <span class="string">''</span></span><br><span class="line">  <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(number % <span class="number">2</span>)</span><br><span class="line">    remStack.push(rem)</span><br><span class="line">    number = <span class="built_in">Math</span>.floor(number / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!remStack.isEmpty())&#123;</span><br><span class="line">    binaryString += remStack.pop().toString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> binaryString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(decimalToBinary(<span class="number">233</span>)); <span class="comment">//11101001</span></span><br><span class="line"><span class="built_in">console</span>.log(decimalToBinary(<span class="number">10</span>));  <span class="comment">//1010</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;p&gt;我们了解到，可以在数组的任意位置进行添加或者删除元素，但是如果想在添加和删除元素时进行更多的操作，还提供了两种类似数组的数据结构：栈和队列&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
      <category term="十进制转二进制" scheme="http://yoursite.com/tags/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>数组降维</title>
    <link href="http://yoursite.com/2019/12/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4/"/>
    <id>http://yoursite.com/2019/12/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4/</id>
    <published>2019-12-24T07:24:23.000Z</published>
    <updated>2019-12-28T02:44:46.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组降维"><a href="#数组降维" class="headerlink" title="数组降维"></a>数组降维</h1><h2 id="二维数组降一维数组"><a href="#二维数组降一维数组" class="headerlink" title="二维数组降一维数组"></a>二维数组降一维数组</h2><p>以 <code>var oldArr=[1, 2, [3, 4]];</code> 为例：</p><ul><li><p>reduce() 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = oldArr.reduce(<span class="function">(<span class="params">accu,curr</span>)=&gt;</span>&#123;<span class="keyword">return</span> prev.concat(curr)&#125;,[])</span><br></pre></td></tr></table></figure></li><li><p>concat() 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = [].concat(...oldArr)</span><br><span class="line"><span class="keyword">var</span> newArr2 = <span class="built_in">Array</span>.prototype.concat.apply([],oldArr)</span><br></pre></td></tr></table></figure></li><li><p>flat() 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = oldArr.flat()</span><br></pre></td></tr></table></figure></li></ul><h2 id="多维降一维"><a href="#多维降一维" class="headerlink" title="多维降一维"></a>多维降一维</h2><h3 id="递归降维"><a href="#递归降维" class="headerlink" title="递归降维"></a>递归降维</h3><p>递归降维这里有两种方法：</p><ol><li><code>forEach</code> 递归</li><li><code>reduce</code> 递归</li></ol><p>举例：</p><ul><li><p>forEach递归降维</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldArr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],<span class="number">10</span>,<span class="number">11</span>,],<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,[<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newArr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ergodic = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//判断是否是数组，是就递归到深层    </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">      ergodic(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newArr.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ergodic(oldArr, newArr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ]</span></span><br></pre></td></tr></table></figure></li><li><p>reduce 递归降维</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldArr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>],[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],<span class="number">10</span>,<span class="number">11</span>,],<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,[<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ergodic = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.reduce(<span class="function">(<span class="params">prev, curr, index, list</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(curr)) &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.concat(...ergodic(curr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev.concat(curr);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newArr = ergodic(oldArr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="flat-降维"><a href="#flat-降维" class="headerlink" title="flat() 降维"></a>flat() 降维</h3><p>flat(depth) depth这个参数默认是一层，可以填写数字按照查找层次，如下所示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组：默认拉平一层</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>]]].flat();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 四维数组：设置拉平两层</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]]].flat(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, [6, 7]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置拉平所有层</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>]]].flat(<span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组降维&quot;&gt;&lt;a href=&quot;#数组降维&quot; class=&quot;headerlink&quot; title=&quot;数组降维&quot;&gt;&lt;/a&gt;数组降维&lt;/h1&gt;&lt;h2 id=&quot;二维数组降一维数组&quot;&gt;&lt;a href=&quot;#二维数组降一维数组&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoursite.com/2019/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</id>
    <published>2019-12-18T13:00:27.000Z</published>
    <updated>2019-12-28T02:40:30.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>根据书上内容,对于数组的一些方法做了一些总结</p><h2 id="JavaScript-的数组方法参考"><a href="#JavaScript-的数组方法参考" class="headerlink" title="JavaScript 的数组方法参考"></a>JavaScript 的数组方法参考</h2><table><thead><tr><th>方 法</th><th>描 述</th></tr></thead><tbody><tr><td>concat</td><td>连接 2 个或更多数组，并返回结果</td></tr><tr><td>every</td><td>对数组中的每个元素运行给定函数，如果该函数对每个元素都返回 true，则返回 true</td></tr><tr><td>some</td><td>对数组中的每个元素运行给定函数，如果任一元素返回 true，则返回 true</td></tr><tr><td>forEach</td><td>对数组中的每个元素运行给定函数。这个方法没有返回值</td></tr><tr><td>map</td><td>对数组中的每个元素运行给定函数，返回每次函数调用的结果组成的数组</td></tr><tr><td>filter</td><td>对数组中的每个元素运行给定函数，返回该函数会返回 true 的元素组成的数组</td></tr><tr><td>join</td><td>将所有的数组元素连接成一个字符串</td></tr><tr><td>indexOf</td><td>返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1</td></tr><tr><td>lastIndexOf</td><td>返回在数组中搜索到的与给定参数相等的元素的索引里最大的值</td></tr><tr><td>reverse</td><td>颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个</td></tr><tr><td>slice</td><td>传入索引值，将数组里对应索引范围内的元素作为新数组返回</td></tr><tr><td>sort</td><td>按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数</td></tr><tr><td>toString</td><td>将数组作为字符串返回</td></tr><tr><td>valueOf</td><td>和 toString 类似，将数组作为字符串返回</td></tr></tbody></table><h3 id="迭代器函数"><a href="#迭代器函数" class="headerlink" title="迭代器函数"></a>迭代器函数</h3><p>JavaScript 内置了许多数组可用的迭代方法。我们需要一个数组和一个函数：假设数组中的值是从 1 到 15；如果数组里的元素可以被 2 整除（偶数），函数就返回 true，否则返回 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果x是2的倍数，就返回true</span></span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>];</span><br></pre></td></tr></table></figure><ol><li>用 every 方法迭代<br>every 方法会迭代数组中的每个元素，直到返回 false。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers.every(isEven);</span><br></pre></td></tr></table></figure>在这个例子里，数组 numbers 的第一个元素是 1， 它不是 2 的倍数（ 1 是奇数）， 因此 isEven函数返回 false，然后 every 执行结束。</li></ol><h2 id="ECMAScript6-和数组的新功能"><a href="#ECMAScript6-和数组的新功能" class="headerlink" title="ECMAScript6 和数组的新功能"></a>ECMAScript6 和数组的新功能</h2><p>下表列出了 ES2015 和 ES2016 新增的数组方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>@@iterator</td><td>返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对</td></tr><tr><td>copyWithin</td><td>复制数组中一系列元素到同一数组指定的起始位置</td></tr><tr><td>entries</td><td>返回包含数组所有键值对的@@iterator</td></tr><tr><td>includes</td><td>如果数组中存在某个元素则返回 true，否则返回 false。 E2016 新增</td></tr><tr><td>find</td><td>根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素</td></tr><tr><td>findIndex</td><td>根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素在数组中的索引</td></tr><tr><td>fill</td><td>用静态值填充数组</td></tr><tr><td>from</td><td>根据已有数组创建一个新数组</td></tr><tr><td>keys</td><td>返回包含数组所有索引的@@iterator</td></tr><tr><td>of</td><td>根据传入的参数创建一个新数组</td></tr><tr><td>values</td><td>返回包含数组中所有值的@@iterator</td></tr></tbody></table><h3 id="使用-iterator-对象"><a href="#使用-iterator-对象" class="headerlink" title="使用 @@iterator 对象"></a>使用 @@iterator 对象</h3><p>ES2015 还为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问。代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = numbers[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>然后，不断调用迭代器的 next 方法，就能依次得到数组中的值。 numbers 数组中有 15 个值，因此需要调用 15 次 iterator.next().value。</p><p>我们可以用下面的代码来输出 numbers 数组中的 15 个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterator = numbers[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> iterator) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组中的所有值都迭代完之后， iterator.next().value 会返回 undefined。</p><h3 id="数组的-entries、keys和values方法"><a href="#数组的-entries、keys和values方法" class="headerlink" title="数组的 entries、keys和values方法"></a>数组的 entries、keys和values方法</h3><p>entries 方法返回包含键值对的 @@iterator,使用集合、字典、散列表等数据结构时，能够取出键值对是很有用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aEntries = numbers.entries(); <span class="comment">// 得到键值对的迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries.next().value); <span class="comment">// [0, 1] - 位置 0 的值为 1</span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries.next().value); <span class="comment">// [1, 2] - 位置 1 的值为 2</span></span><br><span class="line"><span class="built_in">console</span>.log(aEntries.next().value); <span class="comment">// [2, 3] - 位置 2 的值为 3</span></span><br></pre></td></tr></table></figure><p>keys 方法返回包含数组索引的 @@iterator,values 方法返回的 @@iterator 则包含数组的值</p><h2 id="fafa"><a href="#fafa" class="headerlink" title="fafa"></a>fafa</h2><p><strong>使用数组实现斐波拉契数列</strong><br>求斐波拉契数列的前 20 个数。已知斐波那契数列中的前两项是 1，从第三项开始，每一项都等于前两项之和。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fibonacci = []</span><br><span class="line">fibonacci[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">fibonacci[<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">3</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">  fibonacci[i]=fibonacci[i<span class="number">-1</span>]+fibonacci[i<span class="number">-2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;fibonacci.length;i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fibonacci[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;根据书上内容,对于数组的一些方法做了一些总结&lt;/p&gt;
&lt;h2 id=&quot;JavaScript-的数组方法参考&quot;&gt;&lt;a href=&quot;#JavaS
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>ES6复习(二)</title>
    <link href="http://yoursite.com/2019/12/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%A4%8D%E4%B9%A0%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/12/15/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%A4%8D%E4%B9%A0%E4%BA%8C/</id>
    <published>2019-12-15T10:20:15.000Z</published>
    <updated>2019-12-19T02:09:17.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6复习"><a href="#ES6复习" class="headerlink" title="ES6复习"></a>ES6复习</h1><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 函数是 ES6 提供的一种异步解决方案，语法行为与传统的函数不同。</p><p>语法上，可以将 Generator 函数理解成一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说它也是一个遍历器对象生成函数。返回遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator函数是一个普通的函数，有两个特征需要注意，</p><ol><li><code>function</code> 关键字与函数之间有一个星号</li><li>函数内部使用 <code>yield</code> 表达式，定义不同的内部状态</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><p>其中调用 Generator 函数后，函数并不执行，返回的也不是函数运行的结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。<br>所以是对返回的遍历器对象进行操作，所以要调用遍历器对象的 <code>next</code> 方法。Generator 函数是分段执行的，<code>yield</code> 表达式是暂停执行的标记，而 <code>next</code> 方法可以恢复执行。</p><p><code>for...of</code> 可以自动遍历 Generator 函数运行时生成的 Itearator 对象，且此时不再需要 <code>next</code> 方法。</p><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 函数就是 Generator 函数的语法糖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的函数gen可以写成async函数，就是下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p><p>具体文章还是看阮老师的 ES6标准入门，讲的比较清楚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6复习&quot;&gt;&lt;a href=&quot;#ES6复习&quot; class=&quot;headerlink&quot; title=&quot;ES6复习&quot;&gt;&lt;/a&gt;ES6复习&lt;/h1&gt;&lt;h2 id=&quot;Generator&quot;&gt;&lt;a href=&quot;#Generator&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="复习笔记" scheme="http://yoursite.com/tags/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ES6复习(一)</title>
    <link href="http://yoursite.com/2019/12/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/12/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%A4%8D%E4%B9%A0/</id>
    <published>2019-12-14T08:10:14.000Z</published>
    <updated>2019-12-18T14:03:06.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6复习（Promise、Iterator）"><a href="#ES6复习（Promise、Iterator）" class="headerlink" title="ES6复习（Promise、Iterator）"></a>ES6复习（Promise、Iterator）</h1><p>参照阮老师的 ECMAScript 标准入门</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Promise 是一个对象，可以将异步操作以同步操作的流程表达出来，解决<em>回调地狱</em> 的层层嵌套。</p><p>其中包含三个状态：</p><ul><li>pending（进行中）</li><li>fulfilled（已成功）</li><li>rejected（已失败）</li></ul><p><code>Promise</code> 的状态改变只有两种：pending =&gt; fulfilled，pending =&gt; rejected。其中状态一旦改变，状态就凝固了，不会再改变，会一直保持这个结果，这时就称为 resolved（已定型）。</p><p>缺点：第一是无法取消，一旦新建就会立即执行，无法中途取消。第二是不设置回调函数会抛出错误。第三是当处于 <code>pending</code> 状态时，无法知道目前到哪一个阶段。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中函数里有两个 <code>resolve</code> 和 <code>reject</code> 函数，由 JavaScript 引擎提供。</p><p><code>resolve</code> 的作用是将 <code>Promise</code> 的状态从 pending =&gt; fulfilled，在异步操作成功后调用，并将异步操作的结果作为参数返回出去。<code>reject</code> 的作用是将 <code>Promise</code> 的状态从 pending =&gt; rejected，在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p><h2 id="Iterator（遍历器）"><a href="#Iterator（遍历器）" class="headerlink" title="Iterator（遍历器）"></a>Iterator（遍历器）</h2><p>Iterator 是一种统一接口，为不同数据结构提供统一的访问机制。任何数据结构只要部署了 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构中的所有成员。Iterator 遍历对象是一个指针对象，其中包含 next 方法，指向下一个数据结构的成员。返回包含 value 和 done 两种属性的对象， value 是当前成员的值，done 是一个布尔值，表示遍历是否结束。</p><p>JavaScript表示 “集合” 的数据结构有：</p><ul><li>数组</li><li>对象</li><li>ES6 新增的 Set、Map</li></ul><p>Iterator 的作用</p><ol><li>为各种数据结构提供统一的、简单的访问接口</li><li>使得数据结构的成员能够按照某种次序排列</li><li>ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费</li></ol><p>ES6 的一些数据原生具备 Iterator 接口（比如数组），即不用任何处理就可以被 for…of 处理，因为这些数据结构原生部署了 <code>Symbol.iterator</code>，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在  <code>Symbol.iterator</code> 属性上面部署，这样才会被<code>for...of</code>循环遍历。对象之所以没有默认部署 Iterator 接口，是因为对象中的数据是非线性的。</p><p>原生具备 Iterator 接口的数据结构如下：</p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6复习（Promise、Iterator）&quot;&gt;&lt;a href=&quot;#ES6复习（Promise、Iterator）&quot; class=&quot;headerlink&quot; title=&quot;ES6复习（Promise、Iterator）&quot;&gt;&lt;/a&gt;ES6复习（Promise、Ite
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="复习笔记" scheme="http://yoursite.com/tags/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hexo写作命令大全</title>
    <link href="http://yoursite.com/2019/12/12/Hexo%E5%86%99%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2019/12/12/Hexo%E5%86%99%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2019-12-12T08:27:54.000Z</published>
    <updated>2019-12-12T12:01:09.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo写作命令大全"><a href="#Hexo写作命令大全" class="headerlink" title="Hexo写作命令大全"></a>Hexo写作命令大全</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一名前端程序员当然要有自己的博客存，以前用 markdown 写一些自己的学习笔记，但是写完之后都不会去回顾，因为存放在电脑上回顾起来比较麻烦。所以最近在着手自己的博客项目，但是对于 hexo 的一些写作命令并不是很熟悉，所以在网上找到了一些牛人前辈写的博客，下面开始练练手吧。</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>在博客目录下执行如下命令新建一篇文章</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new [layout] &lt;title&gt;</span></span><br></pre></td></tr></table></figure><p>如果未指定文章的布局（layout），则默认使用 <code>post</code> 布局，生成的文档存放于 <code>source\_posts\</code> 目录下，打开后使用 Markdown 语法进行写作，保存后刷新浏览器即可看到文章。</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>布局可以理解为新建文档时的一个模块，基于布局生成的文档将会继承布局的样式。</p><p>Hexo 默认有三种布局：<code>post</code>、 <code>page</code> 和 <code>draft</code>，用户可以在 <code>scaffolds</code> 目录下新建文档来自定义布局格式，还可以修改站点配置文件中的 <code>default_layout</code>参数来指定生成文档时的默认布局。</p><p><img src="http://q2e38owot.bkt.clouddn.com/image/study/hexo1.png" alt="image-20191212151710263"></p><h3 id="文章（post）"><a href="#文章（post）" class="headerlink" title="文章（post）"></a>文章（post）</h3><p>基于 <code>post</code> 布局生成的文档存在于 <code>source\_posts\</code> 目录下，该目录下的文档会作为博客正文显示在网站中。</p><h3 id="页面（page）"><a href="#页面（page）" class="headerlink" title="页面（page）"></a>页面（page）</h3><p><code>page</code> 布局用于生成类似 <strong>首页</strong> 和 <strong>归档</strong> 这样的页面。</p><h3 id="草稿（draft）"><a href="#草稿（draft）" class="headerlink" title="草稿（draft）"></a>草稿（draft）</h3><p><code>draft</code> 布局用于创建草稿，生成的文档存在于 source_drafts\ 目录中，默认配置下将不会把该目录下的文档渲染到网站中。</p><p>通过以下命令将草稿发布为正式文章：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><p><code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code> #新建文章<br><code>hexo p</code> == <code>hexo publish</code><br><code>hexo g</code> == <code>hexo generate</code>#生成<br><code>hexo s</code> == <code>hexo server</code> #启动服务预览<br><code>hexo d</code> == <code>hexo deploy</code>#部署</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p><code>hexo server</code> #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br><code>hexo server -s</code> #静态模式<br><code>hexo server -p 5000</code> #更改端口<br><code>hexo server -i 192.168.1.1</code> #自定义 IP</p><p><code>hexo clean</code> #清除缓存 网页正常情况下可以忽略此条命令<br><code>hexo g</code> #生成静态网页<br><code>hexo d</code> #开始部署</p><hr><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>Markdown 并不会保存插入的图片资源本身，只是记录了获取资源的链接。<br>在 Markdown 中插入一张图片的步骤：</p><ol><li>将图片上床到图床上</li><li>获取图片的连接</li><li>插入到 Markdown 中</li></ol><blockquote><p>引用连接:<br><a href="http://yearito.cn/posts/hexo-writing-skills.html" target="_blank" rel="noopener">http://yearito.cn/posts/hexo-writing-skills.html</a><br><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002632530</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo写作命令大全&quot;&gt;&lt;a href=&quot;#Hexo写作命令大全&quot; class=&quot;headerlink&quot; title=&quot;Hexo写作命令大全&quot;&gt;&lt;/a&gt;Hexo写作命令大全&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo常用命令" scheme="http://yoursite.com/tags/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入了解JavaScript</title>
    <link href="http://yoursite.com/2019/11/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3javascript/"/>
    <id>http://yoursite.com/2019/11/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3javascript/</id>
    <published>2019-11-24T11:28:00.000Z</published>
    <updated>2019-12-12T06:44:05.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS的参数传递"><a href="#JS的参数传递" class="headerlink" title="JS的参数传递"></a>JS的参数传递</h1><h2 id="参数到底如何传递"><a href="#参数到底如何传递" class="headerlink" title="参数到底如何传递"></a>参数到底如何传递</h2><blockquote><p>ECMAScript 中所有函数的参数都是按值传递的</p></blockquote><p>普通类型是按值传递，拷贝原值，引用类型是按共享传递拷贝了引用，都是拷贝值，所以都是按值传递</p><p>这个值如果是简单类型，那么就是其本身。如果是引用类型也就是对象传递就是指向这个对象的地址。故我们可以认为参数全部都是值传递，具体例子：</p><h3 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    n: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    data = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.n) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>传递引用类型传递的是指针。</p><p><img src="https://user-images.githubusercontent.com/15126694/30241403-3fafc13e-95b5-11e7-99f5-1f092c78c48a.png" alt="image"></p><p> 首先执行<code>var obj = {n: 1};</code>，可以看作在栈的011地址中存入了一个指向<code>{n:1}</code>堆的指针*p </p><p><img src="https://camo.githubusercontent.com/e97db40b68c6739348c68215b893e99aa6b044c5/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f392f3435333865666535373066656465313233323131653465313334336434326265" alt="img"></p><p> 接下来为声明<code>function foo</code>此时会创建函数执行上下文，产生一个变量对象，其中声明了形参data，由于函数没有执行，当前值为undefined。我们记data地址为022。关于更多变量对象的知识可以参考冴羽老师的这篇<a href="https://github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">JavaScript深入之变量对象</a>，本文不深入研究关于AO相关，你只需要知道在声明这个函数的时候里面的形参已经被创建出来了。 </p><p><img src="https://camo.githubusercontent.com/74cfb299ca39361602d9887579815203274faa97/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f392f6339343533643630346530653536383466646234396363623362363733323733" alt="img"></p><p> 执行<code>foo(obj)</code>其中会进行参数传递，其中将obj中存储的*p拷贝给处在022地址的data，那么此时它们就指向了同一个对象，如果某一个变量更改了n的值，另一个变量中n的值也会更改，因为其中保存的是指针。 </p><p><img src="https://camo.githubusercontent.com/35dc851e4ebcff7f39b5c3c0c646c49c97927473/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f392f3932313831323661303734336639646631356566333061366430366663336636" alt="img"></p><p> 进入函数内部，顺序执行<code>data = 2;</code>此时002地址存储了基本类型值，则直接存储在栈中，从而与堆中的{n:1}失去了联系。从而打印<code>console.log(data) // 2</code>，最后发现初始开辟的{n:1}对象没有过更改，故而<code>console.log(obj.n) // 1</code>仍然打印1。 </p><h3 id="第二个例子"><a href="#第二个例子" class="headerlink" title="第二个例子"></a>第二个例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.n); <span class="comment">//1</span></span><br><span class="line">  obj.n=<span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.n) <span class="comment">//2</span></span><br><span class="line">&#125;)(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.n) <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/d68b740a7853af8053452f3951e355813c43702c/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f31302f3663393932636235653461306239363965353436343531303631306432643032" alt="img"></p><p> 声明函数，虽然同为obj变量名，但是形参obj为AO中的属性，不会与全局造成覆盖，其拥有新的地址记作022，在未执行前其值为undefined。 </p><p> 函数立即执行，此时将全局obj赋值给形参obj，我们忽略这个重复命名的问题，其实就是将011中的 指针*p拷贝了一份给了022。同时执行第一个<code>console.log(obj.n)</code>结果即为1。 </p><p><img src="https://camo.githubusercontent.com/14e00a0a7f9ab9a3ebf2a9e34cc67076052cee9e/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f31302f3762616537666632636134393132656530356139663139383762653434656136" alt="img"></p><p> 执行<code>obj.n=3</code>，此时为函数的形参即022中的obj来改变了对象内n的值。 </p><p><img src="https://camo.githubusercontent.com/2e191b1b44a608063fc851841c053aeb42b5b101/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031372f392f31302f3364646364386139666562346364336636663030393033613766656332376264" alt="img"></p><p><strong>最关键的一步</strong>：<code>var obj = {n:2};</code>由于对象命名的关系可能很多童鞋就会有点懵，但依然按照同样的方式来分析即可，由于使用了var那么就是新声明一个对象，从而会在栈中压入新的地址记作033，其中存入了新的指针指向了新的对象{n:2}。从而之后打印的<code>console.log(obj.n)</code>结果则应是新开辟的对象中的n的值。</p><p>最后打印<code>console.log(obj.n) //3</code>很显然，全局的对象有过一次更改其值为3。</p><hr><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是指程序源代码中定义变量的区域。</p><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><h2 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h2><p>JavaScript 采用的词法作用域，也就是静态作用域，函数的作用域在函数定义的时候就决定了。</p><p>而词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定。</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 1</span></span><br></pre></td></tr></table></figure><p> 主要区别：<strong>词法作用域是在写代码或者定义时确定的，而动态作用域是在运行时确定的（this也是！）。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用</strong>。 </p><hr><h1 id="Js执行上下文栈"><a href="#Js执行上下文栈" class="headerlink" title="Js执行上下文栈"></a>Js执行上下文栈</h1><blockquote><p> <a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/4</a> </p></blockquote><h2 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h2><p>JavaScript 的可执行代码的类型有三种：</p><ul><li><p>全局代码</p></li><li><p>函数代码</p></li><li><p>eval代码</p><p>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context)”。 </p></li></ul><p>当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>我们可以把函数的执行过程看做一个执行上下文栈，当函数被创建时就会将函数推入执行上下文栈中，当函数执行完毕后，就将该函数从栈中弹出。</p><hr><h1 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h1><p>每个执行上下文，都有三个重要属性：</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>变量对象是与执行上下文相关的数据作用域，存储了上下文定义的变量和函数声明。</p><p>不同上下文的变量对象有所不同，可分为 <strong>全局上下文</strong> 下的变量对象和 <strong>函数上下文</strong> 下的变量对象</p><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>全局对象：是预定义对象，在顶层 JavaScript 中，可以通过 this 引用全局变量，全局对象时作用域链的头，意味着在顶层 JavaScript 中声明的所有变量都可以成为全局对象的属性。</p><p>1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>2.全局对象是由 Object 构造函数实例化的一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure><p>3.预定义了一堆，嗯，一大堆函数和属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 都能生效</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.Math.random());</span><br></pre></td></tr></table></figure><p>4.作为全局变量的宿主。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br></pre></td></tr></table></figure><p>5.客户端 JavaScript 中，全局对象有 window 属性指向自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.window.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span><br></pre></td></tr></table></figure><p>全局上下文中的变量对象就是全局对象！</p><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p> 在函数上下文中，我们活动对象（activation object，AO）来表示变量对象。</p><p>活动对象不可以在 JavaScript 环境中访问，只有当进入一个执行上下文中，这个执行上下文的变量对象才会被激活。而只有被激活的变量对象，也就是活动对象上的属性才能被访问。</p><p>活动对象是进入函数上下文被创建的，它通过函数的 arguments 属性初始化， arguments 属性值是 Arguments 对象。 </p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，</p><p>变量对象会包括：</p><ol><li>函数的所有形参 (如果是函数上下文)<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul></li><li>变量声明<ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ol><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">  var b = 2;</span><br><span class="line">  function c() &#123;&#125;</span><br><span class="line">  var d = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = 3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(1);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p><p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression &quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 Arguments 对象</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</li><li>在代码执行阶段，会再次修改变量对象的属性值</li></ol><p>分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>打印的是函数，而不是 undefined。</p><p>因为在进入函数上下文时，首先会处理函数声明，其次处理变量声明，如果变量声明名称的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p><hr><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>当查找变量的时候，会先从当前上下文的变量对象中进行查找，如果没有，会在父级中的执行上下文的变量对象中查找，还是没有，就一直查找上一级上下文中的变量对象。直到全局上下文中的变量对象。这种由多个执行上下文的对象构成的链就是作用域链。</p><p>用函数的创建和激活理解作用域链：</p><h2 id="函数的创建"><a href="#函数的创建" class="headerlink" title="函数的创建"></a>函数的创建</h2><p>函数作用域在函数被定义时就决定了。</p><p>这是由于函数内部有一个内部属性 <code>[[scope]]</code>，当函数创建的时候，就会保存所有父变量到其中，可以理解 <code>[scope]</code> 就是所有父变量的层级链。但是注意：<code>[[scope]]</code> 并不代表完整的作用域链。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数被激活时，进入执行上下文，创建 VO/AO 后，就会将活动对象添加到作用域链的前端。</p><p>这时候执行的作用域链我们命名为 Scope：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[scope]])</span><br></pre></td></tr></table></figure><p>至此作用域链创建完毕。</p><h1 id="进行梳理"><a href="#进行梳理" class="headerlink" title="进行梳理"></a>进行梳理</h1><p>结合下面例子，梳理前面讲过的执行上下文栈和变量对象，总结一下函数上下文中的作用域链和变量对象的创建过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope2 = <span class="string">'local scope'</span>;</span><br><span class="line">    <span class="keyword">return</span> scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>执行过程如下：</p><p>1.checkscope 函数被创建，保存作用域链到内部属性[[scope]]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: <span class="literal">undefined</span></span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: &apos;local scope&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>执行函数，才会创建函数的执行上下文</p><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><blockquote><p> <a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/7</a> </p></blockquote><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><blockquote><p> <a href="https://github.com/mqyqingfeng/Blog/issues/8" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/8</a> </p></blockquote><h1 id="闭包的问题"><a href="#闭包的问题" class="headerlink" title="闭包的问题"></a>闭包的问题</h1><blockquote><p> <a href="https://github.com/mqyqingfeng/Blog/issues/9" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/9</a> </p></blockquote><p>个人理解：闭包是一个有权访问另一个函数里的变量及方法的函数。</p><p>MND 对闭包的定义：</p><blockquote><p>闭包就是有权访问自由变量的函数。</p><p>自由变量是在函数中使用的，既不是函数的参数也不是函数的局部变量的变量。</p><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>举一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>函数 foo 可以访问变量 a，但是变量 a 既不是 foo 函数的参数，也不是局部变量，所以 a 就是自由变量。</p><p>所有的变量和方法都通过作用域保存起来了，即使外面的函数执行完毕被弹出执行上下文栈，内部函数也是可以通过作用域链找到相应的变量和方法。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS的参数传递&quot;&gt;&lt;a href=&quot;#JS的参数传递&quot; class=&quot;headerlink&quot; title=&quot;JS的参数传递&quot;&gt;&lt;/a&gt;JS的参数传递&lt;/h1&gt;&lt;h2 id=&quot;参数到底如何传递&quot;&gt;&lt;a href=&quot;#参数到底如何传递&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>第三次周总结</title>
    <link href="http://yoursite.com/2019/11/10/%E5%91%A8%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/10/%E5%91%A8%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%91%A8%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-10T12:28:00.000Z</published>
    <updated>2019-12-10T12:46:31.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h2><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，就是对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p><h3 id="Prototype-引用的用处"><a href="#Prototype-引用的用处" class="headerlink" title="[[Prototype]] 引用的用处"></a>[[Prototype]] 引用的用处</h3><p>当你试图引用对象的属性时会触发 [[Get]] 操作，比如 对象名.属性名。第一步是检查对象是否有这个 属性，如果有就是用它。如果没有，就需要使用对象的 [[Prototype]] 链了。</p><h3 id="Object-create-…-的原理"><a href="#Object-create-…-的原理" class="headerlink" title="Object.create(…)的原理"></a>Object.create(…)的原理</h3><p>创建一个对象并把这个对象的 [[Prototype]] 关联到指定的对象</p><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>因为通过各种语法进行属性的查找时，都会查找 [[Prototype]] 链，直到找到属性或者查找完整条原型链。</p><p>所以哪里是 [[Prototype]] 的尽头呢？</p><p>所有普通的 [[Prototype]]链最终都会指向内置的 Object.Prototype。由于所有普通对象都源于这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。</p><h2 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h2><p>一个对象关于另一个对象</p><p>JavaScript和面向类的语言不同，JavaScript只有对象。它是可以不通过类，直接创建对象的语言。</p><h3 id="“类”函数"><a href="#“类”函数" class="headerlink" title="“类”函数"></a>“类”函数</h3><p>Js一直是在模仿类，这种”类似类”的行为利用了函数的一种特殊特性：所有的函数默认都会拥有一个名为 property 的公有并且不可枚举的属性，它指向另一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype</span><br></pre></td></tr></table></figure><p>这个对象通常被称为 Foo 的原型，因为通过名为 Foo.prototype 的属性引用来访问它。“被贴上 Foo.prototype 标签的对象”。</p><p>面向类语言，类是可以被复制（实例化）多次，但是在 JavaScript中，并没有类似的复制机制。不能创建一个类的多个实例，只能创建多个对象，它们 [[property]] <strong>关联</strong>的是同一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === Foo.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>new Foo() 会生成一个新对象（我们称之为a)，这个新对象的内部链接 [[Prototype]] 关联的是 Foo.prototype 对象。最后我们得到的两个对象，它们之间互相关联。我们并没有初始化一个类，实际上我们并没有从“类”中复制任何行为到另一个对象中，只是让两个对象互相关联。</p><p>new Foo()只是间接完成了我们的目标：一个关联到其他对象的新对象。</p><h4 id="关于名称"><a href="#关于名称" class="headerlink" title="关于名称"></a>关于名称</h4><p>在JavaScript中，我们并不会将一个对象（“类”）复制到另一个对象（“实例”），只是将它们关联起来。[[Prototype]] 机制如下图所示：</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191107103923655.png" alt="image-20191107103923655"></p><p>这个机制被称为<strong>原型继承</strong></p><p>对象（实例）a1 到 Foo.prototype 的委托关系，还展示出 Bar.prototype 到 Foo.prototype 的委托关系，而后者和类继承很类似，只有箭头的方向不同。图中由下到上的箭头表明这是委托关联，不是复制操作。</p><h3 id="“构造函数”"><a href="#“构造函数”" class="headerlink" title="“构造函数”"></a>“构造函数”</h3><p>到底是什么原因让我们认为 Foo 是一个 “类” 呢？</p><p>一个原因是使用了关键字 new ，在面向类的语言中构造类函数实例时会用到它。另一个原因是，看起来我们执行了类的构造函数方法，Foo()的调用方式很想初始化类时类构造函数的调用方式。</p><p>还有另一个原因:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.constructor === Foo;  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.constructor === Foo;  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>Foo.prototype 默认（在代码第一行声明中）有一个公有并且不可枚举的属性 .constructor，这个属性引用的是对象关联的函数（本例中是 Foo）。此外，可以看到通过 “构造函数” 调用 new Foo() 创建的对象也有一个 .constructor 属性，指向 “创建这个对象的函数” 。</p><h4 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h4><p>上面 Foo 和你程序中的其他函数没有任何区别。函数本身并不是构造函数，然而，当你在普通函数调用前面加上 new 关键字之后，就会把这个函数调用变成一个 “构造函数调用”。实际上，new 会劫持所有普通函数并用构造对象的形式来调用它。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NothingSpecial</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Don't mind me!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> NothingSpecial();</span><br><span class="line"><span class="comment">//  "Don't mind me!"</span></span><br><span class="line"></span><br><span class="line">a; <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>NothingSpecial 只是一个普通的函数，但是使用 new 调用时，它就会构造一个对象并赋值给 a，这看起来像是 new 的一个副作用（无论如何都会构造一个对象）。这个调用是一个构造函数调用，但是 NothingSpecial 本身并不是一个构造函数。</p><p>在 JavaScript 中对于 “构造函数” 最准确的解释是，所有带 new 的函数调用。函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成 “构造函数调用”。</p><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>参见 p151 页</p><p>JavaScript中的.constructor</p><hr><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>原型风格：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.myName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name, label</span>) </span>&#123;</span><br><span class="line">    Foo.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.label = label</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了一个新的 Bar.prototype 对象并关联到 Foo.prototype</span></span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，现在没有 Bar.prototype.constructor</span></span><br><span class="line"><span class="comment">// 如果你需要这个属性的话可能需要手动修复一下它</span></span><br><span class="line"></span><br><span class="line">Bar.prototype.myLabel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.label</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">"a"</span>, <span class="string">"obj a"</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Foo(<span class="string">"b"</span>, <span class="string">"obj b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.myName()); <span class="comment">//a</span></span><br><span class="line"><span class="built_in">console</span>.log(a.myLabel()); <span class="comment">//obj a</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b.myName()); <span class="comment">//b</span></span><br><span class="line"><span class="comment">//console.log(b.myLabel()); //b.myLabel is not a function</span></span><br></pre></td></tr></table></figure><p>调用 Object.create(..) 会凭空创建一个”新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中 Foo.prototype）。换句话说：“创建一个新的 Bar.prototype 对象并把它关联到 Foo.prototype”。</p><p>声明 function Bar(){..} 时，和其他函数一样，Bar 会有一个 .prototype 关联到默认的对象，但是这个对象并不是我们想要的 Foo.prototype。因此我们创建一个新对象并把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉。</p><p>ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法修改关联。<br>Object.setPrototypeOf(Bar.prototype，Foo.prototype)</p><h2 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h2><p>[[Prototype]] 机制是存在于对象的一个内部链接，它会引用其他对象。</p><p>通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的连接被称为“原型链”。</p><h2 id="原型链图："><a href="#原型链图：" class="headerlink" title="原型链图："></a>原型链图：</h2><img src="https://zacharykwan.com/uploads/prototype/prototype.jpg" alt="“复杂的原型链图”的图片搜索结果" style="zoom: 50%;" /><h1 id="浏览器与Node的事件循环"><a href="#浏览器与Node的事件循环" class="headerlink" title="浏览器与Node的事件循环"></a>浏览器与Node的事件循环</h1><h2 id="浏览器与Node的事件循环-Event-Loop-有何区别"><a href="#浏览器与Node的事件循环-Event-Loop-有何区别" class="headerlink" title="浏览器与Node的事件循环(Event Loop)有何区别?"></a>浏览器与Node的事件循环(Event Loop)有何区别?</h2><blockquote><p> <a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218" target="_blank" rel="noopener">https://juejin.im/post/5c337ae06fb9a049bc4cd218</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h1&gt;&lt;h2 id=&quot;Prototype&quot;&gt;&lt;a href=&quot;#Prototype&quot; class=&quot;headerlink&quot; title=&quot;[[Proto
      
    
    </summary>
    
    
      <category term="周总结" scheme="http://yoursite.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="周总结" scheme="http://yoursite.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>第二次周总结</title>
    <link href="http://yoursite.com/2019/11/03/%E5%91%A8%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/03/%E5%91%A8%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%91%A8%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-03T11:00:00.000Z</published>
    <updated>2019-12-10T12:27:22.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS的执行机制"><a href="#JS的执行机制" class="headerlink" title="JS的执行机制"></a>JS的执行机制</h1><h2 id="关于JavaScript"><a href="#关于JavaScript" class="headerlink" title="关于JavaScript"></a>关于JavaScript</h2><p>JavaScript是一门单线程语言，所有一切 JavaScript 多线程都是用但线程模拟出来的</p><h2 id="JavaScript事件循环"><a href="#JavaScript事件循环" class="headerlink" title="JavaScript事件循环"></a>JavaScript事件循环</h2><ul><li>同步任务进入主线程</li><li>异步任务进入Event Table</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>主线程执行完后，发现执行栈为空，就会去Event Queue中去取相应的函数。</p><p>事件循环的顺序，决定 js 代码的执行顺序。进入整体代码（宏任务）后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有微任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'console'</span>);复制代码</span><br></pre></td></tr></table></figure><ul><li>这段代码作为宏任务，进入主线程。</li><li>先遇到<code>setTimeout</code>，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li><li>接下来遇到了<code>Promise</code>，<code>new Promise</code>立即执行，<code>then</code>函数分发到微任务Event Queue。</li><li>遇到<code>console.log()</code>，立即执行。</li><li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了<code>then</code>在微任务Event Queue里面，执行。</li><li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中<code>setTimeout</code>对应的回调函数，立即执行。</li><li>结束。</li></ul><h2 id="宏任务、微任务与Event-Loop"><a href="#宏任务、微任务与Event-Loop" class="headerlink" title="宏任务、微任务与Event Loop"></a>宏任务、微任务与Event Loop</h2><p>JavaScript中执行的过程可以看成宏任务和微任务的执行，由于单线程的工作原理，js会一步一步的执行代码，这是第一个整体代码（宏任务），也就是主线程，如果遇到一些回调函数就会注册分发到宏任务 Event Queue（任务队列）中，继续执行，当遇到微任务时，也分发到任务队列中，待第一个宏任务执行完毕后，在执行此次的微任务，然后通过 Event Loop 执行下一个宏任务（刚刚在第一次宏任务中注册的回调函数），以此类推。直到循环结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">12</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS的执行机制&quot;&gt;&lt;a href=&quot;#JS的执行机制&quot; class=&quot;headerlink&quot; title=&quot;JS的执行机制&quot;&gt;&lt;/a&gt;JS的执行机制&lt;/h1&gt;&lt;h2 id=&quot;关于JavaScript&quot;&gt;&lt;a href=&quot;#关于JavaScript&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="周总结" scheme="http://yoursite.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="周总结" scheme="http://yoursite.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>第一次周总结</title>
    <link href="http://yoursite.com/2019/10/27/%E5%91%A8%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/10/27/%E5%91%A8%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%91%A8%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-27T11:00:00.000Z</published>
    <updated>2019-12-10T12:20:34.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS对象序列化详解"><a href="#JS对象序列化详解" class="headerlink" title="JS对象序列化详解"></a>JS对象序列化详解</h2><h3 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h3><p>对象序列化是将对象状态转化成一个字符串</p><p>序列化是将对象的状态信息转换成一个可以存储和传输的形式的过程</p><h3 id="为什么会有对象序列化"><a href="#为什么会有对象序列化" class="headerlink" title="为什么会有对象序列化"></a>为什么会有对象序列化</h3><p>简单的说就是方便对象<strong>传输和存储</strong></p><blockquote><p>当这句代码运行时，对象obj的内容会存储在一块内存中，而obj本身存储的只是这块内存的地址的映射而已。简单的说，对象obj就是我们的程序在电脑通电时在内存中维护的一种东西，如果我们程序停止了或者电脑断电了，对象obj将不复存在。那么如何把对象obj的内容保存在磁盘上呢（也就是说在没电时继续保留着）？这时就需要把对象obj序列化，也就是说把obj的内容转换成一个字符串的形式，然后再保存在磁盘上。另外，我们又怎么通过HTTP协议把对象obj的内容发送到客户端呢？没错，还是需要先把对象obj序列化，然后客户端根据接收到的字符串再反序列化（也就是将字符串还原为对象）解析出相应的对象。</p></blockquote><h3 id="JS中的对象序列化"><a href="#JS中的对象序列化" class="headerlink" title="JS中的对象序列化"></a>JS中的对象序列化</h3><p> JSON 的全称是”JavaScript Object Notation“——JavaScript对象表示法。ECMAScript 5中提供了内置函数JSON.stringify()和JSON.parse()用来序列化和还原JavaScript对象。<br> JSON是一种语法，用来序列化字符串，数值，数组，对象，布尔值和null</p><hr><h2 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h2><blockquote><p>你不知道的js上</p></blockquote><h3 id="为什么要用this"><a href="#为什么要用this" class="headerlink" title="为什么要用this"></a>为什么要用this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">"Hello,I'm "</span> + identify.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(greeting)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me =&#123;</span><br><span class="line">  name:<span class="string">'Kele'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you =&#123;</span><br><span class="line">  name:<span class="string">'Reader'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify.call(me)</span><br><span class="line">identify.call(you)</span><br><span class="line"></span><br><span class="line">speak.call(me)</span><br><span class="line">speak.call(you)</span><br></pre></td></tr></table></figure><p>在不同的上下文对象中，重复使用函数的情况下，使用this就不用针对每个对象编写不同版本的函数，如上面代码如果不使用this，则需显示的传入一个上下文对象。</p><h3 id="对this常见的两种误解"><a href="#对this常见的两种误解" class="headerlink" title="对this常见的两种误解"></a>对this常见的两种误解</h3><ol><li><p>指向自身<br>从函数对象内部引用它自身 ，只使用this是不够的。<br>一般来说需通过一个指向函数对象的此法标识符（变量）来引用它:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>)</span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo:"</span>+num)</span><br><span class="line">  <span class="comment">// 记录foo被调用的次数,foo代替this来引用函数对象</span></span><br><span class="line">  foo.count++</span><br><span class="line">&#125;</span><br><span class="line">foo.count=<span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;<span class="number">5</span>)&#123;</span><br><span class="line">    foo(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo被调用几次</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.count);</span><br></pre></td></tr></table></figure><p>回避了this问题，完全依赖于变量foo的词法作用域</p><p>另一种方法是强制this指向foo函数对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo:"</span>+num)</span><br><span class="line">  <span class="comment">// 记录foo被调用的次数</span></span><br><span class="line">  <span class="keyword">this</span>.count++</span><br><span class="line">&#125;</span><br><span class="line">foo.count=<span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&gt;<span class="number">5</span>)&#123;</span><br><span class="line">    foo.call(foo,i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo被调用几次</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.count);</span><br></pre></td></tr></table></figure></li><li><p>它的作用域</p></li></ol><p><strong>总结</strong>：this是在运行时绑定的而不是在编写时绑定，它的上下文取决于函数调用时的条件。this实际是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里调用。</p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>理解调用位置分析调用栈，调用位置就在当前执行的函数的前一个调用中</p><p>四条绑定规则：</p><ul><li>默认调用</li><li>隐式调用</li><li>显示调用<ul><li>call（）和apply（）方法</li></ul></li><li>new绑定<ul><li>首先理解new的机制和面向类的语言完全不同，js中的构造函数只是一些使用new操作符时被调用的函数。并不属于某个类，也不会实例一个类，只是一个普通函数</li></ul></li></ul><h3 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h3><p>判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序判断：</p><ol><li>函数是否在 new 中调用？如果是的话 this 绑定的是新创建的对象</li><li>函数是否通过call、apply或者硬绑定？如果是，this 绑定的是指定的对象</li><li>函数是否在某个上下文对象中调用？this绑定的是那个上下文对象</li><li>如果都不是，使用默认绑定</li></ol><h3 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h3><p>ES6中有一种无法使用这些规则的特殊函数类型：箭头函数</p><p>箭头函数的绑定，无法被修改常用于回调函数</p><hr><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>对象可以通过两种方式定义：声明（文字）形式和构造形式</p><p>两种定义出来的对象是一样的<strong>区别</strong>在于：声明方式可以在文字声明中添加多个键值对，但是构造形式只能逐个添加属性</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对象是 JavaScript 的基础。有六种主要类型（语言类型）</p><ul><li>string</li><li>number</li><li>boolean</li><li>object</li><li>null</li><li>undefined</li></ul><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>JavaScript 中还有一些对象子类型，通常被称为内置对象。</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error  </li></ul><p>思考下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"I'm a string"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length) <span class="comment">//13</span></span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">3</span>)) <span class="comment">//m</span></span><br></pre></td></tr></table></figure><p>我们可以直接在字符串字面量上访问属性或者方法，是因为引擎自动把字面量转换成 String 对象，所以才可以访问属性和方法。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，我们称之为属性。</p><p>这些值存储方式多钟多样，一般并不会存储在对象容器内部。存储在内部的是这些属性的名称，它们就像指针（引用）一样，指向这些值真正的存储位置。</p><p>.属性访问，[]键访问</p><h4 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h4><p>在JavaScript中，函数并不是方法，函数和方法在JavaScript中是可以互换的。</p><p>即使在对象的文字形式中声明一个函数表达式，这个函数也不会属于这个对象，他们只是对于相同函数对象的多个引用。</p><h4 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h4><p>ES5后，所有属性都具备了属性描述符，属性的特性可以通过属性描述符来控制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject,<span class="string">"a"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(myObject,<span class="string">"a"</span>));</span><br><span class="line">&#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,   <span class="comment">//可写</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,   <span class="comment">//可枚举</span></span><br><span class="line">    configurable: <span class="literal">true</span>  <span class="comment">//可配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，可以使用Object.preventExtensions(…)，Object.seal(…)，Object.freeze(…) 来设置对象（及其属性）的不可变性级别。</p><p>在创建普通属性时属性描述符会使用默认值，可以使用Object.definePropertty(…)来添加一个新属性或者修改一个已有属性（如果它是configurable）并对特性进行设置。</p><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject,<span class="string">"a"</span>,&#123;</span><br><span class="line">  value:<span class="number">2</span>,</span><br><span class="line">  writable:<span class="literal">true</span>,</span><br><span class="line">  configurable:<span class="literal">true</span>,</span><br><span class="line">  enumerable:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myObject.a  <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h4 id="Get"><a href="#Get" class="headerlink" title="[Get]"></a>[Get]</h4><p>对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性。如果找到就返回这个属性的值，否则就遍历可能存在的 [[Prototype]] 链，也就是原型链。如若还没找到，返回 undefined</p><h4 id="Put"><a href="#Put" class="headerlink" title="[[Put]]"></a>[[Put]]</h4><p>[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（重要因素）</p><p>如果已经<strong>存在</strong>这个属性，[[put]] 算法大致会检查下面这些内容：</p><ol><li>属性是否是访问描述符（参见Getter和Setter）?如果是并且存在 setter 就调用 setter</li><li>属性的数据描述符中 writable 是否是 false？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常</li><li>如果不是，将该值设置为属性的值</li></ol><p>如果对象中<strong>不存在</strong>这个属性，[[Put]]操作会更加复杂。参见 [[Prototype]]</p><h4 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h4><p>ES5中可以使用 getter 和 setter 部分改写默认操作，但只能应用在单个属性上，无法应用到整个对象。它们都是隐藏函数，getter 获取属性值时调用，setter 在设置属性值时调用。</p><p>JavaScript 会忽略它们的 value 和 writable ，只关心 set 和 get（还有configurable和enumerable）特性。</p><p>为了让属性更合理，getter 和 setter 是成对出现的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="comment">// 给 a 定义一个 getter</span></span><br><span class="line">  <span class="keyword">get</span> a()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._a_</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 给 a 定义一个 setter</span></span><br><span class="line">  <span class="keyword">set</span> a(val)&#123;</span><br><span class="line">    <span class="keyword">this</span>._a_ = val*<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject.a); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h4><p>in 和 hasOwnProperty区别在于是否查找 [[Prototype]] 链</p><p>in 会检查是否在对象及其 [[Prototype]] 原型链中</p><p>in 检查的是某个属性名是否存在</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>for…in 循环可以遍历对象的可枚举属性列表（[[Prototype]]链）。使用它遍历对象是无法直接获取属性值，只是遍历对象中的可枚举属性，需要手动获取属性值。</p><p>ES5数组辅助迭代器，接收一个回调函数并应用到数组的每个元素上，区别是对于回调函数的返回值的处理方式不同：</p><ul><li>forEach(…)会遍历数组中的所有值并忽略回调函数的返回值</li><li>every(…)会一直运行直到回调函数返回false（或假值）</li><li>some(…)会一直运行直到回调函数返回true（或真值）</li></ul><p>every 和 some 中特殊的返回值和普通函数 for 循环中的 break 语句类似，会提前终止遍历</p><p>ES6增加了一种用来遍历数组的 for…of 循环语句，直接遍历值而不是数组下标</p><p>for…of 循环首先会向被访问的对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。细节请见数组内置的 @@iterator 来手动遍历数组是怎么工作的。</p><p>和数组不同，普通对象没有内置的 @@iterator，所有无法完成 for…of 遍历。</p><h2 id="RSA非对称加密"><a href="#RSA非对称加密" class="headerlink" title="RSA非对称加密"></a>RSA非对称加密</h2><p>RSA 不需要双方协商一个保密的密钥，而是有一对钥匙，一个是保密的，成为私钥；另一个是公开的，称为公钥。</p><p>用私钥加密的数据，只有对应的公钥才能解密；用公钥加密的数据，只有对应的私钥才能解密。</p><p>但由于RSA算法的加密和解密速度有点慢，先用 RSA 的方式将对称加密算法的密钥发给对方，随后利用对称密钥通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS对象序列化详解&quot;&gt;&lt;a href=&quot;#JS对象序列化详解&quot; class=&quot;headerlink&quot; title=&quot;JS对象序列化详解&quot;&gt;&lt;/a&gt;JS对象序列化详解&lt;/h2&gt;&lt;h3 id=&quot;什么是序列化&quot;&gt;&lt;a href=&quot;#什么是序列化&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="周总结" scheme="http://yoursite.com/categories/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="周总结" scheme="http://yoursite.com/tags/%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
