<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RicardoJiang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-08T09:21:44.755Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ricardo Jiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SPA应用的优缺点</title>
    <link href="http://yoursite.com/2020/04/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SPA%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2020/04/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SPA%E5%BA%94%E7%94%A8/</id>
    <published>2020-04-08T09:20:54.000Z</published>
    <updated>2020-04-08T09:21:44.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SPA应用的优缺点"><a href="#SPA应用的优缺点" class="headerlink" title="SPA应用的优缺点"></a>SPA应用的优缺点</h1><p>SPA（single-page application）仅在 web 页面初始化时加载相应的HTML、JavaScript和CSS。一旦加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交换，避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染</li><li>基于上面一点，SPA相对对服务器压力小</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后台负责数据处理</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有页面切换需要自己建立堆栈管理</li><li>SEO 难度大：由于所有的内容都在一个页面中动态替换显示，所以在不利于 SEO</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SPA应用的优缺点&quot;&gt;&lt;a href=&quot;#SPA应用的优缺点&quot; class=&quot;headerlink&quot; title=&quot;SPA应用的优缺点&quot;&gt;&lt;/a&gt;SPA应用的优缺点&lt;/h1&gt;&lt;p&gt;SPA（single-page application）仅在 web 页面初始化时加
      
    
    </summary>
    
    
      <category term="SPA" scheme="http://yoursite.com/categories/SPA/"/>
    
    
      <category term="SPA" scheme="http://yoursite.com/tags/SPA/"/>
    
  </entry>
  
  <entry>
    <title>编辑距离</title>
    <link href="http://yoursite.com/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://yoursite.com/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-04-06T02:25:08.000Z</published>
    <updated>2020-04-06T02:30:12.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>难度 <em>困难</em>   运用动态规划的思路进行解题</p><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">LeetCode–编辑距离</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ol><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (删除 &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (删除 &apos;e&apos;)</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &apos;t&apos;)</span><br><span class="line">inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)</span><br><span class="line">enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)</span><br><span class="line">exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)</span><br><span class="line">exection -&gt; execution (插入 &apos;u&apos;)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题运用动态规划的思路，自底向下开始求解答案</p><ul><li><p><code>dp[i][j]</code> 代表 word1 到 i 位置转换成 Word2 到 j 位置需要最少的步数</p></li><li><p>当 word1[i] == word2[j] 时，由于遍历到了 i 和 j，说明 <code>word1 的 0~i-1 和 word2 的 0~j-1</code> 的匹配结果已经生成，由于当前匹配的单词相同，因此无需做任何操作，<code>dp[i][j] = dp[i-1][j-1]</code></p></li><li><p>当  word1[i] ！= word2[j] 时，有以下三个操作</p><ul><li>替换操作： word1 的 <code>0~i-1 和 word2 的 0~j-1</code> 位置字符都相同，只是当前位置字符不匹配，进行替换操作使其相同，所以就有 <code>dp[i][j] = dp[i-1][j-1]+1</code></li><li>删除操作： word1 的 <code>0~i-1 和 word2 的 0~j</code> 位置字符已经匹配，此时多出了 word1 的 i 位置字符，应该将其删除，才能使此时 <code>word1 的 0~i</code> (这个i是执行了删除操作后新的i)和 word2 的 0~j 位置匹配,因此此时<code>dp[i][j]=dp[i-1][j]+1</code></li><li>插入操作：若此时 <code>word1 的 0~i 位置只是和 word2 的 0~j-1</code> 位置匹配,此时只需要在原来的i位置后面插入一个和 word2 的 j 位置相同的字符使得此时的 <code>word1 的 0~i</code> (这个i是执行了插入操作后新的i)和 word2 的 0~j 匹配得上,所以此时<code>dp[i][j]=dp[i][j-1]+1</code></li><li>由于题目所要求的是要最少的操作数:所以当 word1[i]  !=  word2[j] 时,需要在这三个操作中选取一个最小的值赋格当前的<code>dp[i][j]</code></li></ul></li><li><p>状态方程式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(word1[i] == word2[j]):</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; word1</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; word2</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDistance = <span class="function"><span class="keyword">function</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = word1.length,</span><br><span class="line">        n2 = word2.length;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(n1+<span class="number">1</span>),()=&gt;<span class="keyword">new</span> <span class="built_in">Array</span>(n2+<span class="number">1</span>).fill(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">//第一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;=n2;j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n1;i++) dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;编辑距离&quot;&gt;&lt;a href=&quot;#编辑距离&quot; class=&quot;headerlink&quot; title=&quot;编辑距离&quot;&gt;&lt;/a&gt;编辑距离&lt;/h1&gt;&lt;p&gt;难度 &lt;em&gt;困难&lt;/em&gt;   运用动态规划的思路进行解题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/edit-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode–编辑距离&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。&lt;/p&gt;
&lt;p&gt;你可以对一个单词进行如下三种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入一个字符&lt;/li&gt;
&lt;li&gt;删除一个字符&lt;/li&gt;
&lt;li&gt;替换一个字符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：word1 = &amp;quot;horse&amp;quot;, word2 = &amp;quot;ros&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;horse -&amp;gt; rorse (将 &amp;apos;h&amp;apos; 替换为 &amp;apos;r&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rorse -&amp;gt; rose (删除 &amp;apos;r&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rose -&amp;gt; ros (删除 &amp;apos;e&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：word1 = &amp;quot;intention&amp;quot;, word2 = &amp;quot;execution&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;intention -&amp;gt; inention (删除 &amp;apos;t&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inention -&amp;gt; enention (将 &amp;apos;i&amp;apos; 替换为 &amp;apos;e&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enention -&amp;gt; exention (将 &amp;apos;n&amp;apos; 替换为 &amp;apos;x&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exention -&amp;gt; exection (将 &amp;apos;n&amp;apos; 替换为 &amp;apos;c&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exection -&amp;gt; execution (插入 &amp;apos;u&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
      <category term="编辑距离" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>HTTP缓存</title>
    <link href="http://yoursite.com/2020/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/HTTP%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/HTTP%E7%BC%93%E5%AD%98/</id>
    <published>2020-04-05T03:07:33.000Z</published>
    <updated>2020-04-05T03:09:19.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http-缓存"><a href="#Http-缓存" class="headerlink" title="Http 缓存"></a>Http 缓存</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点，主要可分为两点：</p><ul><li>强缓存</li><li>协商缓存</li></ul><h2 id="什么是HTTP缓存"><a href="#什么是HTTP缓存" class="headerlink" title="什么是HTTP缓存"></a>什么是HTTP缓存</h2><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当Web缓存发现请求资源已经被存储，它会拦截请求，返回该资源的拷贝，而不去起源服务器重新下载。</p><p><strong>优点：</strong>缓解服务端压力，提升性能</p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>浏览器中的缓存分为两种，一种是需要发送HTTP请求，一种是不需要发送。</p><p>首先是检查强缓存，这个阶段<strong>不需要</strong>发送HTTP请求。</p><p>在<code>HTTP/1.0</code>和<code>HTTP/1.1</code>当中，这个字段是不一样的。<code>HTTP/1.0</code>使用的是<strong>Expires</strong>，<code>HTTP/1.1</code>使用的是<strong>Cache-Control</strong>。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code>即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Nov <span class="number">2019</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure><p>表示资源在<code>2019年11月22号8点41分</code>过期，过期了就得向服务端发请求。</p><p>但这种方式存在一个隐患，就是<strong>服务器的时间和浏览器的时间可能不一致</strong>，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的<code>HTTP1.1</code>版本中被抛弃了。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在<code>HTTP1.1</code>中，新增了一个字段：<code>Cache-Control</code>。它和 <code>Expires</code> 本质上不同在于它并没有采取<strong>具体过期时间点</strong> 这个方式，而是采取 <strong>过期时长</strong> 来控制缓存，对应的字段是 <code>max-age</code>。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=<span class="number">3600</span></span><br></pre></td></tr></table></figure><p>代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。</p><p><code>Cache-Control</code>有很多指令，完成更多场景的缓存判断, 将一些关键的属性列举如下: </p><ul><li><strong>public</strong>: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的<code>代理服务器</code>最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。</li><li><strong>private</strong>： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</li><li><strong>no-cache</strong>: 跳过当前的强缓存，发送HTTP请求，即直接进入<code>协商缓存阶段</code>。</li><li><strong>no-store</strong>：非常粗暴，不进行任何形式的缓存。</li><li><strong>s-maxage</strong>：这和<code>max-age</code>长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。</li></ul><p>当<strong>Expires</strong>和<strong>Cache-Control</strong>同时存在的时候，<strong>Cache-Control</strong>会优先考虑。</p><p>当资源缓存时间超时了，也就是<strong>强缓存</strong>失效了，就进入<strong>协商缓存</strong>。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存失效之后，浏览器在请求头中携带相应的<code>缓存tag</code>来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是<strong>协商缓存</strong>。</p><p>具体来说，这样的缓存tag分为两种: <strong>Last-Modified</strong> 和 <strong>ETag</strong>。这两者各有优劣，并不存在谁对谁有<strong>绝对的优势</strong>，跟上面强缓存的两个 tag 不一样。</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</p><p>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。</p><p>服务器拿到请求头中的<code>If-Modified-Since</code>的字段后，其实会和这个服务器中<code>该资源的最后修改时间</code>对比:</p><ul><li>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li><li>否则返回304，告诉浏览器直接用缓存。</li></ul><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p><code>ETag</code> 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过<code>响应头</code>把这个值给浏览器。</p><p>浏览器接收到<code>ETag</code>的值，会在下次请求时，将这个值作为<strong>If-None-Match</strong>这个字段的内容，并放到请求头中，然后发给服务器。</p><p>服务器接收到<strong>If-None-Match</strong>后，会跟服务器上该资源的<strong>ETag</strong>进行比对:</p><ul><li>如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li><li>否则返回304，告诉浏览器直接用缓存。</li></ul><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><ol><li>在<code>精准度</code>上，<code>ETag</code>优于<code>Last-Modified</code>。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:</li></ol><ul><li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li><li>Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li></ul><ol><li>在性能上，<code>Last-Modified</code>优于<code>ETag</code>，也很简单理解，<code>Last-Modified</code>仅仅只是记录一个时间点，而 <code>Etag</code>需要根据文件的具体内容生成哈希值。</li></ol><p>另外，如果两种方式都支持的话，服务器会优先考虑<code>ETag</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先通过 <code>Cache-Control</code> 验证强缓存是否可用</p><ul><li><p>如果强缓存可用，直接使用</p></li><li><p>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match</span><br></pre></td></tr></table></figure><p>字段检查资源是否更新</p><ul><li>若资源更新，返回资源和200状态码</li><li>否则，返回304，告诉浏览器直接从缓存获取资源</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5ca2e0c0f265da30d561ed8b#heading-1" target="_blank" rel="noopener">深入现代浏览器的HTTP缓存机制</a></p><p><a href="https://juejin.im/post/5df5bcea6fb9a016091def69" target="_blank" rel="noopener">神三元</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Http-缓存&quot;&gt;&lt;a href=&quot;#Http-缓存&quot; class=&quot;headerlink&quot; title=&quot;Http 缓存&quot;&gt;&lt;/a&gt;Http 缓存&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="HTTP缓存" scheme="http://yoursite.com/tags/HTTP%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2020/04/01/JavaScript/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/04/01/JavaScript/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-04-01T09:15:53.000Z</published>
    <updated>2020-04-09T06:55:58.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><h2 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝"></a>什么是浅拷贝</h2><p>如果是一个引用类型，比如说一个数组直接赋值给另一个新数组，当对这个新数组进行改变的时候，由于是同一个引用，原来的数组也会跟着改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr;</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[100, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果对其进行一次浅拷贝：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>当修改newArr的时候，arr的值并不改变。什么原因?因为这里newArr是arr浅拷贝后的结果，newArr和arr现在引用的已经不是同一块空间啦！</p><p>但是又会存在一个潜在的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">val</span>: <span class="number">4</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">2</span>].val = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ 1, 2, &#123; val: 1000 &#125; ]</span></span><br></pre></td></tr></table></figure><p>这就是浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，它能 解决无限极的对象嵌套问题，实现彻底的拷贝。</p><h2 id="实现浅拷贝的几种方式"><a href="#实现浅拷贝的几种方式" class="headerlink" title="实现浅拷贝的几种方式"></a>实现浅拷贝的几种方式</h2><h3 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">target</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target.hasOwnProperty(prop))&#123;</span><br><span class="line">                cloneTarget[prop] = target[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>但是需要注意的是，Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">'sy'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj, &#123;<span class="attr">name</span>: <span class="string">'sss'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">//&#123; name: 'sss', age: 18 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="concat浅拷贝数组"><a href="#concat浅拷贝数组" class="headerlink" title="concat浅拷贝数组"></a>concat浅拷贝数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat();</span><br><span class="line">newArr[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure><h3 id="slice浅拷贝"><a href="#slice浅拷贝" class="headerlink" title="slice浅拷贝"></a>slice浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice();</span><br><span class="line">newArr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="…展开运算符"><a href="#…展开运算符" class="headerlink" title="…展开运算符"></a>…展开运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...arr];<span class="comment">//跟arr.slice()是一样的效果</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">        <span class="comment">//判断obj子元素是否为对象</span></span><br><span class="line">        <span class="keyword">if</span>(obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>)&#123;</span><br><span class="line">          obj[key] = deepClone(obj[key])</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          objClone[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="[http://47.98.159.95/my_blog/js-api/005.html#_1-%E7%AE%80%E6%98%93%E7%89%88%E5%8F%8A%E9%97%AE%E9%A2%98](http://47.98.159.95/my_blog/js-api/005.html#_1-简易版及问题)">如何写一个完整的深拷贝？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h1&gt;&lt;h2 id=&quot;什么是浅拷贝&quot;&gt;&lt;a href=&quot;#什么是浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;什么是浅拷贝&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="深拷贝和浅拷贝" scheme="http://yoursite.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="http://yoursite.com/2020/03/30/%E5%91%A8%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/03/30/%E5%91%A8%E6%80%BB%E7%BB%93/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-30T09:03:49.000Z</published>
    <updated>2020-03-30T09:07:07.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>JavaScript 之所以能在浏览器环境和NodeJs环境运行，都是因为有V8引擎在幕后保驾护航。从编译、内存分配、运行及垃圾回收等整个过程，都离不开它。</p><p>下面对垃圾回收做一个归纳总结。</p><h2 id="为什么会有垃圾回收？"><a href="#为什么会有垃圾回收？" class="headerlink" title="为什么会有垃圾回收？"></a>为什么会有垃圾回收？</h2><p>JS 语言不想 C/C++，让程序员自己去开辟或释放内存，而是类似Java，采用自己的一套垃圾回收算法进行自动的内存管理。</p><p>垃圾回收的喊出是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但如果写代码时不注意，可能导致循环引用等情况，导致内存泄漏。</p><h2 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h2><p>在其他的后端语言中，如Java/Go, 对于内存的使用没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，具体来说，在<code>64</code>位系统下，V8最多只能分配<code>1.4G</code>, 在 32 位系统中，最多只能分配<code>0.7G</code>。你想想在前端这样的大内存需求其实并不大，但对于后端而言，nodejs如果遇到一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。</p><h3 id="为什么要限制其大小？"><a href="#为什么要限制其大小？" class="headerlink" title="为什么要限制其大小？"></a>为什么要限制其大小？</h3><ul><li>js是单线程的执行机制</li><li>垃圾回收非常耗时</li></ul><p>首先JS是单线程执行的，一旦进入到垃圾回收，其它的各种运行逻辑都要暂停；另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的:</p><blockquote><p>以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式的垃圾回收甚至要 1s 以上。</p></blockquote><h2 id="js的垃圾回收机制"><a href="#js的垃圾回收机制" class="headerlink" title="js的垃圾回收机制"></a>js的垃圾回收机制</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ol><li>标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。</li><li>清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。</li><li>缺点：垃圾收集后有可能会造成大量的 <strong>内存碎片</strong>。</li></ol><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><ol><li>引用计数的含义是跟踪记录每个值被引用的次数，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</li><li>缺点： 循环引用没法回收。</li></ol><h2 id="V8垃圾回收机制"><a href="#V8垃圾回收机制" class="headerlink" title="V8垃圾回收机制"></a>V8垃圾回收机制</h2><p>自动垃圾回收有很多算法，由于不同对象的生存周期不同，所以无法只用一种回收策略来解决问题，这样效率会很低。</p><p>所以，V8采用了一种代回收的策略，将内存分为两个生代：<strong>新生代（new generation）</strong>和<strong>老生代（old generation）</strong>。</p><p><img src="./2.jpg" alt="2"></p><p>新生代：临时分配的内存，存活时间较短的对象</p><p>老生代：常驻内存，存活时间长的对象</p><p>分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫晋升。</p><h3 id="分代内存"><a href="#分代内存" class="headerlink" title="分代内存"></a>分代内存</h3><p>默认情况下，32位系统新生代内存大小为16MB，老生代内存大小为700MB，64位系统下，新生代内存大小为32MB，老生代内存大小为1.4GB。</p><p>新生代平均分成两块相等的内存空间，叫做semispace，每块内存大小8MB（32位）或16MB（64位）。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>首先将新生代内存空间一分为二：</p><p><img src="./3.jpg" alt="3"></p><p>其中From部分表示正在使用的内存，To是目前闲置的内存。</p><p>当进行垃圾回收时，V8将From的对象检查一遍，如果是存活对象那么复制到To内存中（在To内存中按照顺序从头放置），如果是非存活对象直接回收即可。</p><p>当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色<code>对调</code>，From现在被闲置，To为正在使用，如此循环。</p><p>在To内存中按照顺序从头放置的，这是为了应对这样的场景:</p><p><img src="./4.jpg" alt="4"></p><p>深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做<strong>内存碎片</strong>。刚刚介绍的新生代垃圾回收算法也叫<strong>Scavenge算法</strong>。</p><p>Scavenge 算法主要就是解决内存碎片的问题，在进行一顿复制之后，To空间变成了这个样子:</p><p><img src="./5.jpg" alt="5"></p><p>不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象<code>一般很少</code>，因此<code>时间</code>性能非常优秀。</p><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>刚刚介绍了新生代的回收方式，那么新生代中的变量如果经过多次回收后依然存在，那么就会被放入到<code>老生代内存</code>中，这种现象就叫<code>晋升</code>。</p><p>生晋升其实不只是这一种原因，我们来梳理一下会有那些情况触发晋升:</p><ul><li>已经经历过一次 Scavenge 回收。</li><li>To（闲置）空间的内存占用超过25%。</li></ul><p>现在进入到老生代的垃圾回收机制当中，老生代中累积的变量空间一般都是很大的，当然不能用<code>Scavenge</code>算法啦，浪费一半空间不说，对庞大的内存空间进行复制岂不是劳民伤财？</p><p>V8在老生代中主要采用了<strong>Mark-Sweep</strong>和<strong>Mark-Compact</strong>相结合的方式进行垃圾回收。</p><h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h4><p>Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。</p><p>与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。Mark-Sweep在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。</p><p>也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。</p><p>我们还是通过流程图来看一下：</p><p><strong>step1</strong>. 老生代中有对象A、B、C、D、E、F</p><img src="./M.jpg" alt="M" style="zoom:50%;" /><p><strong>step2</strong>. GC进入标记阶段，将A、C、E标记为存活对象</p><img src="./MS2.jpg" alt="MS2" style="zoom:50%;" /><p><strong>step3</strong>. GC进入清除阶段，回收掉死亡的B、D、F对象所占用的内存空间</p><img src="./MS3.jpg" alt="MS3" style="zoom:50%;" /><p>可以看到，Mark-Sweep最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。</p><p>如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p><h4 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact"></a>Mark-Compact</h4><p>为了解决Mark-Sweep的内存碎片问题，Mark-Compact就被提出来了。</p><p><strong>Mark-Compact是标记整理的意思，</strong>是在Mark-Sweep的基础上演变而来的。Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。如下图所示：</p><p><strong>step1</strong>. 老生代中有对象A、B、C、D、E、F（和Mark—Sweep一样）</p><img src="./M.jpg" alt="M" style="zoom:50%;" /><p><strong>step2</strong>. GC进入标记阶段，将A、C、E标记为存活对象（和Mark—Sweep一样）</p><img src="./MS2.jpg" alt="MS2" style="zoom:50%;" /><p><strong>step3</strong>. GC进入整理阶段，将所有存活对象向内存空间的一侧移动，灰色部分为移动后空出来的空间</p><img src="./MC2.jpg" alt="MC2" style="zoom:50%;" /><p><strong>step4</strong>. GC进入清除阶段，将边界另一侧的内存一次性全部回收</p><img src="./MC3.jpg" alt="MC3" style="zoom:50%;" /><h4 id="两者结合"><a href="#两者结合" class="headerlink" title="两者结合"></a>两者结合</h4><p>在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。</p><p>由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>V8的垃圾回收机制分为新生代和老生代。</p><p>新生代主要使用Scavenge进行管理，主要实现是Cheney算法，将内存平均分为两块，使用空间叫From，闲置空间叫To，新对象都先分配到From空间中，在空间快要占满时将存活对象复制到To空间中，然后清空From的内存空间，此时，调换From空间和To空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。</p><p>老生代主要采用Mark-Sweep和Mark-Compact算法，一个是标记清除，一个是标记整理。两者不同的地方是，Mark-Sweep在垃圾回收后会产生碎片内存，而Mark-Compact在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在V8中，老生代是Mark-Sweep和Mark-Compact两者共同进行管理的。</p><blockquote><p> 参考：</p><p><a href="[http://47.98.159.95/my_blog/js-v8/002.html#v8-%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6](http://47.98.159.95/my_blog/js-v8/002.html#v8-内存限制)">V8 引擎如何进行垃圾内存的回收</a></p><p><a href="https://juejin.im/post/5ad3f1156fb9a028b86e78be#heading-3" target="_blank" rel="noopener">聊聊V8引擎的垃圾回收</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;垃圾回收机制&quot;&gt;&lt;a href=&quot;#垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收机制&quot;&gt;&lt;/a&gt;垃圾回收机制&lt;/h1&gt;&lt;p&gt;JavaScript 之所以能在浏览器环境和NodeJs环境运行，都是因为有V8引擎在幕后保驾护航。从编译、
      
    
    </summary>
    
    
      <category term="垃圾回收机制" scheme="http://yoursite.com/categories/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="垃圾回收机制" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>三数之和</title>
    <link href="http://yoursite.com/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-03-30T02:47:54.000Z</published>
    <updated>2020-04-06T02:26:01.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">力扣–三数之和</a></p></blockquote><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>首先对数组进行排序，按照从大到小进行排列</li><li>遍历每一个元素，用一个元素去找另外两个队友，其中该元素为<code>i</code>，<code>L=i+1</code>，<code>R=len-1</code></li><li>根据<code>sum=nums[i]+nums[L]+nums[R]</code>，判断<code>sum</code>是否等于0</li><li><code>nums[i]&gt;0</code>，表示三数之和再怎么计算也无法等于0，跳出循环</li><li><code>nums[i]==nums[i-1]</code>，表示数据重复，将导致结果重复，跳过</li><li><code>sum==0,nums[L]==nums[L+1]</code>，去重，否则结果重复，跳过</li><li><code>sum==1,nums[R]==nums[R-1]</code>，同上</li></ul><p><strong>代码：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">//三数之和无法等于0，结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] === nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//数据重复，跳过，否则结果重复</span></span><br><span class="line">        <span class="keyword">let</span> L = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> R = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                res.push([nums[i],nums[L],nums[R]]);</span><br><span class="line">                <span class="keyword">while</span>(L&lt;R &amp;&amp; nums[L] === nums[L+<span class="number">1</span>]) L++; <span class="comment">//去重,否则结果重复</span></span><br><span class="line">                <span class="keyword">while</span>(L&lt;R &amp;&amp; nums[R] === nums[R<span class="number">-1</span>]) R--; <span class="comment">//同上</span></span><br><span class="line">                L++;</span><br><span class="line">                R--; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;三数之和&quot;&gt;&lt;a href=&quot;#三数之和&quot; class=&quot;headerlink&quot; title=&quot;三数之和&quot;&gt;&lt;/a&gt;三数之和&lt;/h1&gt;&lt;p&gt;给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定数组 nums = [-1, 0, 1, 2, -1, -4]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;满足要求的三元组集合为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, -1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣–三数之和&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="三数之和" scheme="http://yoursite.com/tags/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    
      <category term="力扣" scheme="http://yoursite.com/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>位运算符</title>
    <link href="http://yoursite.com/2020/03/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/03/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-03-26T03:29:10.000Z</published>
    <updated>2020-03-26T03:30:16.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><h2 id="七种位运算符"><a href="#七种位运算符" class="headerlink" title="七种位运算符"></a>七种位运算符</h2><table><thead><tr><th align="center">位运算符</th><th align="center">描述</th><th align="center">运算规则</th></tr></thead><tbody><tr><td align="center">&lt;&lt;</td><td align="center">左移</td><td align="center">各二进制位全部左移若干位，高位丢弃，地位补0</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移</td><td align="center">各二进制位全部右移若干位，正数高位补0，负数高位补1</td></tr><tr><td align="center">&gt;&gt;&gt;</td><td align="center">无符号右移</td><td align="center">各二进制全部右移若干位，高位补0</td></tr><tr><td align="center">&amp;</td><td align="center">位与</td><td align="center">两个位都位1时，结果才为1</td></tr><tr><td align="center">|</td><td align="center">位或</td><td align="center">两个位都是0时，结果才为0</td></tr><tr><td align="center">~</td><td align="center">位非</td><td align="center">0变1,1变0</td></tr><tr><td align="center">^</td><td align="center">位异或</td><td align="center">两个位相同时为0，相异为1</td></tr></tbody></table><p>其中位非（~）是一元运算符，其他都是二元运算符。</p><a id="more"></a><h2 id="位与运算符（-amp-）"><a href="#位与运算符（-amp-）" class="headerlink" title="位与运算符（&amp;）"></a>位与运算符（&amp;）</h2><p><strong>运算规则</strong>：两个数都为二进制，然后从高位比较，如果两个数都为1则为1，否则为0。</p><p><em>例如</em>：130&amp;129</p><p>130        =&gt;      10000010<br>129        =&gt;      10000001<br>130&amp;129   =&gt;  10000000  =&gt; 128</p><h2 id="左移（-lt-lt-）"><a href="#左移（-lt-lt-）" class="headerlink" title="左移（&lt;&lt;）"></a>左移（&lt;&lt;）</h2><p><strong>运算规则</strong>：各二进位全部左移若干位，高位丢弃，低位补0。</p><p><em>例如</em>：6 &lt;&lt; 2 = 24</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0110     -&gt; 6</span><br><span class="line">0000 0000 0000 0000 0000 0000 0001 1000     -&gt; 6 &lt;&lt; 2 = 24</span><br></pre></td></tr></table></figure><p>我们将6的二进位向左移动两位，低位补上两个0，高位丢弃，得出来的结果就是24。 </p><p>左移常被用来做 <code>x * (2 ^ n)</code> 的运算，因为直接基于二进制运算，所以左移效率比 <code>x* (2 ^ n)</code> 高。</p><h2 id="右移（-gt-gt-）"><a href="#右移（-gt-gt-）" class="headerlink" title="右移（&gt;&gt;）"></a>右移（&gt;&gt;）</h2><p><strong>运算规则</strong>：各二进位全部右移若干位，正数高位补0，负数高位补1，低位丢弃。</p><p><em>例如</em>：12 &gt;&gt; 2 = 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 1100     -&gt; 12</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0011     -&gt; 12 &gt;&gt; 2 = 3</span><br><span class="line">复</span><br></pre></td></tr></table></figure><p>因为12是正数，右移过程中高位补上两个0，低位丢弃，得出来的结果就是3。 例如：-12 &gt;&gt; 2 = -3</p><p>负数的二进制 = 正数二进制的反码 + 1</p><h2 id="无符号右移（-gt-gt-gt-）"><a href="#无符号右移（-gt-gt-gt-）" class="headerlink" title="无符号右移（&gt;&gt;&gt;）"></a>无符号右移（&gt;&gt;&gt;）</h2><p><strong>运算规则</strong>：各二进位全部右移若干位，高位补0，低位丢弃。</p><p>其实无符合右移和右移的区别就是不用关心是正数还是负数，右移时高位都补0。</p><p><em>例如</em>：-12 &gt;&gt;&gt; 2 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1111 0100    -&gt; -12</span><br><span class="line">0011 1111 1111 1111 1111 1111 1111 1101    -&gt; -12 &gt;&gt; 2 = 1073741821</span><br></pre></td></tr></table></figure><blockquote><p>参考:  <a href="https://juejin.im/post/5df1a02ee51d4558181d2a5a#heading-5" target="_blank" rel="noopener">java位运算符</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;位运算符&quot;&gt;&lt;a href=&quot;#位运算符&quot; class=&quot;headerlink&quot; title=&quot;位运算符&quot;&gt;&lt;/a&gt;位运算符&lt;/h1&gt;&lt;h2 id=&quot;七种位运算符&quot;&gt;&lt;a href=&quot;#七种位运算符&quot; class=&quot;headerlink&quot; title=&quot;七种位运算符&quot;&gt;&lt;/a&gt;七种位运算符&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;位运算符&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;描述&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;运算规则&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;左移&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;各二进制位全部左移若干位，高位丢弃，地位补0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;右移&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;各二进制位全部右移若干位，正数高位补0，负数高位补1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无符号右移&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;各二进制全部右移若干位，高位补0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&amp;amp;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;位与&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;两个位都位1时，结果才为1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;|&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;位或&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;两个位都是0时，结果才为0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;~&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;位非&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0变1,1变0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;^&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;位异或&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;两个位相同时为0，相异为1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;其中位非（~）是一元运算符，其他都是二元运算符。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="位运算符" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Set和Map</title>
    <link href="http://yoursite.com/2020/03/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Set%E5%92%8CMap/"/>
    <id>http://yoursite.com/2020/03/25/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Set%E5%92%8CMap/</id>
    <published>2020-03-25T03:09:14.000Z</published>
    <updated>2020-03-25T03:20:53.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 类似于数组，但是成员的值都是唯一的，没有重复的值。</p><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><ul><li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li><li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 数据结构，类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p><h3 id="Map-实例的属性和方法"><a href="#Map-实例的属性和方法" class="headerlink" title="Map 实例的属性和方法"></a>Map 实例的属性和方法</h3><p>Map 结构的实例有以下属性和操作方法：</p><ul><li>size</li><li>Map.prototype.set(k,v)：<code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li><li>Map.prototype.get(key)</li><li>Map.prototype.has(key)</li><li>Map.prototype.delete(key)</li><li>Map.prototype.clear()</li></ul><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p><p><code>WeakMap</code>与<code>Map</code>的区别有两点：</p><ul><li><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</li><li><code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</li></ul><p>参考：<a href="https://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">阮一峰–Set和Map</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Set-和-Map-数据结构&quot;&gt;&lt;a href=&quot;#Set-和-Map-数据结构&quot; class=&quot;headerlink&quot; title=&quot;Set 和 Map 数据结构&quot;&gt;&lt;/a&gt;Set 和 Map 数据结构&lt;/h1&gt;&lt;h2 id=&quot;Set&quot;&gt;&lt;a href=&quot;#Se
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="Set和Map" scheme="http://yoursite.com/tags/Set%E5%92%8CMap/"/>
    
  </entry>
  
  <entry>
    <title>cookie、session和token</title>
    <link href="http://yoursite.com/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/cst/"/>
    <id>http://yoursite.com/2020/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/cst/</id>
    <published>2020-03-20T11:52:31.000Z</published>
    <updated>2020-03-20T12:01:06.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cookie、session和token"><a href="#cookie、session和token" class="headerlink" title="cookie、session和token"></a>cookie、session和token</h1><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie是由浏览器生成发送给浏览器，浏览器把cookie以键值对的方式存储在某个目录下的文件中，下一次请求同一网站时会把该cookie发送给服务器。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>ookie会被附加在每个HTTP请求中，所以无形中增加了流量。</li><li>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）</li><li>Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。<a id="more"></a><h3 id="Cookie，SessionStorage，LocalStorage"><a href="#Cookie，SessionStorage，LocalStorage" class="headerlink" title="Cookie，SessionStorage，LocalStorage"></a>Cookie，SessionStorage，LocalStorage</h3></li></ul><p>HTML5提供了两种本地存储的方式 sessionStorage 和 localStorage；</p><p><img src="cookie.jpg" alt="cookie"></p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session代表会话，服务器为了区分每个客户端，给客户端分配不同的”身份标识”，然后客户端每次想服务器发请求的识货，都带上这个“身份标识”，服务器就知道这个请求是哪个客户端发的了。</p><h3 id="过程-服务端session-客户端-sessionId"><a href="#过程-服务端session-客户端-sessionId" class="headerlink" title="过程(服务端session + 客户端 sessionId)"></a>过程(服务端session + 客户端 sessionId)</h3><p><img src="session.jpg" alt="session"></p><ol><li><p>用户向服务器发送用户名和密码</p></li><li><p>服务器验证通过后,在当前对话(session)里面保存相关数据,比如用户角色, 登陆时间等;</p></li><li><p>服务器向用户返回一个<code>session_id</code>, 写入用户的<code>cookie</code></p></li><li><p>用户随后的每一次请求, 都会通过<code>cookie</code>, 将<code>session_id</code>传回服务器</p></li><li><p>服务端收到 <code>session_id</code>, 找到前期保存的数据, 由此得知用户的身份</p></li></ol><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>token是服务端生成的一串字符串,以作客户端进行请求的令牌,当第一次登陆后,服务器生成一个token便将此token返回给客户端,以后客户端只要带上这个token前来请求数据即可,无需再次带上用户名和密码</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><img src="token.jpg" alt="token"></p><ol><li>用户通过用户名和密码发送请求</li><li>程序验证</li><li>程序返回一个签名的token给客户端</li><li>客户端储存token, 并且每次用每次发送请求</li><li>服务端验证Token并返回数据</li></ol><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><ul><li>头部</li><li>负载</li><li>签名</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://jwt.io/" target="_blank" rel="noopener">jwt</a></li><li><a href="https://www.cnblogs.com/moyand/p/9047978.html" target="_blank" rel="noopener">彻底理解cookie，session，token</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JSON Web Token 入门教程</a></li><li><a href="https://www.jianshu.com/p/bd1be47a16c1" target="_blank" rel="noopener">Cookie、Session、Token那点事儿（原创）</a></li></ul><ul><li><a href="https://juejin.im/post/5d01f82cf265da1b67210869#heading-15" target="_blank" rel="noopener">详解 Cookie，Session，Token</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;cookie、session和token&quot;&gt;&lt;a href=&quot;#cookie、session和token&quot; class=&quot;headerlink&quot; title=&quot;cookie、session和token&quot;&gt;&lt;/a&gt;cookie、session和token&lt;/h1&gt;&lt;h2 id=&quot;cookie&quot;&gt;&lt;a href=&quot;#cookie&quot; class=&quot;headerlink&quot; title=&quot;cookie&quot;&gt;&lt;/a&gt;cookie&lt;/h2&gt;&lt;p&gt;cookie是由浏览器生成发送给浏览器，浏览器把cookie以键值对的方式存储在某个目录下的文件中，下一次请求同一网站时会把该cookie发送给服务器。&lt;/p&gt;
&lt;h3 id=&quot;缺陷&quot;&gt;&lt;a href=&quot;#缺陷&quot; class=&quot;headerlink&quot; title=&quot;缺陷&quot;&gt;&lt;/a&gt;缺陷&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ookie会被附加在每个HTTP请求中，所以无形中增加了流量。&lt;/li&gt;
&lt;li&gt;由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）&lt;/li&gt;
&lt;li&gt;Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="cookie" scheme="http://yoursite.com/tags/cookie/"/>
    
      <category term="session" scheme="http://yoursite.com/tags/session/"/>
    
      <category term="token" scheme="http://yoursite.com/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>for-in和for-of</title>
    <link href="http://yoursite.com/2020/03/13/JavaScript/for-in%E5%92%8Cfor-of/"/>
    <id>http://yoursite.com/2020/03/13/JavaScript/for-in%E5%92%8Cfor-of/</id>
    <published>2020-03-13T05:18:10.000Z</published>
    <updated>2020-03-13T05:20:14.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="for-in-和-for-of"><a href="#for-in-和-for-of" class="headerlink" title="for in 和 for of"></a>for in 和 for of</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>推荐在循环对象属性的时候，使用<code>for...in</code>,在遍历数组的时候的时候使用<code>for...of</code>。</li><li><code>for...in</code>循环出的是key，<code>for...of</code>循环出的是value</li><li>注意，<code>for...of</code>是ES6新引入的特性。修复了ES5引入的<code>for...in</code>的不足</li><li><code>for...of</code>不能循环普通的对象，需要通过和<code>Object.keys()</code>搭配使用</li></ol><h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h2><p>for in 作用于数组的话，循环除了遍历数组元素以外，还会遍历自定义属性，如果你的数组中有一个可枚举的类型 a.name，那么循环将额外遍历一次，遍历名为 name 的索引，甚至数组原型上的属性都能访问到，所以不适用于数组的遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// arrCustom</span></span><br><span class="line"><span class="comment">// objCustom</span></span><br></pre></td></tr></table></figure><p>遍历了原型对象，在实际工作中是不需要的，多此一举</p><p>用 hasOwnProperty</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="keyword">if</span> (arr.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure><p>数组本身的属性还是会遍历出来，用 forEach </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>但是 forEach 只能遍历数组，而且在遍历数组的时候无法 break 或 return false 中断</p><h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h2><p>for of 弥补了 for in 循环的所有缺点，一般用于数组的遍历，也支持大部分类数组对象。 </p><p><strong>注意:<code>for-of</code>循环不支持普通对象,但是如果你想迭代一个对象的属性,可以使用<code>for-in</code>循环(这也是它的本职工作)或者内建的<code>Object.keys()方法</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student=&#123;</span><br><span class="line">    name:<span class="string">'wujunchuan'</span>,</span><br><span class="line">    age:<span class="number">22</span>,</span><br><span class="line">    locate:&#123;</span><br><span class="line">    country:<span class="string">'china'</span>,</span><br><span class="line">    city:<span class="string">'xiamen'</span>,</span><br><span class="line">    school:<span class="string">'XMUT'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(student))&#123;</span><br><span class="line">    <span class="comment">//使用Object.keys()方法获取对象key的数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(key+<span class="string">": "</span>+student[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还不如用 for in来遍历</p><p><strong>for of 的其他应用场景：</strong></p><p>for of可以用来迭代字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'boo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br></pre></td></tr></table></figure><p>可以迭代 arguments类数组对象，迭代NodeList这类DOM集合，无需<code>[].slice.call()</code>，也不需要<code>Array.from()</code>进行数组转化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> elements = <span class="built_in">document</span>.querySelectorAll(<span class="string">'body'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> element <span class="keyword">of</span> elements) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element.tagName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果是：</span></span><br><span class="line"><span class="comment">// "BODY"</span></span><br></pre></td></tr></table></figure><p>还可以迭代类型数组、Map、Set、generators</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/11" target="_blank" rel="noopener">JavaScript中的for-of循环</a></p><p><a href="https://www.zhangxinxu.com/wordpress/2018/08/for-in-es6-for-of/" target="_blank" rel="noopener">看，for..in和for..of在那里吵架！</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;for-in-和-for-of&quot;&gt;&lt;a href=&quot;#for-in-和-for-of&quot; class=&quot;headerlink&quot; title=&quot;for in 和 for of&quot;&gt;&lt;/a&gt;for in 和 for of&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="for-in 和 for-of" scheme="http://yoursite.com/tags/for-in-%E5%92%8C-for-of/"/>
    
  </entry>
  
  <entry>
    <title>轮询、长轮询、长连接、websocket</title>
    <link href="http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81websocket/"/>
    <id>http://yoursite.com/2020/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81websocket/</id>
    <published>2020-03-11T08:39:51.000Z</published>
    <updated>2020-03-11T10:01:43.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="轮询、长轮询、SSE、websocket"><a href="#轮询、长轮询、SSE、websocket" class="headerlink" title="轮询、长轮询、SSE、websocket"></a>轮询、长轮询、SSE、websocket</h1><h2 id="短轮询和长轮询"><a href="#短轮询和长轮询" class="headerlink" title="短轮询和长轮询"></a>短轮询和长轮询</h2><p>短轮询和长轮询的目的都是用哦关于实现客户端和服务端的一个即时通讯</p><h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h3><p>短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。</p><p>这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接收请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务端的数据变化</p><p><strong>优缺点</strong>：</p><p>这种方式的优点就是比较简单，易于理解。</p><p>缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务端和客户端的资源。当用户增加时，服务端的压力就会变大。</p><h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>长轮询的基本思路是，首先由客户端向服务端发送请求，当服务端收到客户端发来的请求后，服务端不会直接进行响应，而是先将这个请求挂起，然后判断服务器数据是否有更新。如果有更新则进行响应，如果一直没有数据，则到达一定的事件限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</p><p><strong>优缺点</strong>：</p><p>长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。缺点是连接挂起也会导致资源的浪费。</p><h2 id="SSE（Sever-Send-Events）"><a href="#SSE（Sever-Send-Events）" class="headerlink" title="SSE（Sever-Send Events）"></a>SSE（Sever-Send Events）</h2><p>SSE是 H5 新增的功能，它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询和短轮询不同，虽然都是基于 http 协议，但是轮询需要客户端先发送请求。而 SSE 最大的特点就是不需要客户端发送请求，可以实现只要服务端数据有更新，就可以马上发送到客户端。</p><p>SSE优点就是不需要建立或保持大量的客户端发送服务端的请求，节约了很多资源，提升应用性能。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。</p><p>WebSocket 是 H5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务端主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务端的配置比较复杂。</p><p>websocket 是一个全双工协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信，只能有服务端向客户端推送信息，如果客户端需要发送消息就是属于下一个 http 请求了。</p><blockquote><p>参考资料：<a href="https://cloud.tencent.com/developer/article/1076547" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1076547</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;轮询、长轮询、SSE、websocket&quot;&gt;&lt;a href=&quot;#轮询、长轮询、SSE、websocket&quot; class=&quot;headerlink&quot; title=&quot;轮询、长轮询、SSE、websocket&quot;&gt;&lt;/a&gt;轮询、长轮询、SSE、websocket&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="轮询" scheme="http://yoursite.com/tags/%E8%BD%AE%E8%AF%A2/"/>
    
      <category term="SSE" scheme="http://yoursite.com/tags/SSE/"/>
    
      <category term="websocket" scheme="http://yoursite.com/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2020/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/03/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-03-06T07:45:49.000Z</published>
    <updated>2020-03-06T13:01:48.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于算法之类的问题，知识点还是有点薄弱，今天就来认识一下什么是动态规划算法，查漏补缺，每天学习一点。</p><p>动态规划是一种分阶段解决问题的数学思想，简单的来说就是<strong>大事化小，小事化了</strong>。</p><p>动态规划中有三个核心概念：</p><ul><li>最优子结构</li><li>边界</li><li>状态转移公式</li></ul><p><strong>举一个例子</strong>：</p><p><img src="dp.png" alt="dp"></p><p>假设只能通过road1或road2两条路径到达终点，到达road1有x条路径，到达road2有y条路径，所以到达终点的可能性就是 x+y </p><p><strong>另一个列子</strong>：</p><p>有一个只能容纳10本书的单层书架，你每次只能放1本或2本书。要求用程序求出你将书架填满一共有多少种方法。</p><p>从书架上为0到放满的方法总数<strong>等于</strong>0本到9本的方法总数<strong>加</strong>0到8本的方法总数。也就是F(10)=F(8)+F(9)，依次类推得到：<strong>F(n) = F(n-1)+F(n-2)（n&gt;=3）</strong></p><ul><li>最优子结构：F(10)=F(8)+F(9)</li><li>边界：当书架直接只有1 或 2 本书要放时，我们可以直接得到结果，无需花间，我们称F(1)和F(2)为边界。</li><li>状态转移公式：F(n) = F(n-1)+F(n-2)</li></ul><h2 id="leecode"><a href="#leecode" class="headerlink" title="leecode"></a>leecode</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">原题地址</a></p><h3 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="robot_maze.png" alt="robot_maze"></p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>说明：</strong> <em>m</em> 和 <em>n</em> 的值均不超过 100。</p><blockquote><p>示例 1:</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; obstacleGrid</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span>(<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.length,</span><br><span class="line">        n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//用数组记录每一次的结果</span></span><br><span class="line">    <span class="keyword">let</span> dp = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i]=[];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">// 若该节点为0，表示通向该节点的路径为0</span></span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//对于n行1列来说，该节点的路径是依赖于左边的节点</span></span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><blockquote><p><a href="https://juejin.im/post/5cde316f6fb9a07ed9118f01#heading-2" target="_blank" rel="noopener">https://juejin.im/post/5cde316f6fb9a07ed9118f01#heading-2</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划算法&quot;&gt;&lt;a href=&quot;#动态规划算法&quot; class=&quot;headerlink&quot; title=&quot;动态规划算法&quot;&gt;&lt;/a&gt;动态规划算法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yoursite.com/2020/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/%E8%B7%A8%E5%9F%9F/</id>
    <published>2020-03-03T09:04:24.000Z</published>
    <updated>2020-03-22T06:32:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跨域是一个常考点，平常也有所了解，在这里做一个简单的总结。</p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>跨域是指当前域名下想请求另一个域名下的资源但是由于同源策略的限制，而不能直接发送请求请求。</p><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>同源是指：协议+域名+端口 三者相同，如果缺少同源策略很容易受到XSS、CSFR等攻击。</p><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h3><p>通常为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一个独立域名的服务器上，在html页面中通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><p>利用<code>&lt;script&gt;</code>标签没有跨域限制，将src设置为需要访问的url，并提供一个回调函数来接收数据。只限于get请求。</p><p>具体代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url,jsonpCallback,success</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.creatElement(<span class="string">'script'</span>)</span><br><span class="line">    script.src = url</span><br><span class="line">    script.async = <span class="literal">true</span></span><br><span class="line">    script.type = <span class="string">'text/javascript'</span></span><br><span class="line">    <span class="comment">// 约定一个callback字段名，来传递函数名，前端通过该函数来拿到数据</span></span><br><span class="line">    <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        success &amp;&amp; success(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="JSONP的缺点"><a href="#JSONP的缺点" class="headerlink" title="JSONP的缺点"></a>JSONP的缺点</h4><ul><li>由于是 <code>script</code> 标签，所以读不到 <code>ajax</code> 那么精确的状态，不知道状态码是什么，也不知道响应头是什么，它只知道成功和失败。</li><li>不支持<code>post</code>（因为是 <code>script</code> 标签，所以只支持 <code>get</code> 请求）</li></ul><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><h4 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h4><p><code>CORS</code> 的全称是 <strong>跨域资源共享</strong>(Cross-origin resource sharing)。它允许浏览器向跨域服务器，发出 <code>XMLHTTPRequest</code>，从而克服了 AJAX 只能同源使用的限制。</p><p>如果<code>wang.com</code>和<code>ergou.com</code>这两个网站都是我的，我就是想让<code>wang.com</code>去访问<code>ergou.com</code>里面的数据应该怎么办呢？</p><p>只需要<code>wang.com</code>在响应头里写<code>ergou.com</code>可以访问即可。这就是<code>CORS</code>。</p><p>实现<code>CORS</code>通信的关键是服务器。只要服务器实现了<code>CORS</code>接口，就可以跨源通信。</p><h4 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h4><p><code>CORS</code> 跨域分为两种请求，一种是<strong>简单请求</strong>，另一种是<strong>复杂请求</strong>。</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>只要满足以下条件的就是简单请求：</p><ul><li><p>请求方式为<code>HEAD</code>、<code>POST</code> 或者 <code>GET</code></p></li><li><p>http头信息不超出以下字段：<code>Accept</code>、<code>Accept-Language</code> 、 <code>Content-Language</code>、 <code>Last-Event-ID</code>、 <code>Content-Type</code>(限于三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)</p></li></ul><p>简单请求的实现具体来说就是在信息头中加入一个<code>Origin</code>字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//wang.com</span></span><br><span class="line">Host: api.ergou.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>Origin</code>的作用就是用来说明本次请求来自哪个源，服务器会根据<code>Origin</code>的值来判断是否接受本次请求。</p><p>如果<code>Origin</code>所表示的源不被服务器接受，即浏览器发现回应的信息头中没有<code>Access-Control-Allow-Origin</code>字段，就会自动抛出一个错误。</p><p>注意：这种错误是无法通过状态码识别的，这也是通过<code>CORS</code>实现跨域请求的一个弊端。</p><p>如果<code>Origin</code>所表示的源被服务器端所接受，那么服务器就会返回如下响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.ergou.com</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure><ul><li><p><code>Access-Control-Allow-Origin</code> :该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求</p></li><li><p><code>Access-Control-Allow-Credentials</code>: 该字段可选。它的值是一个布尔值，表示是否允许发送<code>Cookie</code>。默认情况下，<code>Cookie</code>不包括在<code>CORS</code>请求之中。设为<code>true</code>，即表示服务器明确许可，<code>Cookie</code>可以包含在请求中，一起发给服务器。这个值也<strong>只能设为<code>true</code></strong>，如果服务器不要浏览器发送<code>Cookie</code>，删除该字段即可。(注意：如果要发送<code>cookie</code>，不仅要进行上述的设置，还要在<code>AJAX</code>请求中设置<code>withCredentials</code>属性）</p></li><li><p><code>Access-Control-Expose-Headers</code>:该字段可选。<code>CORS</code>请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</p></li></ul><h5 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h5><p>所谓复杂请求，即不满足上述条件的请求就是复杂请求。</p><p>比如请求的方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>复杂请求首先会发起一个预检请求，该请求是 <code>option</code> 方法的，通过该请求来知道服务端是否允许跨域请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://api.wang.com/cors'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>上面的请求就是一个复杂请求，当浏览器发现这是一个复杂请求之后，就会主动发出一个预检请求，询问服务器是否允许本次请求。</p><p>服务器收到预检请求之后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，才会做出相应的回应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.wang.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="CORS存在的问题"><a href="#CORS存在的问题" class="headerlink" title="CORS存在的问题"></a>CORS存在的问题</h4><p>不支持<code>IE8/9</code>，如果要在<code>IE8/9</code>使用<code>CORS</code>跨域需要使用<code>XDomainRequest</code>对象来支持<code>CORS</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;跨域是一个常考点，平常也有所了解，在这里做一个简单的总结。&lt;/p&gt;
&lt;h2 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; clas
      
    
    </summary>
    
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="CORS" scheme="http://yoursite.com/tags/CORS/"/>
    
      <category term="JSONP" scheme="http://yoursite.com/tags/JSONP/"/>
    
  </entry>
  
  <entry>
    <title>每日一题（二）</title>
    <link href="http://yoursite.com/2020/03/03/%E6%AF%8F%E6%97%A5%E9%95%80%E9%87%91/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/03/%E6%AF%8F%E6%97%A5%E9%95%80%E9%87%91/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-03-03T08:23:09.000Z</published>
    <updated>2020-03-22T06:54:19.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一题（二）"><a href="#每日一题（二）" class="headerlink" title="每日一题（二）"></a>每日一题（二）</h1><h2 id="常见的网站漏洞有哪些"><a href="#常见的网站漏洞有哪些" class="headerlink" title="常见的网站漏洞有哪些"></a>常见的网站漏洞有哪些</h2><p>有跨站脚本攻击（XSS）、跨站请求伪造（CSRF）、点击劫持、SQL注入、DDOS攻击、DNS劫持</p><h2 id="简单介绍一下XSS以及XSS如何防御"><a href="#简单介绍一下XSS以及XSS如何防御" class="headerlink" title="简单介绍一下XSS以及XSS如何防御"></a>简单介绍一下XSS以及XSS如何防御</h2><p>跨站脚本攻击是说攻击者通过注入恶意脚本，在用户浏览页面的时候进行攻击，比如获取cookie或者其他用户身份信息。</p><p>可以分为存储型和反射型：</p><ul><li>存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击</li><li>反射型不存储在数据库中，往往表现为将攻击代码放在URL地址的请求参数中</li></ul><h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><ol><li><strong>转义字符</strong>，对于用户输入的内容进行转义，如对引号、尖括号、斜杠进行转义</li><li><strong>CSP</strong>，CSP本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。通常可以通过两种方式实现GSP：<ul><li>设置HTTP Header中的Content-Security-Pplicy</li><li>设置meta标签方式</li></ul></li><li>输入内容长度控制</li><li>HTTP-Only Cookie：禁止JavaScript读取某些敏感Cookie，攻击者完成XSS注入后也无法窃取此Cookie</li><li>验证码：防止脚本冒充用户提交危险操作</li></ol><h2 id="简单介绍一下CSRF-跨站请求伪造-以及如何防御"><a href="#简单介绍一下CSRF-跨站请求伪造-以及如何防御" class="headerlink" title="简单介绍一下CSRF(跨站请求伪造)以及如何防御"></a>简单介绍一下CSRF(跨站请求伪造)以及如何防御</h2><p>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对呗攻击的网站执行某项操作的目的</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ol><li><strong>同源检测</strong>：验证 HTTP Referer 或者 Origin字段；它记录了该HTTP请求的来源地址</li><li><strong>在请求地址中添加token并验证</strong>：服务器下发一个随机Token，每次发送请求时将Token携带上，服务器验证Token是否有效</li><li>在HTTP头中自定义属性并验证。把token放到HTTP头的自定义属性里面</li><li><strong>不让第三方网站访问到用户Cookie</strong>:可以对设置 <strong>SameSite</strong> 属性。该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但该属性目前并不是所有浏览器都兼容。</li></ol><h2 id="判断数组的方法"><a href="#判断数组的方法" class="headerlink" title="判断数组的方法"></a>判断数组的方法</h2><h3 id="Object-property-toString-call"><a href="#Object-property-toString-call" class="headerlink" title="Object.property.toString.call()"></a>Object.property.toString.call()</h3><p>每一个继承 Object 的对象都有 <code>toString</code> 方法，如果 <code>toString</code> 方法没有重写，会返回 <code>[Object type]</code>，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 <code>toString</code> 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或 apply 方法改变 <code>toString</code> 方法的执行上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> an = [<span class="string">'Hello'</span>,<span class="string">'An'</span>];</span><br><span class="line">an.toString(); <span class="comment">// "Hello,An"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(an); <span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure><p>这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'An'</span>) <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>(<span class="number">1</span>)) <span class="comment">// "[object Symbol]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;<span class="attr">name</span>: <span class="string">'An'</span>&#125;) <span class="comment">// "[object Object]"</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 的内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p><p>使用 <code>instanceof</code>判断一个对象是否为数组，<code>instanceof</code> 会判断这个对象的原型链上是否会找到对应的 <code>Array</code> 的原型，找到返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]  <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但 <code>instanceof</code> 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]  <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p>该方法用来判断对象是否为数组</p><ul><li><p>instanceof 与 isArray：</p><p>当检测Array实例时，<code>Array.isArray</code> 优于 <code>instanceof</code> ，因为 <code>Array.isArray</code> 可以检测出 <code>iframes</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length<span class="number">-1</span>].Array;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correctly checking for Array</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Considered harmful, because doesn't work though iframes</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><code>Array.isArray()</code> 与 <code>Object.prototype.toString.call()</code><br><code>Array.isArray()</code>是ES5新增的方法，当不存在 <code>Array.isArray()</code> ，可以用 <code>Object.prototype.toString.call()</code> 实现。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;每日一题（二）&quot;&gt;&lt;a href=&quot;#每日一题（二）&quot; class=&quot;headerlink&quot; title=&quot;每日一题（二）&quot;&gt;&lt;/a&gt;每日一题（二）&lt;/h1&gt;&lt;h2 id=&quot;常见的网站漏洞有哪些&quot;&gt;&lt;a href=&quot;#常见的网站漏洞有哪些&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="每日一题系列" scheme="http://yoursite.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Xss" scheme="http://yoursite.com/tags/Xss/"/>
    
      <category term="CSRF" scheme="http://yoursite.com/tags/CSRF/"/>
    
      <category term="判断数组的方法" scheme="http://yoursite.com/tags/%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的进制转换</title>
    <link href="http://yoursite.com/2020/02/29/JavaScript/JavaScript%E7%9A%84%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/02/29/JavaScript/JavaScript%E7%9A%84%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-02-29T03:37:29.000Z</published>
    <updated>2020-02-29T03:56:37.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript的进制转换"><a href="#JavaScript的进制转换" class="headerlink" title="JavaScript的进制转换"></a>JavaScript的进制转换</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在刷算法题的时候，突然碰到了进制转换的相关问题。以前就有所了解，但还是做一下总结吧。</p><h2 id="神奇的JavaScript"><a href="#神奇的JavaScript" class="headerlink" title="神奇的JavaScript"></a>神奇的JavaScript</h2><p>JS 是一个很神奇的语言，内置的很多函数可以帮我们进行进制转换。</p><p>JS中可以直接使用16进制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0x5f</span>; <span class="comment">//95</span></span><br></pre></td></tr></table></figure><p>将任意进制字符串转换为十进制，利用parseInt()，其中第一个参数为需要转换的字符串；第二个参数从 <code>2</code> 到 <code>36</code>，代表该进位系统的数字，如果不传默认为十进制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"11"</span>, <span class="number">2</span>); <span class="comment">// 3 2进制转10进制 </span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"77"</span>, <span class="number">8</span>); <span class="comment">// 63 8进制转10进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">"af"</span>, <span class="number">16</span>); <span class="comment">//175 16进制转10进制</span></span><br></pre></td></tr></table></figure><p>将10进制转换为2进制，八进制，十六进制字符串<br>Object.toString(n) : 即 (n) 表示进制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">152</span>).toString(<span class="number">2</span>) <span class="comment">// "10011000" ; 先用括号将152转换“包”成一个对象， 或者如下写法;</span></span><br><span class="line"><span class="number">152.</span>.toString(<span class="number">2</span>) <span class="comment">// 这里第一个点将152转换成float类型的小数，第二个点是引出对象方法;</span></span><br><span class="line"><span class="number">152.</span>.toString(<span class="number">16</span>) <span class="comment">// "98" : 十进制转16进制</span></span><br><span class="line"><span class="number">152.</span>.toString(<span class="number">32</span>) <span class="comment">// "4o" ：十提制转32进制</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript的进制转换&quot;&gt;&lt;a href=&quot;#JavaScript的进制转换&quot; class=&quot;headerlink&quot; title=&quot;JavaScript的进制转换&quot;&gt;&lt;/a&gt;JavaScript的进制转换&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="进制转换" scheme="http://yoursite.com/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>模拟实现new</title>
    <link href="http://yoursite.com/2020/02/22/JavaScript/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0new/"/>
    <id>http://yoursite.com/2020/02/22/JavaScript/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0new/</id>
    <published>2020-02-22T10:51:27.000Z</published>
    <updated>2020-03-12T05:03:48.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟实现new"><a href="#模拟实现new" class="headerlink" title="模拟实现new"></a>模拟实现new</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今日复习一下new操作符，new是用于创建构造函数的实例，其中创建的实例对象拥有构造函数的属性、方法和原型上的属性和方法。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>分析</strong>：</p><p>因为 new 的结构是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，假设这个对象叫 obj，obj会具有构造函数里的属性，根据经典继承的例子，可以使用 Constructor.apply(obj,arguments) 来给 obj 添加新的属性。</p><p>根据原型及原型链的知识，我们可以知道实例的 <code>__proto__</code> 属性会指向构造函数的 prototype，所以用这个特性来实现实例访问原型上的属性</p><p><strong>代码</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj =  <span class="keyword">new</span> <span class="built_in">Object</span>(), <span class="comment">//从Object.prototype上克隆一个对象</span></span><br><span class="line">        Constructor = [].shift.call(<span class="built_in">arguments</span>); <span class="comment">//取得外部传入的构造器</span></span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    <span class="keyword">var</span> ret = Constructor.apply(obj,<span class="built_in">arguments</span>);<span class="comment">//借用外部传入的构造器给obj设置属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj;<span class="comment">//确保构造器总是返回一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">参考文献</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模拟实现new&quot;&gt;&lt;a href=&quot;#模拟实现new&quot; class=&quot;headerlink&quot; title=&quot;模拟实现new&quot;&gt;&lt;/a&gt;模拟实现new&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="new的模拟实现" scheme="http://yoursite.com/tags/new%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>模拟实现call、apply和bind</title>
    <link href="http://yoursite.com/2020/02/22/JavaScript/call%E3%80%81apply%E5%92%8Cbind/"/>
    <id>http://yoursite.com/2020/02/22/JavaScript/call%E3%80%81apply%E5%92%8Cbind/</id>
    <published>2020-02-22T06:11:20.000Z</published>
    <updated>2020-02-22T06:40:45.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟实现call、apply和bind"><a href="#模拟实现call、apply和bind" class="headerlink" title="模拟实现call、apply和bind"></a>模拟实现call、apply和bind</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>手动实现call、apply和bind是面试常考题，对这方面做一次梳理。</p><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;<span class="comment">//此处this是指调用myCall的function</span></span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn; <span class="comment">//将该函数删除</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.protptype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context=window</span>)</span>&#123;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">        result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = context.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> != <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'not a function'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> resFn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> resFn?<span class="keyword">this</span>:context,args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模拟实现call、apply和bind&quot;&gt;&lt;a href=&quot;#模拟实现call、apply和bind&quot; class=&quot;headerlink&quot; title=&quot;模拟实现call、apply和bind&quot;&gt;&lt;/a&gt;模拟实现call、apply和bind&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="模拟实现call、apply和bind" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E3%80%81apply%E5%92%8Cbind/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://yoursite.com/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/02/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-21T09:39:34.000Z</published>
    <updated>2020-02-22T10:08:15.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序、快速排序、希尔排序、堆排序"><a href="#归并排序、快速排序、希尔排序、堆排序" class="headerlink" title="归并排序、快速排序、希尔排序、堆排序"></a>归并排序、快速排序、希尔排序、堆排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之所以把这几类排序放在一起比较，是因为它们的平均时间复杂度都为 <code>O(nlogn)</code> </p><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分进行排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p>归并排序采用的是 <code>分治思想</code>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400a4920693?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="merge-sort-example.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 拆分成两个子数组</span></span><br><span class="line">  <span class="keyword">let</span> left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">    right = arr.slice(middle);</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="comment">// 比较两个数组大小排序</span></span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length) result.push(left.shift());</span><br><span class="line">  <span class="keyword">while</span> (right.length) result.push(right.shift());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr :'</span>, mergeSort(arr));</span><br><span class="line"><span class="comment">// arr : [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure><p>空间复杂度O(n)，时间复杂度O(nlogn)</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400a943f4fc?imageslim" alt="merge-sort.gif"></p><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p>快速排序顾名思义速度快，而且效率高，是处理大数据最快的排序算法之一。</p><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><ul><li>先找到一个基准点（一般只数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，小的放左边，反之放右边</li><li>左右分别用一个空数组存储比较后的数据</li><li>循环执行上述操作</li></ul><p>特点： 快速，常用<br>缺点： 需要另外声明两个数组，浪费了内存空间资源</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">  <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 取基准点</span></span><br><span class="line">  <span class="keyword">var</span> pivot = arr.splice(pivotIndex,<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> left = [] <span class="comment">//存放比基准点小的数组</span></span><br><span class="line">  <span class="keyword">var</span> right = [] <span class="comment">//存放比基准点大的数组</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat(pivot,quickSort(right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">85</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">96</span>, <span class="number">50</span>]</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(array));</span><br><span class="line"><span class="comment">//[17, 24, 31, 45,50, 63, 85, 96]</span></span><br></pre></td></tr></table></figure><h3 id="归并和快排的区别"><a href="#归并和快排的区别" class="headerlink" title="归并和快排的区别"></a>归并和快排的区别</h3><p>快排和归并都是用分治思想，也是利用递归实现，它们之间的区别在哪里呢？</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400af40f991?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="快速排序与归并排序"></p><p>区别：</p><ul><li>归并排序的处理过程是<code>由下而上</code>的，先处理子问题，然后再合并。</li><li>而快排正好相反，它的处理过程是<code>由上而下</code>的，先分区，然后再处理子问题。</li><li>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。</li><li>归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。</li><li>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</li></ul><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><ul><li>先将整个待排序的记录序列分割成为若干子序列</li><li>分别进行直接插入排序</li><li>待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序</li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>举个易于理解的例子：[35, 33, 42, 10, 14, 19, 27, 44]，我们采取间隔 4。创建一个位于 4 个位置间隔的所有值的虚拟子列表。下面这些值是 { 35, 14 }，{ 33, 19 }，{ 42, 27 } 和 { 10, 44 }。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400c7272496?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="栗子"></p><ol start="2"><li>我们比较每个子列表中的值，并在原始数组中交换它们（如果需要）。完成此步骤后，新数组应如下所示。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400d228f608?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="栗子"></p><ol start="3"><li>然后，我们采用 2 的间隔，这个间隙产生两个子列表：{ 14, 27, 35, 42 }， { 19, 10, 33, 44 }。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400d8c0378c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="栗子"></p><ol start="4"><li>我们比较并交换原始数组中的值（如果需要）。完成此步骤后，数组变成：[14, 10, 27, 19, 35, 33, 42, 44]，图如下所示，10 与 19 的位置互换一下。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400deeea4b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p><ol start="5"><li>最后，我们使用值间隔 1 对数组的其余部分进行排序，Shell sort 使用插入排序对数组进行排序。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400f86526f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="栗子"></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shellSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length,</span><br><span class="line">    temp, gap = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 动态定义间隔序列</span></span><br><span class="line">    gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      temp = arr[i];</span><br><span class="line">      <span class="keyword">let</span> j = i - gap;</span><br><span class="line">      <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">        arr[j + gap] = arr[j]</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + gap] = temp;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'arr  :'</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">35</span>, <span class="number">33</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">44</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'原始array:'</span>, array);</span><br><span class="line"><span class="keyword">const</span> newArr = shellSort(array);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'newArr:'</span>, newArr);</span><br><span class="line"><span class="comment">// 原始 array:   [35, 33, 42, 10, 14, 19, 27, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 33, 42, 10, 35, 19, 27, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 19, 42, 10, 35, 33, 27, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [10, 14, 19, 27, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [10, 14, 19, 27, 35, 33, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]</span></span><br><span class="line"><span class="comment">// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]</span></span><br><span class="line"><span class="comment">// newArr:     [10, 14, 19, 27, 33, 35, 42, 44]</span></span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>第一，希尔排序是原地排序算法吗 ？ 希尔排序过程中，只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1) 。所以，希尔排序是<code>原地排序</code>算法。</li><li>第二，希尔排序是稳定的排序算法吗 ？ 我们知道，单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素相对顺序发生变化。 因此，希尔排序<code>不稳定</code>。</li><li>第三，希尔排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n logn)。 最差情况：T(n) = O(n (log(n))2)。 平均情况：T(n) = 取决于间隙序列。</li></ul><h3 id="动画-1"><a href="#动画-1" class="headerlink" title="动画"></a>动画</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f400f870146a?imageslim" alt="shell-sort.gif"></p><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p><strong>堆的定义</strong></p><p>堆其实是一种特殊的树。只要满足这两点，它就是一个堆。</p><ul><li>堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</li></ul><p>对于每个节点的值都<code>大于等于</code>子树中每个节点值的堆，我们叫作<code>大顶堆</code>。 对于每个节点的值都<code>小于等于</code>子树中每个节点值的堆，我们叫作<code>小顶堆</code>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f40107bab9d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="区分堆、大顶堆、小顶堆"></p><p>其中图 1 和 图 2 是大顶堆，图 3 是小顶堆，图 4 不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。</p><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><ol><li>将初始待排序关键字序列 (R1, R2 …. Rn) 构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1, R2, ….. Rn-1) 和新的有序区 (Rn) ，且满足 R[1, 2 … n-1] &lt;= R[n]。</li><li>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1, R2 …… Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1, R2 …. Rn-2) 和新的有序区 (Rn-1, Rn)。不断重复此过程，直到有序区的元素个数为 n - 1，则整个排序过程完成。</li></ol><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="keyword">const</span> heapSort = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'堆排序耗时'</span>);</span><br><span class="line"><span class="comment">// 初始化大顶堆，从第一个非叶子结点开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">heapify(array, i, array.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序，每一次 for 循环找出一个当前最大值，数组长度减一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(array.length - <span class="number">1</span>); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">// 根节点与最后一个节点交换</span></span><br><span class="line">swap(array, <span class="number">0</span>, i);</span><br><span class="line"><span class="comment">// 从根节点开始调整，并且最后一个结点已经为当前最大值，不需要再参与比较，所以第三个参数为 i，即比较到最后一个结点前一个即可</span></span><br><span class="line">heapify(array, <span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'堆排序耗时'</span>);</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个节点</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">array, i, j</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> temp = array[i];</span><br><span class="line">array[i] = array[j];</span><br><span class="line">array[j] = temp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 i 结点以下的堆整理为大顶堆，注意这一步实现的基础实际上是：</span></span><br><span class="line"><span class="comment">// 假设结点 i 以下的子堆已经是一个大顶堆，heapify 函数实现的</span></span><br><span class="line"><span class="comment">// 功能是实际上是：找到 结点 i 在包括结点 i 的堆中的正确位置。</span></span><br><span class="line"><span class="comment">// 后面将写一个 for 循环，从第一个非叶子结点开始，对每一个非叶子结点</span></span><br><span class="line"><span class="comment">// 都执行 heapify 操作，所以就满足了结点 i 以下的子堆已经是一大顶堆</span></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function">(<span class="params">array, i, length</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> temp = array[i]; <span class="comment">// 当前父节点</span></span><br><span class="line"><span class="comment">// j &lt; length 的目的是对结点 i 以下的结点全部做顺序调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span> * i + <span class="number">1</span>; j &lt; length; j = <span class="number">2</span> * j + <span class="number">1</span>) &#123;</span><br><span class="line">temp = array[i]; <span class="comment">// 将 array[i] 取出，整个过程相当于找到 array[i] 应处于的位置</span></span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt; length &amp;&amp; array[j] &lt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">j++; <span class="comment">// 找到两个孩子中较大的一个，再与父节点比较</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; array[j]) &#123;</span><br><span class="line">swap(array, i, j); <span class="comment">// 如果父节点小于子节点:交换；否则跳出</span></span><br><span class="line">i = j; <span class="comment">// 交换后，temp 的下标变为 j</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'原始array:'</span>, array);</span><br><span class="line"><span class="keyword">const</span> newArr = heapSort(array);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'newArr:'</span>, newArr);</span><br><span class="line"><span class="comment">// 原始 array:  [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]</span></span><br><span class="line"><span class="comment">// 堆排序耗时: 0.15087890625ms</span></span><br><span class="line"><span class="comment">// newArr:     [1, 2, 2, 3, 4, 5, 5, 6, 8, 9]</span></span><br></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li><p>第一，堆排序是原地排序算法吗 ？ 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。</p></li><li><p>第二，堆排序是稳定的排序算法吗 ？ 因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。 所以，堆排序是<code>不稳定</code>的排序算法。</p></li><li><p>第三，堆排序的时间复杂度是多少 ？ 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。 最佳情况：T(n) = O(nlogn)。 最差情况：T(n) = O(nlogn)。 平均情况：T(n) = O(nlogn)。</p></li></ul><h3 id="动画-2"><a href="#动画-2" class="headerlink" title="动画"></a>动画</h3><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f40108015de8?imageslim" alt="heap-sort.gif"></p><p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1f4011e30a700?imageslim" alt="heap-sort2.gif"></p><h2 id="排序算法的复杂性对比"><a href="#排序算法的复杂性对比" class="headerlink" title="排序算法的复杂性对比"></a>排序算法的复杂性对比</h2><table><thead><tr><th align="center">名称</th><th align="center">最好</th><th align="center">平均</th><th align="center">最坏</th><th align="center">内存</th><th align="center">稳定性</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">归并排序</td><td align="center">nlog(n)</td><td align="center">nlog(n)</td><td align="center">nlog(n)</td><td align="center">n</td><td align="center">Yes</td><td align="center">…</td></tr><tr><td align="center">快速排序</td><td align="center">nlog(n)</td><td align="center">nlog(n)</td><td align="center">n2</td><td align="center">log(n)</td><td align="center">No</td><td align="center">在 in-place 版本下，内存复杂度通常是 O(log(n))</td></tr><tr><td align="center">希尔排序</td><td align="center">nlog(n)</td><td align="center">取决于差距序列</td><td align="center">n(log(n))2</td><td align="center">1</td><td align="center">No</td><td align="center">…</td></tr><tr><td align="center">堆排序</td><td align="center">nlog(n)</td><td align="center">nlog(n)</td><td align="center">nlog(n)</td><td align="center">1</td><td align="center">No</td><td align="center">…</td></tr></tbody></table><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢前辈的文章：</p><ul><li><a href="https://juejin.im/post/5d371aa6e51d455d850d3bbe" target="_blank" rel="noopener">数据结构与算法之美</a></li></ul><ul><li><a href="https://segmentfault.com/a/1190000015487916" target="_blank" rel="noopener">JS 实现堆排序</a></li><li><a href="https://time.geekbang.org/column/article/41913" target="_blank" rel="noopener">数据结构与算法之美</a></li><li><a href="https://juejin.im/post/57dcd394a22b9d00610c5ec8" target="_blank" rel="noopener">十大经典排序算法总结（JavaScript 描述）</a></li><li><a href="https://juejin.im/post/58c9d5fb1b69e6006b686bce" target="_blank" rel="noopener">JS 中可能用得到的全部的排序算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;归并排序、快速排序、希尔排序、堆排序&quot;&gt;&lt;a href=&quot;#归并排序、快速排序、希尔排序、堆排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序、快速排序、希尔排序、堆排序&quot;&gt;&lt;/a&gt;归并排序、快速排序、希尔排序、堆排序&lt;/h1&gt;&lt;h2 id=&quot;前
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="http://yoursite.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="http://yoursite.com/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>外卖项目总结</title>
    <link href="http://yoursite.com/2020/02/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/02/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-20T08:56:16.000Z</published>
    <updated>2020-02-20T08:57:51.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Vue做的外卖项目"><a href="#基于Vue做的外卖项目" class="headerlink" title="基于Vue做的外卖项目"></a>基于Vue做的外卖项目</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于外卖项目做一个总结，写一些心得和在项目中遇到的难点和一些常用知识点，让自己对于 <code>Vue</code> 有更加深刻的体会。</p><h2 id="首页轮播区域"><a href="#首页轮播区域" class="headerlink" title="首页轮播区域"></a>首页轮播区域</h2><p>首页轮播区域是用 Swiper 插件做的，Swiper 常用于移动端网站的内容触摸滑动，是存 <code>JavaScript</code> 打造的滑动特效插件。</p><p>其中后台传过来的内容是一维数组，而首页的逻辑是只显示8条数据，多出来的放在下一页，所以需要对数据进行进一步的封装，封装成二维数组，这其中就需要一个外部数组和内部数组，通过判断内部数组的长度再将内部数组放入外部数组，以此类推。</p><p>而对于用 Swiper 插件会遇到插件不起作用的问题，这就是异步加载数据的问题。我们需要用 <code>watch</code> 和 <code>nextTick</code> 一起使用解决这个问题。其中 <code>watch</code> 是监听数据的改变,数据更新了在更新界面之前执行， 而 <code>nextTick</code>  是在界面更新之后立即执行。</p><h2 id="Star组件"><a href="#Star组件" class="headerlink" title="Star组件"></a>Star组件</h2><p>这是一个评分组件，其中需要通过 props 传递  <code>Size</code> 和 <code>score</code> 其中需要 v-for 渲染 class，来决定星星的数量，通过 <code>score</code> 来计算用的是全星还是半星，其中需要 Math.floor() 计算出整数，在四舍五入计算出半星，最后补全。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理是运行到前台服务器，拦截前台服务器发送过来的请求，转发给后台获取后台的响应，再将响应发送给前台服务器 </p><h2 id="mock-js"><a href="#mock-js" class="headerlink" title="mock.js"></a>mock.js</h2><p>生成随机数据，拦截 Ajax 请求</p><h2 id="shopGoods"><a href="#shopGoods" class="headerlink" title="shopGoods"></a>shopGoods</h2><p>在 shopGoods 组件中，有一个左右联动的菜单页面，左侧和右侧列表相关联</p><p>当滑动右侧列表时，左侧列表会更新到当前分类，</p><p>当点击左侧某个分类时，右侧会滑动到对应的分类位置</p><p>对于滑动用的是 better-scroll 库，其中点击右侧列表然后左侧列表到达对应的类用的是 scrollTo</p><p>在 tops 数组中找到对应的区间是使用 findIndex，传入回调函数计算对应的区间</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于左右侧列表我们需要以下条件来实现：</p><ul><li>current类，来对当前分类进行高亮显示</li><li>currentIndex，一个计算属性来判断和哪一个分类的下标一样</li><li>scrollY，右侧列表滑动到的Y坐标</li><li>tops，所有右侧分类 li 的 top 组成的数组</li></ul><h2 id="cartControl"><a href="#cartControl" class="headerlink" title="cartControl"></a>cartControl</h2><p>其中有一个对 count 的加减，因为 count 是新增属性，是不会显示到页面上（没有数据绑定）</p><p>通过 Vue.set，让新增的属性也有数据绑定</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>购物车部分包括：</p><p>对物品的添加和删减的操作，这就是 cartControl 组件，</p><p>其中要通过记录购物车有哪些物品和物品的数量计算总价格，通过 Vuex 来管理，将商品保存到state里，对于计算物品的价格和数量放在 getter 里进行计算，最后通过取出这些数据进行显示，当商品达到起送价格后方可结算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于Vue做的外卖项目&quot;&gt;&lt;a href=&quot;#基于Vue做的外卖项目&quot; class=&quot;headerlink&quot; title=&quot;基于Vue做的外卖项目&quot;&gt;&lt;/a&gt;基于Vue做的外卖项目&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="外卖项目" scheme="http://yoursite.com/tags/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="http://yoursite.com/2020/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/HTTP/"/>
    <id>http://yoursite.com/2020/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%81%E5%AE%89%E5%85%A8/HTTP/</id>
    <published>2020-02-20T07:52:57.000Z</published>
    <updated>2020-02-26T04:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>超文本传输协议（HyperText Transfer Protocol）</p><p>HTTP协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据时，会发出一次HTTP请求。HTTP会通过TCP建立起一个到服务器的连接通道，当本次请求完毕后，HTTP会立即将TCP连接断开，这个过程很短。所以HTTP连接是一个短连接，是一种无状态连接。</p><h2 id="http传输流"><a href="#http传输流" class="headerlink" title="http传输流"></a>http传输流</h2><p><img src="https://user-gold-cdn.xitu.io/2018/4/17/162d19df66466f6b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>常用状态码：</p><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>206 Partial Content，进行范围请求</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的URL</li><li>303 see other，表示资源存在着另一个URL，应使用GET方法定向获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和302含义相同</li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h2 id="http1-0-http1-1-http2-0-特性及区别"><a href="#http1-0-http1-1-http2-0-特性及区别" class="headerlink" title="http1.0 http1.1 http2.0 特性及区别"></a>http1.0 http1.1 http2.0 特性及区别</h2><h3 id="http1-0特性"><a href="#http1-0特性" class="headerlink" title="http1.0特性"></a>http1.0特性</h3><ul><li>无状态：服务器不跟踪记录请求过的状态</li><li>无连接：浏览器每次请求都需要建立tcp连接</li></ul><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录</p><h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>无连接导致性能缺陷有两种：</p><ol><li>无复用连接：<br>每次发送请求都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低</li><li>队头阻塞<br>http1.0规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也会阻塞</li></ol><h3 id="http1-1特性"><a href="#http1-1特性" class="headerlink" title="http1.1特性"></a>http1.1特性</h3><p>http1.1的出现是为了解决http1.0性能缺陷</p><p>http1.1特性：</p><ul><li>长连接：新增connection字段，可以设置keep-alive值保持连接不断开</li><li>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回</li><li>缓存处理：新增字段cache-control</li><li>断点传输</li></ul><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>http1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据</p><h4 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h4><p>基于长连接的基础，我们先看没有管道化请求响应：</p><p>tcp没有断开，用的同一个通道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</span><br></pre></td></tr></table></figure><p>管道化的请求响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求1 --&gt; 请求2 --&gt; 请求3 &gt; 响应1 --&gt; 响应2 --&gt; 响应3</span><br></pre></td></tr></table></figure><p>即使服务器先准备好响应2,也是按照请求顺序先返回响应1</p><p>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p><h4 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h4><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求</p><p>通过设置字段cache-control来控制</p><h4 id="断点传输"><a href="#断点传输" class="headerlink" title="断点传输"></a>断点传输</h4><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p><p>在 Header 里两个参数实现的，客户端发请求时对应的是 Range 服务器端响应时对应的是 Content-Range</p><h3 id="http2-0特性"><a href="#http2-0特性" class="headerlink" title="http2.0特性"></a>http2.0特性</h3><ul><li>二进制分帧</li><li>多路复用：在共享TCP连接的基础上同时发送请求和响应</li><li>头部压缩</li><li>服务器推送：服务器可以额外的项客户端推送资源，而无需客户端明确的请求</li></ul><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>http1.0 到http1.1的主要区别，就是从无连接到长连接</li><li>http2.0对比1.X版本主要区别就是多路复用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;超文本传输协议（HyperText Transfer Protocol）&lt;/p&gt;
&lt;p&gt;HTTP协议是建立在TCP协议基础之
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="http1.0 http1.1 http2.0" scheme="http://yoursite.com/tags/http1-0-http1-1-http2-0/"/>
    
  </entry>
  
</feed>
